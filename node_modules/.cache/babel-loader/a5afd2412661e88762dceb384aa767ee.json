{"ast":null,"code":"//TODO: Implement 3D model imports\nimport Transform from \"./Transform\";\nimport ShapeGenerator from \"./ShapeGenerator\";\n\nclass Mesh {\n  constructor(gl) {\n    this.gl = gl;\n    this.totalVertices = 0;\n    this.color = [0.5, 0.5, 0.5];\n    this.shape = null;\n    this.transform = new Transform();\n  }\n  /*\r\n  clone() {\r\n      let clone = new Mesh(this.gl);\r\n        if (this.shape === 'cube')\r\n          clone.createCube();\r\n      else if (this.shape === 'sphere')\r\n          clone.createSphere(64);\r\n        clone.setColor(this.color);\r\n      clone.transform = this.transform.clone();\r\n      return clone;\r\n  }\r\n  */\n\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  setPosition(pos) {\n    this.transform.setPosition(pos);\n  }\n\n  setScale(scale) {\n    this.transform.setScale(scale);\n  }\n\n  setRotation(rot) {\n    this.transform.setRotation(rot);\n  }\n\n  render(shader) {\n    if (this.shape) {\n      // Activate the shader\n      shader.activate(); // Set shader uniforms for this mesh\n\n      this.bindBuffersAndEnableAttributes(shader);\n      this.updateUniforms(shader); // Draw our graphics\n      // Param 1 specifies how to draw from vertices,\n      // param 2 is how many vertices we use to draw\n      // param 3 is what type the elements are\n      // param 4 is the starting point from the array\n\n      if (this.shape === \"LINE\") this.gl.drawElements(this.gl.LINES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);else this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\n      this.unbindBuffers();\n    } else {\n      console.log(\"ERROR! The mesh got no shape!\");\n    }\n  }\n\n  updateUniforms(shader) {\n    this.gl.uniformMatrix4fv(shader.modelViewUniformLocation, this.gl.FALSE, this.transform.matrix);\n    this.gl.uniform3fv(shader.colorUniformLocation, this.color);\n  }\n\n  unbindBuffers() {\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  bindBuffersAndEnableAttributes(shader) {\n    // Vertex buffer\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); // Enable vertex attribute\n\n    this.gl.vertexAttribPointer(shader.positionAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.FALSE, // Don't normalize the data\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\n    0 // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(shader.positionAttributeLocation); // Enable normal attribute\n\n    this.gl.vertexAttribPointer(shader.normalAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.TRUE, // Not normalized\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\n    3 * Float32Array.BYTES_PER_ELEMENT // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(shader.normalAttributeLocation); // Index buffer\n\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  }\n\n  createBuffers(vertices, indices) {\n    // Create vertex and normal buffer\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createCylinderSmooth(vertSeg, horizSeg, radius, height) {\n    this.shape = 'cylinder';\n    let cylinderData = ShapeGenerator.createCylinderSmooth(vertSeg, horizSeg, radius, height);\n    this.totalVertices = cylinderData.numVertices; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cylinderData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createCylinderSharp(vertSegs, radius, height) {\n    this.shape = 'cylinder';\n    let cylinderData = ShapeGenerator.createCylinderSharp(vertSegs, radius, height);\n    this.totalVertices = cylinderData.numVertices;\n    this.createBuffers(cylinderData.vertices, cylinderData.indices);\n  }\n\n  createSphere(segments) {\n    this.shape = 'sphere';\n    let sphereData = ShapeGenerator.createSphere(segments, 1.0);\n    this.totalVertices = sphereData.numVertices;\n    this.createBuffers(sphereData.vertices, sphereData.indices);\n  }\n\n  createCube() {\n    this.shape = 'cube';\n    let cubeData = ShapeGenerator.createCube();\n    this.totalVertices = cubeData.numVertices;\n    this.createBuffers(cubeData.vertices, cubeData.indices);\n  }\n\n  createPlane(rows, columns) {\n    this.shape = 'plane';\n    let index = 0;\n    let x = 0;\n    let vertexArray = []; // Generate and store coordinates in vertex array\n\n    for (let i = 0; i <= columns; ++i) {\n      x = -(rows / 2);\n\n      for (let k = 0; k <= rows; ++k) {\n        // Storing one vertex at the time (x,y,z)\n        vertexArray[index] = x;\n        vertexArray[index + 1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\n\n        vertexArray[index + 2] = -i; // Set normals\n\n        vertexArray[index + 3] = 0.0;\n        vertexArray[index + 4] = 1.0;\n        vertexArray[index + 5] = 0.0; // Texture coordinates\n\n        vertexArray[index + 6] = 0.0;\n        vertexArray[index + 7] = 0.0; // We go from left to right in the direction of x-axis\n\n        ++x; // Increase by three since we store values in three indices at the time\n\n        index += 8;\n      }\n    } // v0-v3 represent the four vertices in one quad\n\n\n    let v0 = 0;\n    let v1 = 1;\n    let v2 = rows + 2;\n    let v3 = rows + 1;\n    index = 0;\n    let indexArray = []; // Store indices in index array\n\n    for (let j = 0; j < columns; ++j) {\n      // Each iteration generates the order of vertex indices for one full quad\n      for (let l = 0; l < rows; ++l) {\n        // Triangle 1\n        indexArray[index] = v0;\n        indexArray[index + 1] = v1;\n        indexArray[index + 2] = v2; // Triangle 2\n\n        indexArray[index + 3] = v2;\n        indexArray[index + 4] = v3;\n        indexArray[index + 5] = v0; // Increase for next quad\n\n        ++v0;\n        ++v1;\n        ++v2;\n        ++v3;\n        index += 6;\n      } // Increase one more time after a full row of quads\n\n\n      ++v0;\n      ++v1;\n      ++v2;\n      ++v3;\n    } //this.totalTriangles = rows*columns*2;\n    //this.totalVertices = this.totalTriangles*3;\n\n\n    this.totalVertices = indexArray.length;\n    this.createBuffers(vertexArray, indexArray);\n  }\n\n  createLine(vertices, indices) {\n    this.shape = \"LINE\";\n    this.totalVertices = indices.length;\n    this.createBuffers(vertices, indices);\n  }\n\n}\n\nexport default Mesh;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Mesh.js"],"names":["Transform","ShapeGenerator","Mesh","constructor","gl","totalVertices","color","shape","transform","setColor","setPosition","pos","setScale","scale","setRotation","rot","render","shader","activate","bindBuffersAndEnableAttributes","updateUniforms","drawElements","LINES","UNSIGNED_SHORT","TRIANGLES","unbindBuffers","console","log","uniformMatrix4fv","modelViewUniformLocation","FALSE","matrix","uniform3fv","colorUniformLocation","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","vertexBuffer","vertexAttribPointer","positionAttributeLocation","FLOAT","Float32Array","BYTES_PER_ELEMENT","enableVertexAttribArray","normalAttributeLocation","TRUE","indexBuffer","createBuffers","vertices","indices","createBuffer","bufferData","STATIC_DRAW","Uint16Array","createCylinderSmooth","vertSeg","horizSeg","radius","height","cylinderData","numVertices","createCylinderSharp","vertSegs","createSphere","segments","sphereData","createCube","cubeData","createPlane","rows","columns","index","x","vertexArray","i","k","v0","v1","v2","v3","indexArray","j","l","length","createLine"],"mappings":"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","sourcesContent":["//TODO: Implement 3D model imports\r\n\r\nimport Transform from \"./Transform\";\r\nimport ShapeGenerator from \"./ShapeGenerator\";\r\n\r\nclass Mesh {\r\n    constructor(gl) {\r\n        this.gl = gl;\r\n\r\n        this.totalVertices = 0;\r\n\r\n        this.color = [0.5, 0.5, 0.5];\r\n        this.shape = null;\r\n\r\n        this.transform = new Transform();\r\n    }\r\n\r\n    /*\r\n    clone() {\r\n        let clone = new Mesh(this.gl);\r\n\r\n        if (this.shape === 'cube')\r\n            clone.createCube();\r\n        else if (this.shape === 'sphere')\r\n            clone.createSphere(64);\r\n\r\n        clone.setColor(this.color);\r\n        clone.transform = this.transform.clone();\r\n        return clone;\r\n    }\r\n    */\r\n\r\n    setColor(color) {\r\n        this.color = color;\r\n    }\r\n\r\n    setPosition(pos) {\r\n        this.transform.setPosition(pos);\r\n    }\r\n\r\n    setScale (scale) {\r\n        this.transform.setScale(scale);\r\n    }\r\n\r\n    setRotation (rot) {\r\n        this.transform.setRotation(rot);\r\n    }\r\n\r\n    render(shader) {\r\n        if (this.shape) {\r\n            // Activate the shader\r\n            shader.activate();\r\n            // Set shader uniforms for this mesh\r\n            this.bindBuffersAndEnableAttributes(shader);\r\n            this.updateUniforms(shader);\r\n            // Draw our graphics\r\n            // Param 1 specifies how to draw from vertices,\r\n            // param 2 is how many vertices we use to draw\r\n            // param 3 is what type the elements are\r\n            // param 4 is the starting point from the array\r\n            if (this.shape === \"LINE\")\r\n                this.gl.drawElements(this.gl.LINES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\r\n            else\r\n                this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\r\n\r\n            this.unbindBuffers();\r\n        }\r\n        else {\r\n            console.log(\"ERROR! The mesh got no shape!\");\r\n        }\r\n    }\r\n\r\n    updateUniforms(shader) {\r\n        this.gl.uniformMatrix4fv(shader.modelViewUniformLocation, this.gl.FALSE, this.transform.matrix);\r\n        this.gl.uniform3fv(shader.colorUniformLocation, this.color);\r\n    }\r\n\r\n    unbindBuffers() {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    bindBuffersAndEnableAttributes(shader) {\r\n        // Vertex buffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n\r\n        // Enable vertex attribute\r\n        this.gl.vertexAttribPointer(\r\n            shader.positionAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.FALSE, // Don't normalize the data\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\r\n            0// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(shader.positionAttributeLocation);\r\n\r\n        // Enable normal attribute\r\n        this.gl.vertexAttribPointer(\r\n            shader.normalAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.TRUE, // Not normalized\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\r\n            3 * Float32Array.BYTES_PER_ELEMENT// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(shader.normalAttributeLocation);\r\n\r\n        // Index buffer\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n    }\r\n\r\n    createBuffers(vertices, indices) {\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createCylinderSmooth (vertSeg, horizSeg, radius, height) {\r\n        this.shape = 'cylinder';\r\n\r\n        let cylinderData = ShapeGenerator.createCylinderSmooth(vertSeg, horizSeg, radius, height);\r\n        this.totalVertices = cylinderData.numVertices;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cylinderData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createCylinderSharp (vertSegs, radius, height) {\r\n        this.shape = 'cylinder';\r\n\r\n        let cylinderData = ShapeGenerator.createCylinderSharp(vertSegs, radius, height);\r\n        this.totalVertices = cylinderData.numVertices;\r\n\r\n        this.createBuffers(cylinderData.vertices, cylinderData.indices);\r\n    }\r\n\r\n    createSphere (segments) {\r\n        this.shape = 'sphere';\r\n\r\n        let sphereData = ShapeGenerator.createSphere(segments, 1.0);\r\n        this.totalVertices = sphereData.numVertices;\r\n\r\n        this.createBuffers(sphereData.vertices, sphereData.indices);\r\n    }\r\n\r\n    createCube() {\r\n        this.shape = 'cube';\r\n        let cubeData = ShapeGenerator.createCube();\r\n        this.totalVertices = cubeData.numVertices;\r\n\r\n        this.createBuffers(cubeData.vertices, cubeData.indices);\r\n    }\r\n\r\n    createPlane (rows, columns) {\r\n        this.shape = 'plane';\r\n\r\n        let index = 0;\r\n        let x = 0;\r\n        let vertexArray = [];\r\n        // Generate and store coordinates in vertex array\r\n        for (let i = 0; i <= columns; ++i) {\r\n            x = -(rows/2);\r\n            for (let k = 0; k <= rows; ++k) {\r\n                // Storing one vertex at the time (x,y,z)\r\n                vertexArray[index] = x;\r\n                vertexArray[index+1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\r\n                vertexArray[index+2] = -i;\r\n\r\n                // Set normals\r\n                vertexArray[index+3] = 0.0;\r\n                vertexArray[index+4] = 1.0;\r\n                vertexArray[index+5] = 0.0;\r\n\r\n                // Texture coordinates\r\n                vertexArray[index+6] = 0.0;\r\n                vertexArray[index+7] = 0.0;\r\n\r\n                // We go from left to right in the direction of x-axis\r\n                ++x;\r\n                // Increase by three since we store values in three indices at the time\r\n                index += 8;\r\n            }\r\n        }\r\n\r\n        // v0-v3 represent the four vertices in one quad\r\n        let v0 = 0;\r\n        let v1 = 1;\r\n        let v2 = rows+2;\r\n        let v3 = rows+1;\r\n        index = 0;\r\n        let indexArray = [];\r\n        // Store indices in index array\r\n        for (let j = 0; j < columns; ++j) {\r\n            // Each iteration generates the order of vertex indices for one full quad\r\n            for (let l = 0; l < rows; ++l) {\r\n                // Triangle 1\r\n                indexArray[index] = v0;\r\n                indexArray[index + 1] = v1;\r\n                indexArray[index + 2] = v2;\r\n                // Triangle 2\r\n                indexArray[index + 3] = v2;\r\n                indexArray[index + 4] = v3;\r\n                indexArray[index + 5] = v0;\r\n\r\n                // Increase for next quad\r\n                ++v0;\r\n                ++v1;\r\n                ++v2;\r\n                ++v3;\r\n                index += 6;\r\n            }\r\n            // Increase one more time after a full row of quads\r\n            ++v0;\r\n            ++v1;\r\n            ++v2;\r\n            ++v3;\r\n        }\r\n        //this.totalTriangles = rows*columns*2;\r\n        //this.totalVertices = this.totalTriangles*3;\r\n        this.totalVertices = indexArray.length;\r\n\r\n        this.createBuffers(vertexArray, indexArray);\r\n    };\r\n\r\n    createLine (vertices, indices) {\r\n        this.shape = \"LINE\";\r\n        this.totalVertices = indices.length;\r\n\r\n\r\n        this.createBuffers(vertices, indices);\r\n    }\r\n}\r\n\r\nexport default Mesh;"]},"metadata":{},"sourceType":"module"}