{"ast":null,"code":"class ShapeGenerator {\n  static createCube(x = 1.0, y = 1.0, z = 1.0) {\n    // Vertex coordinates, normals and texture coordinates\n    let vertexArray = [// Vertex         Normal             Texture coordinates\n    // Vertex 0\n    -x, -y, -z, 0.0, -1.0, 0.0, 0.0, 1.0, -x, -y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, // Vertex 1\n    -x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, z, 0.0, 0.0, 1.0, 0.0, 1.0, -x, -y, z, -1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 2\n    x, -y, z, 0.0, -1.0, 0.0, 1.0, 0.0, x, -y, z, 0.0, 0.0, 1.0, 1.0, 1.0, x, -y, z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 3\n    x, -y, -z, 0.0, -1.0, 0.0, 1.0, 1.0, x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, -y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 4\n    -x, y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, -x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 5\n    -x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, y, z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 6\n    x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, y, z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 7\n    x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0]; // Vertex indices\n\n    let indexArray = [// Bottom\n    0, 9, 6, // v0, v3, v2\n    6, 3, 0, // v2, v1, v0\n    // Front\n    4, 7, 18, // v1, v2, v6\n    18, 15, 4, // v6, v5, v1\n    // Left\n    1, 5, 16, // v0, v1, v5\n    16, 12, 1, // v5, v4, v0\n    // Back\n    2, 13, 21, // v0, v4, v7\n    21, 10, 2, // v7, v3, v0\n    // Right\n    8, 11, 22, // v2, v3, v7\n    22, 19, 8, // v7, v6, v2\n    // Top\n    14, 17, 20, // v4, v5, v6\n    20, 23, 14 // v6, v7, v4\n    ];\n    let totalTriangles = 12;\n    let totalVertices = totalTriangles * 3;\n    return {\n      numVertices: totalVertices,\n      vertices: vertexArray,\n      indices: indexArray\n    };\n  }\n\n  static createSphere(segments, radius) {\n    let numHorizontalSegments = segments; // Minium amount of horizontal segments is 2\n\n    if (numHorizontalSegments < 2) {\n      numHorizontalSegments = 2;\n    } // Number of vertical segments of the sphere\n\n\n    let numVerticalSegments = 2 * numHorizontalSegments;\n    let numVertices = 1 + (numHorizontalSegments - 1) * numVerticalSegments + 1; // top + middle + bottom\n\n    let numTriangles = numVerticalSegments + (numHorizontalSegments - 2) * 4 * numHorizontalSegments + numVerticalSegments; // top + middle + bottom\n    // Floats per row: position(x,y,z), normal(x,y,z), texture(s,t)\n\n    let stride = 8;\n    let vertices = []; // Initialize vertex array\n\n    let indices = []; // Initialize index array\n\n    /** Generate vertex array **/\n    // Bottom vertex\n\n    vertices[0] = 0.0;\n    vertices[1] = -radius;\n    vertices[2] = 0.0; // Coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Normal\n\n    vertices[6] = 0.5;\n    vertices[7] = 0.0;\n    const PI = Math.PI;\n    let sampleRate = PI / numHorizontalSegments; // Number of steps\n\n    let theta = -PI + sampleRate; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let phi = 0.0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n    // Generate middle part vertices with normals\n\n    let index = stride - 1; // Skip first 7 (the bottom vertex with normal and texture coordinates already specified)\n\n    for (let i = 0; i < numHorizontalSegments - 1; ++i) {\n      let Y = Math.cos(theta); // Y-coordinate\n\n      let R = Math.sin(theta); // XZ-plane\n\n      phi = 0.0;\n\n      for (let j = 0; j < numVerticalSegments; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = radius * R * Math.sin(phi);\n        vertices[++index] = radius * Y;\n        vertices[++index] = radius * R * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = Y;\n        vertices[++index] = R * Math.cos(phi); // Texture Coordinates (s, t)\n\n        vertices[++index] = phi / (2.0 * PI);\n        vertices[++index] = 1.0 + theta / PI;\n        phi += sampleRate;\n      }\n\n      theta += sampleRate;\n    } // Top vertex\n\n\n    vertices[++index] = 0.0;\n    vertices[++index] = radius;\n    vertices[++index] = 0.0; // Coordinates\n\n    vertices[++index] = 0.0;\n    vertices[++index] = 1.0;\n    vertices[++index] = 0.0; // Normal\n\n    vertices[++index] = 0.5;\n    vertices[++index] = 1.0;\n    /** Generate index array */\n    // Bottom cap\n\n    index = -1;\n\n    for (let i = 0; i < numVerticalSegments; ++i) {\n      indices[++index] = 0;\n\n      if (i + 2 <= numVerticalSegments) {\n        indices[++index] = i + 2;\n      } else {\n        indices[++index] = i + 2 - numVerticalSegments;\n      }\n\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = 1;\n\n    for (let i = 0; i < numHorizontalSegments - 2; i++) {\n      for (let j = 0; j < numVerticalSegments - 1; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = numVerticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = numVerticalSegments + v0 + 1;\n        indices[++index] = numVerticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - numVerticalSegments;\n      indices[++index] = numVerticalSegments + v0;\n      indices[++index] = v0 + 1 - numVerticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = numVerticalSegments + v0;\n      ++v0;\n    } // Top cap\n\n\n    let lastVertexIndex = numVertices - 1;\n\n    for (let i = 0; i < numVerticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - numVerticalSegments) {\n        indices[++index] = lastVertexIndex - 2 - i;\n      } else {\n        indices[++index] = lastVertexIndex - numVerticalSegments - 1;\n      }\n\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    indices[numTriangles * 3 - 2] = lastVertexIndex - 1;\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static createCylinderSmooth(vertSegs, horizSegs, radius, height) {\n    if (horizSegs < 1) {\n      horizSegs = 1;\n    }\n\n    if (vertSegs < 4) {\n      vertSegs = 4;\n    }\n\n    const stride = 8;\n    let vertices = [];\n    let indices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -(height / 2.0);\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.5;\n    vertices[7] = 0.5;\n    const PI = Math.PI; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0.0; // Start on index 7\n\n    let index = stride - 1; // Generate vertices and normals for bottom circle plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < vertSegs; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = radius * Math.sin(phi);\n      vertices[++index] = -(height / 2.0); // The bottom circle is on the plane y = -height/2\n\n      vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\n      vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\n      phi += 2.0 * PI / vertSegs;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0.0; // Generate middle part vertices with normals (from bottom to top)\n\n    for (let i = 0; i < horizSegs + 1; ++i) {\n      let y = Math.cos(theta);\n\n      for (let j = 0; j < vertSegs; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = radius * Math.sin(phi);\n        vertices[++index] = height / 2.0 * y;\n        vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = phi / (2.0 * PI);\n        vertices[++index] = Math.abs(y * 0.5 - 0.5);\n        phi += 2.0 * PI / vertSegs;\n      }\n\n      phi = 0.0;\n      theta += PI / horizSegs;\n    }\n\n    phi = 0.0; // Generate vertices and normals for top circle plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < vertSegs; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = radius * Math.sin(phi);\n      vertices[++index] = height / 2.0;\n      vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\n      vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\n      phi += 2.0 * PI / vertSegs;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0.0;\n    vertices[++index] = height / 2.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 1.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.5;\n    vertices[++index] = 0.5;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    index = -1;\n\n    for (let i = 0; i < vertSegs; ++i) {\n      indices[++index] = 0;\n\n      if (i + 2 <= vertSegs) {\n        indices[++index] = i + 2;\n      } else {\n        indices[++index] = i + 2 - vertSegs;\n      }\n\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = vertSegs + 1;\n\n    for (let i = 0; i < horizSegs; i++) {\n      for (let j = 0; j < vertSegs - 1; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = vertSegs + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = vertSegs + v0 + 1;\n        indices[++index] = vertSegs + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - vertSegs;\n      indices[++index] = vertSegs + v0;\n      indices[++index] = v0 + 1 - vertSegs;\n      indices[++index] = v0 + 1;\n      indices[++index] = vertSegs + v0;\n      ++v0;\n    }\n\n    let numVertices = 4 * vertSegs + 2 + vertSegs * (horizSegs - 1); // Top circle plane\n\n    let lastVertexIndex = numVertices - 1;\n\n    for (let i = 0; i < vertSegs; ++i) {\n      indices[++index] = lastVertexIndex;\n\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - vertSegs) {\n        indices[++index] = lastVertexIndex - 2 - i;\n      } else {\n        indices[++index] = lastVertexIndex - 1;\n      }\n\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static createCylinderSharp(vertSegs, radius, height) {\n    const horizSegs = 1;\n\n    if (vertSegs < 4) {\n      vertSegs = 4;\n    }\n\n    const stride = 8;\n    let vertices = [];\n    let indices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -(height / 2.0);\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.5;\n    vertices[7] = 0.5;\n    const PI = Math.PI; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0.0;\n    let index = stride - 1; // Generate vertices and normals for bottom circle plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < vertSegs; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = radius * Math.sin(phi);\n      vertices[++index] = -(height / 2.0); // The bottom circle is on the plane y = -height/2\n\n      vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\n      vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\n      phi += 2.0 * PI / vertSegs;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0.0; // Generate middle part vertices with normals (from bottom to top)\n\n    for (let i = 0; i < horizSegs + 1; ++i) {\n      let y = Math.cos(theta); // Two vertices each iteration which belong to the same face\n\n      for (let j = 0; j < vertSegs; ++j) {\n        let phiNext = phi + 2.0 * PI / vertSegs; // First Vertex\n        // Vertex (x, y, z)\n\n        vertices[++index] = radius * Math.sin(phi);\n        vertices[++index] = height / 2.0 * y;\n        vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi) + Math.sin(phiNext);\n        vertices[++index] = y + y;\n        vertices[++index] = Math.cos(phi) + Math.cos(phiNext); // Textures (s, t)\n\n        vertices[++index] = phi / (2.0 * PI);\n        vertices[++index] = Math.abs(y * 0.5 - 0.5); // Second Vertex\n        // Vertex (x, y, z)\n\n        vertices[++index] = radius * Math.sin(phiNext);\n        vertices[++index] = height / 2.0 * y;\n        vertices[++index] = radius * Math.cos(phiNext); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi) + Math.sin(phiNext);\n        vertices[++index] = y + y;\n        vertices[++index] = Math.cos(phi) + Math.cos(phiNext); // Textures (s, t)\n\n        vertices[++index] = phiNext / (2.0 * PI);\n        vertices[++index] = Math.abs(y * 0.5 - 0.5);\n        phi = phiNext;\n      }\n\n      vertices[index - 1] = 1.0; // Last vertex s-texture coordinate is always 1\n\n      phi = 0.0;\n      theta += PI / horizSegs;\n    } // Reset phi to 0\n\n\n    phi = 0.0; // Generate vertices and normals for top circle plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < vertSegs; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = radius * Math.sin(phi);\n      vertices[++index] = height / 2.0;\n      vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\n      vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\n      phi += 2.0 * PI / vertSegs;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0.0;\n    vertices[++index] = height / 2.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 1.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.5;\n    vertices[++index] = 0.5;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    index = -1;\n\n    for (let i = 0; i < vertSegs; ++i) {\n      indices[++index] = 0;\n\n      if (i + 2 <= vertSegs) {\n        indices[++index] = i + 2;\n      } else {\n        indices[++index] = i + 2 - vertSegs;\n      }\n\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = vertSegs + 1;\n\n    for (let i = 0; i < horizSegs; i++) {\n      for (let j = 0; j < vertSegs; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = 2 * vertSegs + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = 2 * vertSegs + v0 + 1;\n        indices[++index] = 2 * vertSegs + v0;\n        v0 = v0 + 2;\n      }\n    } // Top circle plane\n\n\n    let numVertices = 6 * vertSegs + 2;\n    let lastVertexIndex = numVertices - 1;\n\n    for (let i = 0; i < vertSegs; ++i) {\n      indices[++index] = lastVertexIndex;\n\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - vertSegs) {\n        indices[++index] = lastVertexIndex - 2 - i;\n      } else {\n        indices[++index] = lastVertexIndex - 1;\n      }\n\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static createPlane(WIDTH, HEIGHT, textureWidth = -1.0, textureHeight = -1.0) {\n    // Textire coordiantes\n    let s, t;\n\n    if (textureWidth > 0.0001) {\n      s = WIDTH / textureWidth;\n    } else {\n      s = 1.0;\n    }\n\n    if (textureHeight > 0.0001) {\n      t = HEIGHT / textureHeight;\n    } else {\n      t = 1.0;\n    }\n\n    let vertexData = [// Position Coordinates                 // Normals       // Texture coordinates\n    -(WIDTH / 2.0), 0.0, -(HEIGHT / 2.0), 0.0, 1.0, 0.0, 0.0, 0.0, // Upper left\n    WIDTH / 2.0, 0.0, -(HEIGHT / 2.0), 0.0, 1.0, 0.0, s, 0.0, // Upper right\n    WIDTH / 2.0, 0.0, HEIGHT / 2.0, 0.0, 1.0, 0.0, s, t, // Lower right\n    -(WIDTH / 2.0), 0.0, HEIGHT / 2.0, 0.0, 1.0, 0.0, 0.0, t // Lower left\n    ];\n    let indexData = [0, 2, 1, // First triangle\n    0, 3, 2 // Second triangle\n    ];\n    let numVertices = 4;\n    let numTriangles = 2;\n    let stride = 8;\n    console.log(\"Vertices before: \" + numVertices * stride);\n    let vertices = [];\n    console.log(\"Vertices before: \" + numTriangles * 3);\n    let indices = [];\n\n    for (let i = 0; i < numVertices * stride; ++i) {\n      vertices[i] = vertexData[i];\n    }\n\n    for (let i = 0; i < numTriangles * 3; ++i) {\n      indices[i] = indexData[i];\n    }\n\n    return {\n      numVertices: numVertices,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n}\n\nexport default ShapeGenerator;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\ShapeGenerator.js"],"names":["ShapeGenerator","createCube","x","y","z","vertexArray","indexArray","totalTriangles","totalVertices","numVertices","vertices","indices","createSphere","segments","radius","numHorizontalSegments","numVerticalSegments","numTriangles","stride","PI","Math","sampleRate","theta","phi","index","i","Y","cos","R","sin","j","v0","lastVertexIndex","length","createCylinderSmooth","vertSegs","horizSegs","height","abs","createCylinderSharp","phiNext","createPlane","WIDTH","HEIGHT","textureWidth","textureHeight","s","t","vertexData","indexData","console","log"],"mappings":"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","sourcesContent":["class ShapeGenerator {\r\n    static createCube(x = 1.0, y = 1.0, z = 1.0) {\r\n        // Vertex coordinates, normals and texture coordinates\r\n        let vertexArray = [\r\n            // Vertex         Normal             Texture coordinates\r\n            // Vertex 0\r\n            -x, -y, -z,      0.0, -1.0,  0.0,     0.0, 1.0,\r\n            -x, -y, -z,     -1.0,  0.0,  0.0,     0.0, 0.0,\r\n            -x, -y, -z,      0.0,  0.0,  -1.0,    0.0, 0.0,\r\n\r\n            // Vertex 1\r\n            -x, -y,  z,     0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y,  z,     0.0,  0.0, 1.0,       0.0, 1.0,\r\n            -x, -y,  z,    -1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 2\r\n            x, -y,  z,      0.0, -1.0,  0.0,      1.0, 0.0,\r\n            x, -y,  z,      0.0,  0.0, 1.0,       1.0, 1.0,\r\n            x, -y,  z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 3\r\n            x, -y, -z,      0.0, -1.0,  0.0,      1.0, 1.0,\r\n            x, -y, -z,      0.0,  0.0,  -1.0,     0.0, 0.0,\r\n            x, -y, -z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 4\r\n            -x, y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  0.0,  -1.0,     0.0, 0.0,\r\n            -x, y, -z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 5\r\n            -x, y, z,      0.0,  0.0, 1.0,        0.0, 0.0,\r\n            -x, y, z,     -1.0,  0.0,  0.0,       0.0, 0.0,\r\n            -x, y, z,      0.0,  1.0,  0.0,       0.0, 0.0,\r\n\r\n            // Vertex 6\r\n            x, y, z,       0.0,  0.0, 1.0,        0.0, 0.0,\r\n            x, y, z,       1.0,  0.0,  0.0,       0.0, 0.0,\r\n            x, y, z,       0.0,  1.0,  0.0,       0.0, 0.0,\r\n\r\n            // Vertex 7\r\n            x, y, -z,       0.0,  0.0,  -1.0,     0.0, 0.0,\r\n            x, y, -z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, -z,       0.0,  1.0,  0.0,      0.0, 0.0\r\n        ];\r\n\r\n        // Vertex indices\r\n        let indexArray = [\r\n            // Bottom\r\n            0, 9, 6,  // v0, v3, v2\r\n            6, 3, 0,  // v2, v1, v0\r\n\r\n            // Front\r\n            4, 7, 18,  // v1, v2, v6\r\n            18, 15, 4, // v6, v5, v1\r\n\r\n            // Left\r\n            1, 5, 16,  // v0, v1, v5\r\n            16, 12, 1, // v5, v4, v0\r\n\r\n            // Back\r\n            2, 13, 21, // v0, v4, v7\r\n            21, 10, 2, // v7, v3, v0\r\n\r\n            // Right\r\n            8, 11, 22, // v2, v3, v7\r\n            22, 19, 8, // v7, v6, v2\r\n\r\n            // Top\r\n            14, 17, 20, // v4, v5, v6\r\n            20, 23, 14  // v6, v7, v4\r\n        ];\r\n\r\n        let totalTriangles = 12;\r\n        let totalVertices = totalTriangles*3;\r\n\r\n        return {\r\n            numVertices: totalVertices,\r\n            vertices: vertexArray,\r\n            indices: indexArray\r\n        };\r\n    }\r\n\r\n    static createSphere(segments, radius) {\r\n        let numHorizontalSegments = segments;\r\n        // Minium amount of horizontal segments is 2\r\n        if (numHorizontalSegments < 2) {\r\n            numHorizontalSegments = 2;\r\n        }\r\n\r\n        // Number of vertical segments of the sphere\r\n        let numVerticalSegments = 2 * numHorizontalSegments;\r\n        let numVertices = 1 + (numHorizontalSegments - 1) * numVerticalSegments + 1; // top + middle + bottom\r\n        let numTriangles = numVerticalSegments + (numHorizontalSegments - 2) * 4 * numHorizontalSegments + numVerticalSegments; // top + middle + bottom\r\n\r\n        // Floats per row: position(x,y,z), normal(x,y,z), texture(s,t)\r\n        let stride = 8;\r\n        let vertices = []; // Initialize vertex array\r\n        let indices = []; // Initialize index array\r\n\r\n        /** Generate vertex array **/\r\n        // Bottom vertex\r\n        vertices[0] = 0.0; vertices[1] = -radius; vertices[2] = 0.0; // Coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0;    vertices[5] = 0.0; // Normal\r\n        vertices[6] = 0.5; vertices[7] = 0.0;\r\n\r\n        const PI = Math.PI;\r\n\r\n        let sampleRate = PI / numHorizontalSegments; // Number of steps\r\n        let theta = -PI + sampleRate; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let  phi = 0.0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = stride - 1; // Skip first 7 (the bottom vertex with normal and texture coordinates already specified)\r\n        for (let i = 0; i < (numHorizontalSegments - 1); ++i) {\r\n            let Y = Math.cos(theta); // Y-coordinate\r\n            let R = Math.sin(theta); // XZ-plane\r\n\r\n            phi = 0.0;\r\n            for (let j = 0; j < numVerticalSegments; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = radius * R * Math.sin(phi);\r\n                vertices[++index] = radius * Y;\r\n                vertices[++index] = radius * R * Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R * Math.sin(phi);\r\n                vertices[++index] = Y;\r\n                vertices[++index] = R * Math.cos(phi);\r\n                // Texture Coordinates (s, t)\r\n                vertices[++index] = phi / (2.0 * PI);\r\n                vertices[++index] = 1.0 + (theta / PI);\r\n\r\n                phi += sampleRate;\r\n            }\r\n            theta += sampleRate;\r\n        }\r\n\r\n        // Top vertex\r\n        vertices[++index] = 0.0; vertices[++index] = radius; vertices[++index] = 0.0; // Coordinates\r\n        vertices[++index] = 0.0; vertices[++index] = 1.0;    vertices[++index] = 0.0; // Normal\r\n        vertices[++index] = 0.5; vertices[++index] = 1.0;\r\n\r\n        /** Generate index array */\r\n        // Bottom cap\r\n        index = -1;\r\n        for (let i = 0; i < numVerticalSegments; ++i) {\r\n            indices[++index] = 0;\r\n            if ((i + 2) <= numVerticalSegments) {\r\n                indices[++index] = i + 2;\r\n            }\r\n            else {\r\n                indices[++index] = (i + 2) - numVerticalSegments;\r\n            }\r\n            indices[++index] = i + 1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for (let i = 0; i < (numHorizontalSegments - 2); i++) {\r\n            for (let j = 0; j < (numVerticalSegments - 1); ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - numVerticalSegments;\r\n            indices[++index] = numVerticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - numVerticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = numVerticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top cap\r\n        let lastVertexIndex = numVertices - 1;\r\n        for (let i = 0; i < numVerticalSegments; ++i) {\r\n            indices[++index] = lastVertexIndex;\r\n            if ((lastVertexIndex - 2 - i) >= lastVertexIndex - numVerticalSegments) {\r\n                indices[++index] = lastVertexIndex - 2 - i;\r\n            }\r\n            else {\r\n                indices[++index] = lastVertexIndex - numVerticalSegments - 1;\r\n            }\r\n            indices[++index] = lastVertexIndex - 1 - i;\r\n        }\r\n        indices[(numTriangles * 3) - 2] = (lastVertexIndex - 1);\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static createCylinderSmooth (vertSegs, horizSegs, radius, height) {\r\n        if (horizSegs < 1) {\r\n            horizSegs = 1;\r\n        }\r\n        if (vertSegs < 4) {\r\n            vertSegs = 4;\r\n        }\r\n\r\n        const stride = 8;\r\n        let vertices = [];\r\n        let indices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -(height / 2.0); vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0;            vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.5; vertices[7] = 0.5;\r\n\r\n        const PI = Math.PI;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0.0;\r\n\r\n        // Start on index 7\r\n        let index = stride - 1;\r\n        // Generate vertices and normals for bottom circle plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < vertSegs; ++j) {\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = radius * Math.sin(phi);\r\n            vertices[++index] = -(height / 2.0); // The bottom circle is on the plane y = -height/2\r\n            vertices[++index] = radius * Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\r\n            vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\r\n\r\n            phi += (2.0 * PI) / vertSegs;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0.0;\r\n        // Generate middle part vertices with normals (from bottom to top)\r\n        for (let i = 0; i < (horizSegs + 1); ++i) {\r\n            let y = Math.cos(theta);\r\n            for (let j = 0; j < vertSegs; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = radius * Math.sin(phi);\r\n                vertices[++index] = (height / 2.0) * y;\r\n                vertices[++index] = radius * Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = phi/(2.0*PI);\r\n                vertices[++index] = Math.abs(y * 0.5 - 0.5);\r\n\r\n                phi += (2.0 * PI) / vertSegs;\r\n            }\r\n            phi = 0.0;\r\n            theta += PI / horizSegs;\r\n        }\r\n\r\n        phi = 0.0;\r\n        // Generate vertices and normals for top circle plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < vertSegs; ++j) {\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = radius * Math.sin(phi);\r\n            vertices[++index] = (height / 2.0);\r\n            vertices[++index] = radius * Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\r\n            vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\r\n\r\n            phi += (2.0 * PI) / vertSegs;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0.0; vertices[++index] = (height / 2.0); vertices[++index] = 0.0;\r\n        vertices[++index] = 0.0; vertices[++index] = 1.0;            vertices[++index] = 0.0;\r\n        vertices[++index] = 0.5; vertices[++index] = 0.5;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        index = -1;\r\n        for (let i = 0; i < vertSegs; ++i) {\r\n            indices[++index] = 0;\r\n            if ((i + 2) <= vertSegs) {\r\n                indices[++index] = i + 2;\r\n            }\r\n            else {\r\n                indices[++index] = (i + 2) - vertSegs;\r\n            }\r\n            indices[++index] = i + 1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = vertSegs + 1;\r\n        for (let i = 0; i < horizSegs; i++) {\r\n            for (let j = 0; j < (vertSegs - 1); ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = vertSegs + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = vertSegs + v0 + 1;\r\n                indices[++index] = vertSegs + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - vertSegs;\r\n            indices[++index] = vertSegs + v0;\r\n            indices[++index] = (v0 + 1) - vertSegs;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = vertSegs + v0;\r\n            ++v0;\r\n        }\r\n\r\n        let numVertices = (4 * vertSegs) + 2 + (vertSegs * (horizSegs - 1));\r\n        // Top circle plane\r\n        let lastVertexIndex = numVertices - 1;\r\n        for (let i = 0; i < vertSegs; ++i) {\r\n            indices[++index] = lastVertexIndex;\r\n            if ((lastVertexIndex - 2 - i) >= lastVertexIndex - vertSegs) {\r\n                indices[++index] = lastVertexIndex - 2 - i;\r\n            }\r\n            else {\r\n                indices[++index] = lastVertexIndex - 1;\r\n            }\r\n            indices[++index] = lastVertexIndex - 1 - i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static createCylinderSharp(vertSegs, radius, height) {\r\n        const horizSegs = 1;\r\n\r\n        if (vertSegs < 4) {\r\n            vertSegs = 4;\r\n        }\r\n        const stride = 8;\r\n        let vertices = [];\r\n        let indices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -(height / 2.0); vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0;            vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.5; vertices[7] = 0.5;\r\n\r\n        const PI = Math.PI;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0.0;\r\n\r\n        let index = stride - 1;\r\n        // Generate vertices and normals for bottom circle plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < vertSegs; ++j) {\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = radius * Math.sin(phi);\r\n            vertices[++index] = -(height / 2.0); // The bottom circle is on the plane y = -height/2\r\n            vertices[++index] = radius * Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\r\n            vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\r\n\r\n            phi += (2.0 * PI) / vertSegs;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0.0;\r\n        // Generate middle part vertices with normals (from bottom to top)\r\n        for (let i = 0; i < (horizSegs + 1); ++i) {\r\n            let y = Math.cos(theta);\r\n            // Two vertices each iteration which belong to the same face\r\n            for (let j = 0; j < vertSegs; ++j) {\r\n                let phiNext = phi + (2.0 * PI) / vertSegs;\r\n                // First Vertex\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = radius * Math.sin(phi);\r\n                vertices[++index] = (height / 2.0) * y;\r\n                vertices[++index] = radius * Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi) + Math.sin(phiNext);\r\n                vertices[++index] = y + y;\r\n                vertices[++index] = Math.cos(phi) + Math.cos(phiNext);\r\n\r\n                // Textures (s, t)\r\n                vertices[++index] = phi / (2.0*PI);\r\n                vertices[++index] = Math.abs(y * 0.5 - 0.5);\r\n\r\n                // Second Vertex\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = radius * Math.sin(phiNext);\r\n                vertices[++index] = (height / 2.0) * y;\r\n                vertices[++index] = radius * Math.cos(phiNext);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi) + Math.sin(phiNext);\r\n                vertices[++index] = y + y;\r\n                vertices[++index] = Math.cos(phi) + Math.cos(phiNext);\r\n\r\n                // Textures (s, t)\r\n                vertices[++index] = phiNext / (2.0*PI);\r\n                vertices[++index] = Math.abs(y * 0.5 - 0.5);\r\n\r\n                phi = phiNext;\r\n            }\r\n            vertices[index - 1] = 1.0; // Last vertex s-texture coordinate is always 1\r\n\r\n            phi = 0.0;\r\n            theta += PI / horizSegs;\r\n        }\r\n\r\n        // Reset phi to 0\r\n        phi = 0.0;\r\n        // Generate vertices and normals for top circle plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < vertSegs; ++j) {\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = radius * Math.sin(phi);\r\n            vertices[++index] = (height / 2.0);\r\n            vertices[++index] = radius * Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\r\n            vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\r\n\r\n            phi += (2.0 * PI) / vertSegs;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0.0; vertices[++index] = (height / 2.0); vertices[++index] = 0.0;\r\n        vertices[++index] = 0.0; vertices[++index] = 1.0;            vertices[++index] = 0.0;\r\n        vertices[++index] = 0.5; vertices[++index] = 0.5;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        index = -1;\r\n        for (let i = 0; i < vertSegs; ++i) {\r\n            indices[++index] = 0;\r\n\r\n            if ((i + 2) <= vertSegs) {\r\n                indices[++index] = i + 2;\r\n            }\r\n            else {\r\n                indices[++index] = (i + 2) - vertSegs;\r\n            }\r\n\r\n            indices[++index] = i + 1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = vertSegs + 1;\r\n        for (let i = 0; i < horizSegs; i++) {\r\n            for (let j = 0; j < vertSegs; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = 2 * vertSegs + v0;\r\n\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = 2* vertSegs + v0 + 1;\r\n                indices[++index] = 2 * vertSegs + v0;\r\n                v0 = v0 + 2;\r\n            }\r\n        }\r\n\r\n        // Top circle plane\r\n        let numVertices = 6 * vertSegs + 2;\r\n        let lastVertexIndex = numVertices - 1;\r\n        for (let i = 0; i < vertSegs; ++i) {\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex - 2 - i) >= lastVertexIndex - vertSegs) {\r\n                indices[++index] = lastVertexIndex - 2 - i;\r\n            }\r\n            else {\r\n                indices[++index] = lastVertexIndex - 1;\r\n            }\r\n\r\n            indices[++index] = lastVertexIndex - 1 - i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static createPlane (WIDTH, HEIGHT, textureWidth = -1.0, textureHeight = -1.0) {\r\n        // Textire coordiantes\r\n        let s, t;\r\n        if (textureWidth > 0.0001) {\r\n            s = WIDTH / textureWidth;\r\n        }\r\n        else {\r\n            s = 1.0;\r\n        }\r\n\r\n        if (textureHeight > 0.0001) {\r\n            t = HEIGHT / textureHeight;\r\n        }\r\n        else {\r\n            t = 1.0;\r\n        }\r\n\r\n        let vertexData = [\r\n            // Position Coordinates                 // Normals       // Texture coordinates\r\n            -(WIDTH / 2.0), 0.0, -(HEIGHT / 2.0),   0.0, 1.0, 0.0,   0.0, 0.0, // Upper left\r\n             (WIDTH / 2.0), 0.0, -(HEIGHT / 2.0),   0.0, 1.0, 0.0,   s, 0.0, // Upper right\r\n             (WIDTH / 2.0), 0.0,  (HEIGHT / 2.0),   0.0, 1.0, 0.0,   s, t, // Lower right\r\n            -(WIDTH / 2.0), 0.0,  (HEIGHT / 2.0),   0.0, 1.0, 0.0,   0.0, t  // Lower left\r\n        ];\r\n\r\n        let indexData = [\r\n            0, 2, 1, // First triangle\r\n            0, 3, 2 // Second triangle\r\n        ];\r\n\r\n        let numVertices = 4;\r\n        let numTriangles = 2;\r\n        let stride = 8;\r\n        console.log(\"Vertices before: \" + (numVertices * stride));\r\n        let vertices = [];\r\n        console.log(\"Vertices before: \" + (numTriangles * 3));\r\n        let indices = [];\r\n\r\n        for (let i = 0; i < (numVertices * stride); ++i) {\r\n            vertices[i] = vertexData[i];\r\n        }\r\n\r\n        for (let i = 0; i < (numTriangles * 3); ++i) {\r\n            indices[i] = indexData[i];\r\n        }\r\n\r\n        return {\r\n            numVertices: numVertices,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n}\r\n\r\nexport default ShapeGenerator;"]},"metadata":{},"sourceType":"module"}