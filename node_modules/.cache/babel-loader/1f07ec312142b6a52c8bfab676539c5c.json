{"ast":null,"code":"//TODO: Implement a sky box background\n//TODO: Implement cubic shadow mapping\n//TODO: Implement a ParticleSystem component\n// JavaScript components\nimport Shader from \"./ShaderHandle\";\nimport Time from \"./Time\";\nimport Camera from \"./Camera\";\nimport Mesh from \"./Mesh\";\nimport GameObject from \"./GameObject\";\nimport EventHandler from \"./events/EventHandler\";\nimport MouseEvent from \"./events/MouseEvent\";\nimport Scene from \"./Scene\";\nimport PointLightSource from \"./PointLightSource\";\nimport IntersectionField from \"./IntersectionField\";\nimport Vector3 from \"./math/Vector3\";\nimport Matrix4 from \"./math/Matrix4\"; // Shader files\n\nimport PhongLightingShader from \"./shaders/PhongLightingShader\";\nimport AmbientShader from \"./shaders/AmbientShader\";\n/***** Settings *****/\n// Default camera position and rotation\n\nconst CAMERA_POSITION = [0.0, 5.0, 40.0];\nconst CAMERA_ROTATION = [0.0, 0.0, 0.0]; // Enum struct for creating different shapes\n\nconst SHAPE = {\n  CUBE: 0,\n  SPHERE: 1,\n  CYLINDER_SMOOTH: 2,\n  CYLINDER_SHARP: 3,\n  PLANE: 4\n};\nconst MS_PER_UPDATE = 2.0;\n\nclass Engine {\n  constructor() {\n    // Initialize timing variables\n    this.lastTime = 0.0;\n    this.frameCount = 0;\n    this.fps = 0;\n    this.currentTextOffset = 0;\n    this.viewportAspectRatio = 1.0;\n    this.lag = 0.0; // Scenes works like blocks in the game world.\n    // The active scenes are based on the cameras distance to the origin of each scene.\n\n    this.scenes = [];\n    this.shaders = new Map();\n    this.rayVertices = [];\n  }\n  /*\r\n  * @brief This is the engines main update function and is called every iteration of the main loop\r\n  */\n\n\n  run() {\n    // Time start of the loop\n    let startTime = Time.now; // Update time clock\n\n    Time.update(); // Add elapsed time to the lag variable\n\n    this.lag += Time.deltaTime;\n\n    while (this.lag >= MS_PER_UPDATE) {\n      this.update();\n      this.lag -= MS_PER_UPDATE;\n    } // Render graphics\n\n\n    this.render(this.lag / MS_PER_UPDATE); // Hold each frame for a specified number of milliseconds (16 ms locks on roughly 60 fps)\n    //while ((Time.now - startTime) < 16.0) ; // Sleep\n  }\n\n  update() {\n    // Handle camera navigation\n    this.processCameraNavigation(this.camera);\n    this.scenes.forEach(scene => {\n      scene.update();\n    });\n\n    if (MouseEvent.mouseDown) {\n      console.log(\"X: \" + MouseEvent.offsetX + \", Y: \" + MouseEvent.offsetY);\n      this.intersectionTest(MouseEvent.offsetX, MouseEvent.offsetY);\n    }\n\n    EventHandler.resetMouseEvents();\n  }\n\n  render(residualLag) {\n    // Set the viewport to the canvas dimensions and update the aspect ratio for the projection matrix\n    this.updateViewportDimensions(); // Clear screen 3D\n\n    this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT); // Draw scenes\n\n    this.scenes.forEach(scene => {\n      scene.updateLightPositions();\n      scene.draw();\n    }); ///// INTERSECTION TEST //////\n\n    /*\r\n    this.intersect.updateBorders(this.camera, this.scenes[0].sceneObjects[0].transform.matrix, this.canvas.width, this.canvas.height);\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.ctx.strokeStyle = \"yellow\";\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(this.intersect.borders.xMin, this.intersect.borders.yMin);\r\n    this.ctx.lineTo(this.intersect.borders.xMax, this.intersect.borders.yMin);\r\n    this.ctx.lineTo(this.intersect.borders.xMax, this.intersect.borders.yMax);\r\n    this.ctx.lineTo(this.intersect.borders.xMin, this.intersect.borders.yMax);\r\n    this.ctx.closePath();\r\n    this.ctx.stroke();\r\n    */\n    ///// INTERSECTION TEST //////\n\n    this.drawRay(); // Display fps and other information\n\n    this.drawTextElements();\n  } // This function is called before the game loop is initiated\n\n\n  preload() {\n    // Initiate time tracker component\n    Time.init(); // Initiate the event handler\n\n    EventHandler.init(); // Set up webgl 2D and 3D context from html canvas. Viewport and render settings are also set.\n\n    this.setUpWebGL(); // Create shaders\n\n    let mainShader = new Shader(this.canvas, PhongLightingShader.vertex, PhongLightingShader.fragment);\n    let ambientShader = new Shader(this.canvas, AmbientShader.vertex, AmbientShader.fragment);\n    this.shaders.set(\"phong\", mainShader);\n    this.shaders.set(\"ambient\", ambientShader); // Initialize the main camera\n\n    this.camera = new Camera(this.shaders);\n    this.camera.setPosition(CAMERA_POSITION);\n    this.camera.setRotation(CAMERA_ROTATION); // Create a scene for the objects\n\n    let defaultScene = new Scene(this.shaders); // Create scene objects\n\n    this.loadDefaultSceneObjects(defaultScene); // Add to scenes\n\n    this.scenes.push(defaultScene); ///// INTERSECTION TEST //////\n\n    /*\r\n    this.intersect = new IntersectionField();\r\n    this.cubeMatrix = this.scenes[0].sceneObjects[0].transform.matrix;\r\n    this.intersect.updateBorders(this.camera, this.cubeMatrix, this.canvas.width, this.canvas.height);\r\n    */\n    ///// INTERSECTION TEST //////\n    ///// MULTIPLE SCENE TEST ///////\n\n    /*\r\n    let defaultScene2 = new Scene(this.shaders);\r\n    let defaultScene3 = new Scene(this.shaders);\r\n    let defaultScene4 = new Scene(this.shaders);\r\n      this.loadDefaultSceneObjects(defaultScene2);\r\n    this.loadDefaultSceneObjects(defaultScene3);\r\n    this.loadDefaultSceneObjects(defaultScene4);\r\n      defaultScene3.setPosition([0.0, 0.0, 80.0]);\r\n    defaultScene3.setRotation([0.0, 180.0, 0.0]);\r\n      defaultScene2.setPosition([0.0, 60.0, 0.0]);\r\n    defaultScene2.setRotation([0.0, 0.0, 180.0]);\r\n      defaultScene4.setPosition([0.0, 60.0, 80.0]);\r\n    defaultScene4.setRotation([0.0, 180.0, 180.0]);\r\n      this.scenes.push(defaultScene2);\r\n    this.scenes.push(defaultScene3);\r\n    this.scenes.push(defaultScene4);\r\n    */\n    ///// MULTIPLE SCENE TEST ///////\n  }\n\n  updateViewportDimensions() {\n    // Calculate current aspect ratio\n    let currentAspectRatio = this.canvas.width / this.canvas.height; // Check if the aspect ratio has changed before going further\n\n    if (Math.abs(this.viewportAspectRatio - currentAspectRatio) < 0.001) return; // Update the projection matrix for the shaders\n\n    this.shaders.forEach(shader => {\n      shader.activate();\n      shader.setProjectionUniformAspectRatio(currentAspectRatio);\n    }); // Update the viewport dimensions to the canvas width\n\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height); // Save current aspect ratio\n\n    this.viewportAspectRatio = currentAspectRatio;\n  }\n\n  drawTextElements() {\n    // Set text font style\n    this.ctx.font = \"20px Consolas\";\n    this.ctx.fillStyle = 'white';\n    this.currentTextOffset = 0; // Clear previous\n\n    this.ctx.clearRect(this.currentTextOffset, 0, this.canvas.offsetWidth, 30); // Draw the text\n\n    this.displayFrameRate();\n    this.displayCameraPosition();\n  }\n\n  displayFrameRate() {\n    let currentTime = Time.time; // If tNow - tLast >= 1000, one second has passed\n\n    if (currentTime - this.lastTime >= 1000.0) {\n      // Fps = the number of frames\n      this.fps = this.frameCount; // Update timer\n\n      this.lastTime = currentTime; // Reset frame count\n\n      this.frameCount = 0;\n    } else {\n      ++this.frameCount;\n    } // Compose text string\n\n\n    let fpsText = \"Frame rate: \" + this.fps + \" fps, Time per frame: \" + Time.deltaTime.toFixed(0) + \" ms,\"; // Draw fps and frame time in milliseconds\n\n    this.ctx.fillText(fpsText, 10, 25); // Update text offset for next text\n\n    this.currentTextOffset = fpsText.length * 12 + 10;\n  }\n\n  displayCameraPosition() {\n    let pos = this.camera.transform.position; // Compose text string\n\n    let cameraPositionText = \"Camera position: (\" + pos.x.toFixed(2) + \", \" + pos.y.toFixed(2) + \", \" + pos.z.toFixed(2) + \")\"; // Draw fps and frame time in milliseconds\n\n    this.ctx.fillText(cameraPositionText, this.currentTextOffset, 25); // Update text offset for next text\n\n    this.currentTextOffset = cameraPositionText.length * 12;\n  }\n\n  createGameObject(settings) {\n    let mesh = new Mesh(this.gl);\n\n    if (settings.shape === SHAPE.CUBE) {\n      mesh.createCube();\n    } else if (settings.shape === SHAPE.SPHERE) {\n      mesh.createSphere(32);\n    } else if (settings.shape === SHAPE.CYLINDER_SMOOTH) {\n      mesh.createCylinderSmooth(32, 1, 1, 2);\n    } else if (settings.shape === SHAPE.CYLINDER_SHARP) {\n      mesh.createCylinderSharp(8, 1, 2);\n    } else if (settings.shape === SHAPE.PLANE) {\n      mesh.createPlane(50, 50);\n    }\n\n    mesh.setColor(settings.color);\n    let obj = new GameObject(settings.name);\n    obj.setPosition(settings.position);\n    obj.setScale(settings.scale);\n    obj.addMesh(mesh);\n    return obj;\n  }\n\n  createPointLightSource(settings) {\n    // Create the light source component\n    let lightSource = new PointLightSource(settings.name);\n    lightSource.setPosition(settings.position);\n    lightSource.setScale(settings.scale);\n    lightSource.setLightColor(settings.color);\n    lightSource.setAttenuation(settings.attenuation.kLinear, settings.attenuation.kQuadratic); // Create a model for the light source\n\n    let lightSourceModel = new Mesh(this.gl);\n    lightSourceModel.createSphere(8);\n    lightSourceModel.setColor(settings.color);\n    lightSource.addMesh(lightSourceModel);\n    return lightSource;\n  }\n\n  loadDefaultSceneObjects(scene) {\n    // Create a red cube\n    let cube = this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Red Cube',\n      scale: [1.0, 1.0, 1.0],\n      position: [0.0, 1.5, 0.0],\n      color: [1.0, 0.0, 0.0]\n    });\n    scene.addGameObject(cube); // Create a green sphere\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.SPHERE,\n      name: 'Green Sphere',\n      scale: [1.0, 1.0, 1.0],\n      position: [4.0, 2.0, 2.0],\n      color: [0.0, 1.0, 0.0]\n    })); // Create a smooth magenta cylinder\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CYLINDER_SMOOTH,\n      name: 'Magenta Cylinder',\n      scale: [1.0, 1.0, 1.0],\n      position: [-4.0, 2.0, 2.0],\n      color: [1.0, 0.0, 1.0]\n    })); // Create a sharp orange cylinder\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CYLINDER_SHARP,\n      name: 'Orange Cylinder',\n      scale: [1.0, 1.0, 1.0],\n      position: [-8.0, 2.0, 2.0],\n      color: [1.0, 0.5, 0.0]\n    })); // Create gray floor\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Roof',\n      scale: [40.0, 0.1, 40.0],\n      position: [0.0, 0.0, 0.0],\n      color: [0.75, 0.75, 0.75]\n    })); // Create blue walls\n\n    let wallColor = [0.0, 0.2, 1.0];\n    let wallHeight = 10.0;\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Left Wall',\n      scale: [0.1, wallHeight, 20.0],\n      position: [-40.0, wallHeight, -20.0],\n      color: wallColor\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Right Wall',\n      scale: [0.1, wallHeight, 20.0],\n      position: [40.0, wallHeight, -20.0],\n      color: wallColor\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Back Wall',\n      scale: [40.0, wallHeight, 0.1],\n      position: [0.0, wallHeight, -40.0],\n      color: wallColor\n    })); // Create gray roof\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Floor',\n      scale: [40.0, 0.1, 20.0],\n      position: [0.0, wallHeight * 2.0, -20.0],\n      color: [0.5, 0.5, 0.5]\n    })); // Create a point lights for the scene\n    // Add the light source to our scene\n\n    let lampRadius = 0.5;\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [0.0, 2.0 * wallHeight - lampRadius, -35.0],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Right Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [37.5, 2.0 * wallHeight - lampRadius, -15.0],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Left Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [-37.5, 2.0 * wallHeight - lampRadius, -15.0],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n  }\n\n  processCameraNavigation() {\n    // Zoom camera view in and out\n    if (MouseEvent.isPressed.middleButton) {\n      this.camera.translate([0.0, 0.0, -(MouseEvent.movementY + MouseEvent.movementX) / 20.0]);\n    } // Pan the camera view\n    else if (MouseEvent.isPressed.leftButton) {\n        this.camera.translate([-MouseEvent.movementX / 40.0, MouseEvent.movementY / 40.0, 0.0]);\n      } // Rotate the camera view\n      else if (MouseEvent.isPressed.rightButton) {\n          this.camera.rotate([-MouseEvent.movementY / 10.0, -MouseEvent.movementX / 10.0, 0.0]);\n        }\n\n    if (Math.abs(MouseEvent.wheelDelta) > 0.01) {\n      if (MouseEvent.wheelDelta > 0.0) {\n        this.camera.translate([0.0, 0.0, 0.5]);\n      } else this.camera.translate([0.0, 0.0, -0.5]);\n    }\n  }\n\n  setUpWebGL() {\n    // 2D Canvas for text display\n    this.canvas2D = document.getElementById('text-canvas');\n    this.ctx = this.canvas2D.getContext('2d'); // WebGL canvas\n\n    this.canvas = document.getElementById(\"gl-canvas\"); // Initialize the WebGL context\n\n    this.gl = this.canvas.getContext(\"webgl\"); // If WebGL isn't supported\n\n    if (!this.gl) {\n      console.log(\"WebGL is not supported\");\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n      return 0;\n    } // Set the viewport dimensions to the same as the canvas\n\n\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height); // Set clear color to dark blue, fully opaque\n\n    this.gl.clearColor(0.02, 0.02, 0.02, 1.0); // Enable depth so that triangles closer to the camera don't get overlapped by those further away\n\n    this.gl.enable(this.gl.DEPTH_TEST); // Only draw \"visible\" sides (memory saving)\n\n    this.gl.enable(this.gl.CULL_FACE);\n    this.gl.cullFace(this.gl.BACK);\n    this.gl.frontFace(this.gl.CCW);\n  }\n\n  intersectionTest(mouseX, mouseY) {\n    let fieldOfView = Math.PI / 6;\n    let aspectRatio = this.canvas.width / this.canvas.height; // Normalize the pixel coordinates\n\n    let xNormalized = (mouseX - this.canvas.width * 0.5) * (1.0 / this.canvas.width) * 0.5;\n    let yNormalized = -(mouseY - this.canvas.height * 0.5) * (1.0 / this.canvas.width) * 0.5; // Move the x coordinate in the cameras x direction\n\n    let xDirection = this.camera.right.multipleBy(xNormalized); // Move the y coordinate in the cameras y direction\n\n    let yDirection = this.camera.up.multipleBy(yNormalized); // Ray direction\n\n    let rayDir = Vector3.add(this.camera.forward, Vector3.add(xDirection, yDirection).multipleBy(2.0)).normalized(); //console.log(\"ray direction: \" + rayDir.x.toFixed(3) + \", \" + rayDir.y.toFixed(3) + \", \" + rayDir.z.toFixed(3));\n\n    let rayStart = this.camera.position.clone(); //console.log(\"ray start: \" + rayStart.x.toFixed(1) + \", \" + rayStart.y.toFixed(1) + \", \" + rayStart.z.toFixed(1));\n\n    Vector3.add(rayStart, rayDir.multipleBy(2.0));\n    this.rayVertices = [];\n    let t = 1.0;\n\n    for (let i = 2; i < 12; i++) {\n      t += 0.1;\n      let vertex = Vector3.add(rayStart, rayDir.multipleBy(t));\n      this.rayVertices[i * 3] = vertex.x;\n      this.rayVertices[i * 3 + 1] = vertex.y;\n      this.rayVertices[i * 3 + 2] = vertex.z;\n    }\n\n    this.createRay(); // Define a sphere\n\n    let sphere = {\n      center: new Vector3([0.0, 1.0, 0.0]),\n      radius: 2.0\n    };\n    let rayToSphere = Vector3.subtract(sphere.center, rayStart);\n    let tca = Vector3.dot(rayToSphere, rayDir);\n\n    if (tca < 0.0) {\n      console.log(\"miss\");\n      return false;\n    }\n\n    let d = Math.sqrt(Vector3.dot(rayToSphere, rayToSphere) - tca * tca);\n\n    if (d > sphere.radius) {\n      console.log(\"miss\");\n      return false;\n    } else {\n      console.log(\"hit\");\n      return true;\n    }\n    /*\r\n    let thc = Math.sqrt(sphere.radius*sphere.radius - d*d);\r\n    let intersectionPoint1 = tca - thc;\r\n    let intersectionPoint2 = tca + thc;\r\n    */\n\n  }\n\n  drawRay() {\n    if (this.rayVertices === null) return; // Use the combined shader program object\n\n    this.gl.useProgram(this.shaderProgram);\n    /*======= Associating shaders to buffer objects ======*/\n    // Bind vertex buffer object\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertex_buffer); // Get the attribute location\n\n    let coord = this.gl.getAttribLocation(this.shaderProgram, \"coordinates\"); // Point an attribute to the currently bound VBO\n\n    this.gl.vertexAttribPointer(coord, 3, this.gl.FLOAT, false, 0, 0); // Enable the attribute\n\n    this.gl.enableVertexAttribArray(coord);\n    /*============ Drawing the triangle =============*/\n    // Draw the triangle\n\n    this.gl.drawArrays(this.gl.LINES, 0, 10); // POINTS, LINE_STRIP, LINE_LOOP, LINES,\n    // TRIANGLE_STRIP,TRIANGLE_FAN, TRIANGLES\n  }\n\n  createRay(vertices) {\n    // Create an empty buffer object\n    this.vertex_buffer = this.gl.createBuffer(); // Bind appropriate array buffer to it\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertex_buffer); // Pass the vertex data to the buffer\n\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW); // Unbind the buffer\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    /*=================== Shaders ====================*/\n    // Vertex shader source code\n\n    let vertCode = 'attribute vec3 coordinates;' + 'void main(void) {' + ' gl_Position = vec4(coordinates, 1.0);' + '}'; // Create a vertex shader object\n\n    let vertShader = this.gl.createShader(this.gl.VERTEX_SHADER); // Attach vertex shader source code\n\n    this.gl.shaderSource(vertShader, vertCode); // Compile the vertex shader\n\n    this.gl.compileShader(vertShader); // Fragment shader source code\n\n    let fragCode = 'void main(void) {' + 'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' + '}'; // Create fragment shader object\n\n    let fragShader = this.gl.createShader(this.gl.FRAGMENT_SHADER); // Attach fragment shader source code\n\n    this.gl.shaderSource(fragShader, fragCode); // Compile the fragmentt shader\n\n    this.gl.compileShader(fragShader); // Create a shader program object to store\n    // the combined shader program\n\n    this.shaderProgram = this.gl.createProgram(); // Attach a vertex shader\n\n    this.gl.attachShader(this.shaderProgram, vertShader); // Attach a fragment shader\n\n    this.gl.attachShader(this.shaderProgram, fragShader); // Link both the programs\n\n    this.gl.linkProgram(this.shaderProgram);\n  }\n\n}\n\nexport default Engine;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Engine.js"],"names":["Shader","Time","Camera","Mesh","GameObject","EventHandler","MouseEvent","Scene","PointLightSource","IntersectionField","Vector3","Matrix4","PhongLightingShader","AmbientShader","CAMERA_POSITION","CAMERA_ROTATION","SHAPE","CUBE","SPHERE","CYLINDER_SMOOTH","CYLINDER_SHARP","PLANE","MS_PER_UPDATE","Engine","constructor","lastTime","frameCount","fps","currentTextOffset","viewportAspectRatio","lag","scenes","shaders","Map","rayVertices","run","startTime","now","update","deltaTime","render","processCameraNavigation","camera","forEach","scene","mouseDown","console","log","offsetX","offsetY","intersectionTest","resetMouseEvents","residualLag","updateViewportDimensions","gl","clear","DEPTH_BUFFER_BIT","COLOR_BUFFER_BIT","updateLightPositions","draw","drawRay","drawTextElements","preload","init","setUpWebGL","mainShader","canvas","vertex","fragment","ambientShader","set","setPosition","setRotation","defaultScene","loadDefaultSceneObjects","push","currentAspectRatio","width","height","Math","abs","shader","activate","setProjectionUniformAspectRatio","viewport","ctx","font","fillStyle","clearRect","offsetWidth","displayFrameRate","displayCameraPosition","currentTime","time","fpsText","toFixed","fillText","length","pos","transform","position","cameraPositionText","x","y","z","createGameObject","settings","mesh","shape","createCube","createSphere","createCylinderSmooth","createCylinderSharp","createPlane","setColor","color","obj","name","setScale","scale","addMesh","createPointLightSource","lightSource","setLightColor","setAttenuation","attenuation","kLinear","kQuadratic","lightSourceModel","cube","addGameObject","wallColor","wallHeight","lampRadius","addLightSource","isPressed","middleButton","translate","movementY","movementX","leftButton","rightButton","rotate","wheelDelta","canvas2D","document","getElementById","getContext","alert","clearColor","enable","DEPTH_TEST","CULL_FACE","cullFace","BACK","frontFace","CCW","mouseX","mouseY","fieldOfView","PI","aspectRatio","xNormalized","yNormalized","xDirection","right","multipleBy","yDirection","up","rayDir","add","forward","normalized","rayStart","clone","t","i","createRay","sphere","center","radius","rayToSphere","subtract","tca","dot","d","sqrt","useProgram","shaderProgram","bindBuffer","ARRAY_BUFFER","vertex_buffer","coord","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","drawArrays","LINES","vertices","createBuffer","bufferData","Float32Array","STATIC_DRAW","vertCode","vertShader","createShader","VERTEX_SHADER","shaderSource","compileShader","fragCode","fragShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram"],"mappings":"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","sourcesContent":["//TODO: Implement a sky box background\r\n//TODO: Implement cubic shadow mapping\r\n//TODO: Implement a ParticleSystem component\r\n\r\n// JavaScript components\r\nimport Shader from \"./ShaderHandle\";\r\nimport Time from \"./Time\";\r\nimport Camera from \"./Camera\";\r\nimport Mesh from \"./Mesh\";\r\nimport GameObject from \"./GameObject\";\r\nimport EventHandler from \"./events/EventHandler\";\r\nimport MouseEvent from \"./events/MouseEvent\";\r\nimport Scene from \"./Scene\";\r\nimport PointLightSource from \"./PointLightSource\";\r\nimport IntersectionField from \"./IntersectionField\";\r\n\r\nimport Vector3 from \"./math/Vector3\";\r\nimport Matrix4 from \"./math/Matrix4\";\r\n\r\n// Shader files\r\nimport PhongLightingShader from \"./shaders/PhongLightingShader\";\r\nimport AmbientShader from \"./shaders/AmbientShader\";\r\n\r\n/***** Settings *****/\r\n// Default camera position and rotation\r\nconst CAMERA_POSITION = [0.0, 5.0, 40.0];\r\nconst CAMERA_ROTATION = [0.0, 0.0, 0.0];\r\n\r\n// Enum struct for creating different shapes\r\nconst SHAPE = {\r\n    CUBE: 0,\r\n    SPHERE: 1,\r\n    CYLINDER_SMOOTH: 2,\r\n    CYLINDER_SHARP: 3,\r\n    PLANE: 4\r\n};\r\n\r\nconst MS_PER_UPDATE = 2.0;\r\n\r\nclass Engine {\r\n    constructor() {\r\n        // Initialize timing variables\r\n        this.lastTime = 0.0;\r\n        this.frameCount = 0;\r\n        this.fps = 0;\r\n        this.currentTextOffset = 0;\r\n        this.viewportAspectRatio = 1.0;\r\n\r\n        this.lag = 0.0;\r\n\r\n        // Scenes works like blocks in the game world.\r\n        // The active scenes are based on the cameras distance to the origin of each scene.\r\n        this.scenes = [];\r\n\r\n        this.shaders = new Map();\r\n\r\n        this.rayVertices = [];\r\n    }\r\n\r\n    /*\r\n    * @brief This is the engines main update function and is called every iteration of the main loop\r\n    */\r\n    run() {\r\n        // Time start of the loop\r\n        let startTime =  Time.now;\r\n\r\n        // Update time clock\r\n        Time.update();\r\n\r\n        // Add elapsed time to the lag variable\r\n        this.lag += Time.deltaTime;\r\n\r\n        while (this.lag >= MS_PER_UPDATE) {\r\n            this.update();\r\n            this.lag -= MS_PER_UPDATE;\r\n        }\r\n\r\n        // Render graphics\r\n        this.render(this.lag/MS_PER_UPDATE);\r\n\r\n        // Hold each frame for a specified number of milliseconds (16 ms locks on roughly 60 fps)\r\n        //while ((Time.now - startTime) < 16.0) ; // Sleep\r\n    }\r\n\r\n    update() {\r\n        // Handle camera navigation\r\n        this.processCameraNavigation(this.camera);\r\n\r\n        this.scenes.forEach((scene) => {\r\n            scene.update();\r\n        });\r\n\r\n        if(MouseEvent.mouseDown) {\r\n            console.log(\"X: \" + MouseEvent.offsetX + \", Y: \" + MouseEvent.offsetY);\r\n\r\n            this.intersectionTest(MouseEvent.offsetX, MouseEvent.offsetY);\r\n        }\r\n\r\n        EventHandler.resetMouseEvents();\r\n    }\r\n\r\n    render(residualLag) {\r\n        // Set the viewport to the canvas dimensions and update the aspect ratio for the projection matrix\r\n        this.updateViewportDimensions();\r\n\r\n        // Clear screen 3D\r\n        this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);\r\n\r\n        // Draw scenes\r\n        this.scenes.forEach((scene) => {\r\n            scene.updateLightPositions();\r\n            scene.draw();\r\n        });\r\n\r\n        ///// INTERSECTION TEST //////\r\n        /*\r\n        this.intersect.updateBorders(this.camera, this.scenes[0].sceneObjects[0].transform.matrix, this.canvas.width, this.canvas.height);\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.strokeStyle = \"yellow\";\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(this.intersect.borders.xMin, this.intersect.borders.yMin);\r\n        this.ctx.lineTo(this.intersect.borders.xMax, this.intersect.borders.yMin);\r\n        this.ctx.lineTo(this.intersect.borders.xMax, this.intersect.borders.yMax);\r\n        this.ctx.lineTo(this.intersect.borders.xMin, this.intersect.borders.yMax);\r\n        this.ctx.closePath();\r\n        this.ctx.stroke();\r\n        */\r\n        ///// INTERSECTION TEST //////\r\n\r\n        this.drawRay();\r\n\r\n        // Display fps and other information\r\n        this.drawTextElements();\r\n    }\r\n\r\n    // This function is called before the game loop is initiated\r\n    preload() {\r\n        // Initiate time tracker component\r\n        Time.init();\r\n\r\n        // Initiate the event handler\r\n        EventHandler.init();\r\n\r\n        // Set up webgl 2D and 3D context from html canvas. Viewport and render settings are also set.\r\n        this.setUpWebGL();\r\n\r\n        // Create shaders\r\n        let mainShader = new Shader(this.canvas, PhongLightingShader.vertex, PhongLightingShader.fragment);\r\n        let ambientShader = new Shader(this.canvas, AmbientShader.vertex, AmbientShader.fragment);\r\n\r\n        this.shaders.set(\"phong\", mainShader);\r\n        this.shaders.set(\"ambient\", ambientShader);\r\n\r\n        // Initialize the main camera\r\n        this.camera = new Camera(this.shaders);\r\n        this.camera.setPosition(CAMERA_POSITION);\r\n        this.camera.setRotation(CAMERA_ROTATION);\r\n\r\n        // Create a scene for the objects\r\n        let defaultScene = new Scene(this.shaders);\r\n\r\n        // Create scene objects\r\n        this.loadDefaultSceneObjects(defaultScene);\r\n        // Add to scenes\r\n        this.scenes.push(defaultScene);\r\n\r\n        ///// INTERSECTION TEST //////\r\n        /*\r\n        this.intersect = new IntersectionField();\r\n        this.cubeMatrix = this.scenes[0].sceneObjects[0].transform.matrix;\r\n        this.intersect.updateBorders(this.camera, this.cubeMatrix, this.canvas.width, this.canvas.height);\r\n        */\r\n        ///// INTERSECTION TEST //////\r\n\r\n        ///// MULTIPLE SCENE TEST ///////\r\n        /*\r\n        let defaultScene2 = new Scene(this.shaders);\r\n        let defaultScene3 = new Scene(this.shaders);\r\n        let defaultScene4 = new Scene(this.shaders);\r\n\r\n        this.loadDefaultSceneObjects(defaultScene2);\r\n        this.loadDefaultSceneObjects(defaultScene3);\r\n        this.loadDefaultSceneObjects(defaultScene4);\r\n\r\n        defaultScene3.setPosition([0.0, 0.0, 80.0]);\r\n        defaultScene3.setRotation([0.0, 180.0, 0.0]);\r\n\r\n        defaultScene2.setPosition([0.0, 60.0, 0.0]);\r\n        defaultScene2.setRotation([0.0, 0.0, 180.0]);\r\n\r\n        defaultScene4.setPosition([0.0, 60.0, 80.0]);\r\n        defaultScene4.setRotation([0.0, 180.0, 180.0]);\r\n\r\n        this.scenes.push(defaultScene2);\r\n        this.scenes.push(defaultScene3);\r\n        this.scenes.push(defaultScene4);\r\n        */\r\n        ///// MULTIPLE SCENE TEST ///////\r\n    }\r\n\r\n    updateViewportDimensions() {\r\n        // Calculate current aspect ratio\r\n        let currentAspectRatio = this.canvas.width / this.canvas.height;\r\n\r\n        // Check if the aspect ratio has changed before going further\r\n        if (Math.abs(this.viewportAspectRatio - currentAspectRatio) < 0.001)\r\n            return;\r\n\r\n        // Update the projection matrix for the shaders\r\n        this.shaders.forEach((shader) => {\r\n            shader.activate();\r\n            shader.setProjectionUniformAspectRatio(currentAspectRatio);\r\n        });\r\n\r\n        // Update the viewport dimensions to the canvas width\r\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        // Save current aspect ratio\r\n        this.viewportAspectRatio = currentAspectRatio;\r\n    }\r\n\r\n    drawTextElements() {\r\n        // Set text font style\r\n        this.ctx.font = \"20px Consolas\";\r\n        this.ctx.fillStyle = 'white';\r\n        this.currentTextOffset = 0;\r\n\r\n        // Clear previous\r\n        this.ctx.clearRect(this.currentTextOffset, 0, this.canvas.offsetWidth, 30);\r\n\r\n        // Draw the text\r\n        this.displayFrameRate();\r\n        this.displayCameraPosition();\r\n    }\r\n\r\n    displayFrameRate() {\r\n        let currentTime = Time.time;\r\n        // If tNow - tLast >= 1000, one second has passed\r\n        if ((currentTime - this.lastTime) >= 1000.0) {\r\n            // Fps = the number of frames\r\n            this.fps = this.frameCount;\r\n            // Update timer\r\n            this.lastTime = currentTime;\r\n            // Reset frame count\r\n            this.frameCount = 0;\r\n        }\r\n        else {\r\n            ++this.frameCount;\r\n        }\r\n\r\n        // Compose text string\r\n        let fpsText = \"Frame rate: \" + this.fps + \" fps, Time per frame: \" + Time.deltaTime.toFixed(0) + \" ms,\";\r\n        // Draw fps and frame time in milliseconds\r\n        this.ctx.fillText(fpsText, 10, 25);\r\n        // Update text offset for next text\r\n        this.currentTextOffset = fpsText.length * 12 + 10;\r\n    }\r\n\r\n    displayCameraPosition() {\r\n        let pos = this.camera.transform.position;\r\n        // Compose text string\r\n        let cameraPositionText = \"Camera position: (\" + pos.x.toFixed(2) + \", \" + pos.y.toFixed(2) + \", \" + pos.z.toFixed(2) + \")\";\r\n\r\n        // Draw fps and frame time in milliseconds\r\n        this.ctx.fillText(cameraPositionText, this.currentTextOffset, 25);\r\n        // Update text offset for next text\r\n        this.currentTextOffset = cameraPositionText.length * 12;\r\n    }\r\n\r\n    createGameObject (settings) {\r\n        let mesh = new Mesh(this.gl);\r\n        if (settings.shape === SHAPE.CUBE) {\r\n            mesh.createCube();\r\n        }\r\n        else if (settings.shape === SHAPE.SPHERE) {\r\n            mesh.createSphere(32);\r\n        }\r\n        else if (settings.shape === SHAPE.CYLINDER_SMOOTH) {\r\n            mesh.createCylinderSmooth(32, 1, 1, 2);\r\n        }\r\n        else if(settings.shape === SHAPE.CYLINDER_SHARP) {\r\n            mesh.createCylinderSharp(8, 1, 2);\r\n        }\r\n        else if (settings.shape === SHAPE.PLANE) {\r\n            mesh.createPlane(50,50);\r\n        }\r\n        mesh.setColor(settings.color);\r\n\r\n        let obj = new GameObject (settings.name);\r\n        obj.setPosition(settings.position);\r\n        obj.setScale(settings.scale);\r\n        obj.addMesh(mesh);\r\n\r\n        return obj;\r\n    }\r\n\r\n    createPointLightSource(settings) {\r\n        // Create the light source component\r\n        let lightSource = new PointLightSource(settings.name);\r\n        lightSource.setPosition(settings.position);\r\n        lightSource.setScale(settings.scale);\r\n        lightSource.setLightColor(settings.color);\r\n        lightSource.setAttenuation(settings.attenuation.kLinear, settings.attenuation.kQuadratic);\r\n\r\n        // Create a model for the light source\r\n        let lightSourceModel = new Mesh(this.gl);\r\n        lightSourceModel.createSphere(8);\r\n        lightSourceModel.setColor(settings.color);\r\n        lightSource.addMesh(lightSourceModel);\r\n\r\n        return lightSource;\r\n    }\r\n\r\n    loadDefaultSceneObjects(scene) {\r\n        // Create a red cube\r\n        let cube = this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Red Cube',\r\n            scale: [1.0, 1.0, 1.0],\r\n            position: [0.0, 1.5, 0.0],\r\n            color: [1.0, 0.0, 0.0]\r\n        });\r\n        scene.addGameObject(cube);\r\n\r\n        // Create a green sphere\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.SPHERE,\r\n                name: 'Green Sphere',\r\n                scale: [1.0, 1.0, 1.0],\r\n                position: [4.0, 2.0, 2.0],\r\n                color: [0.0, 1.0, 0.0]\r\n            })\r\n        );\r\n\r\n        // Create a smooth magenta cylinder\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.CYLINDER_SMOOTH,\r\n                name: 'Magenta Cylinder',\r\n                scale: [1.0, 1.0, 1.0],\r\n                position: [-4.0, 2.0, 2.0],\r\n                color: [1.0, 0.0, 1.0]\r\n            })\r\n        );\r\n\r\n        // Create a sharp orange cylinder\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.CYLINDER_SHARP,\r\n                name: 'Orange Cylinder',\r\n                scale: [1.0, 1.0, 1.0],\r\n                position: [-8.0, 2.0, 2.0],\r\n                color: [1.0, 0.5, 0.0]\r\n            })\r\n        );\r\n\r\n        // Create gray floor\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.CUBE,\r\n                name: 'Roof',\r\n                scale: [40.0, 0.1, 40.0],\r\n                position: [0.0, 0.0, 0.0],\r\n                color: [0.75, 0.75, 0.75]\r\n            })\r\n        );\r\n\r\n        // Create blue walls\r\n        let wallColor = [0.0, 0.2, 1.0];\r\n        let wallHeight = 10.0;\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.CUBE,\r\n                name: 'Left Wall',\r\n                scale: [0.1, wallHeight, 20.0],\r\n                position: [-40.0, wallHeight, -20.0],\r\n                color: wallColor\r\n            })\r\n        );\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.CUBE,\r\n                name: 'Right Wall',\r\n                scale: [0.1, wallHeight, 20.0],\r\n                position: [40.0, wallHeight, -20.0],\r\n                color: wallColor\r\n            })\r\n        );\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.CUBE,\r\n                name: 'Back Wall',\r\n                scale: [40.0, wallHeight, 0.1],\r\n                position: [0.0, wallHeight, -40.0],\r\n                color: wallColor\r\n            })\r\n        );\r\n\r\n        // Create gray roof\r\n        scene.addGameObject(\r\n            this.createGameObject({\r\n                shape: SHAPE.CUBE,\r\n                name: 'Floor',\r\n                scale: [40.0, 0.1, 20.0],\r\n                position: [0.0, wallHeight * 2.0, -20.0],\r\n                color: [0.5, 0.5, 0.5]\r\n            })\r\n        );\r\n\r\n        // Create a point lights for the scene\r\n        // Add the light source to our scene\r\n        let lampRadius = 0.5;\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [0.0, 2.0 * wallHeight - lampRadius, -35.0],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Right Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [37.5, 2.0 * wallHeight - lampRadius, -15.0],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Left Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [-37.5, 2.0 * wallHeight - lampRadius, -15.0],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n    }\r\n\r\n    processCameraNavigation () {\r\n        // Zoom camera view in and out\r\n        if (MouseEvent.isPressed.middleButton) {\r\n            this.camera.translate([0.0, 0.0, -(MouseEvent.movementY + MouseEvent.movementX)/20.0]);\r\n        } // Pan the camera view\r\n        else if(MouseEvent.isPressed.leftButton) {\r\n            this.camera.translate([-MouseEvent.movementX/40.0, MouseEvent.movementY/40.0, 0.0]);\r\n        } // Rotate the camera view\r\n        else if (MouseEvent.isPressed.rightButton) {\r\n            this.camera.rotate([-MouseEvent.movementY/10.0, -MouseEvent.movementX/10.0, 0.0]);\r\n        }\r\n\r\n        if (Math.abs(MouseEvent.wheelDelta) > 0.01) {\r\n            if (MouseEvent.wheelDelta > 0.0) {\r\n                this.camera.translate([0.0, 0.0, 0.5]);\r\n            }\r\n            else\r\n                this.camera.translate([0.0, 0.0, -0.5]);\r\n        }\r\n    }\r\n\r\n    setUpWebGL() {\r\n        // 2D Canvas for text display\r\n        this.canvas2D = document.getElementById('text-canvas');\r\n        this.ctx = this.canvas2D.getContext('2d');\r\n\r\n        // WebGL canvas\r\n        this.canvas = document.getElementById(\"gl-canvas\");\r\n        // Initialize the WebGL context\r\n        this.gl = this.canvas.getContext(\"webgl\");\r\n\r\n        // If WebGL isn't supported\r\n        if (!this.gl) {\r\n            console.log(\"WebGL is not supported\");\r\n            alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n            return 0;\r\n        }\r\n\r\n        // Set the viewport dimensions to the same as the canvas\r\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n        // Set clear color to dark blue, fully opaque\r\n        this.gl.clearColor(0.02, 0.02, 0.02, 1.0);\r\n        // Enable depth so that triangles closer to the camera don't get overlapped by those further away\r\n        this.gl.enable(this.gl.DEPTH_TEST);\r\n        // Only draw \"visible\" sides (memory saving)\r\n        this.gl.enable(this.gl.CULL_FACE);\r\n        this.gl.cullFace(this.gl.BACK);\r\n        this.gl.frontFace(this.gl.CCW);\r\n    }\r\n\r\n    intersectionTest(mouseX, mouseY) {\r\n        let fieldOfView = Math.PI / 6;\r\n        let aspectRatio = this.canvas.width / this.canvas.height;\r\n\r\n        // Normalize the pixel coordinates\r\n        let xNormalized = (mouseX - this.canvas.width * 0.5) * (1.0 / this.canvas.width) * 0.5;\r\n        let yNormalized = -(mouseY - this.canvas.height * 0.5) * (1.0 / this.canvas.width) * 0.5;\r\n\r\n        // Move the x coordinate in the cameras x direction\r\n        let xDirection = this.camera.right.multipleBy(xNormalized);\r\n        // Move the y coordinate in the cameras y direction\r\n        let yDirection = this.camera.up.multipleBy(yNormalized);\r\n\r\n        // Ray direction\r\n        let rayDir = (Vector3.add(this.camera.forward, Vector3.add(xDirection, yDirection).multipleBy(2.0))).normalized();\r\n        //console.log(\"ray direction: \" + rayDir.x.toFixed(3) + \", \" + rayDir.y.toFixed(3) + \", \" + rayDir.z.toFixed(3));\r\n\r\n        let rayStart = this.camera.position.clone();\r\n        //console.log(\"ray start: \" + rayStart.x.toFixed(1) + \", \" + rayStart.y.toFixed(1) + \", \" + rayStart.z.toFixed(1));\r\n\r\n        Vector3.add(rayStart, rayDir.multipleBy(2.0));\r\n        this.rayVertices = [];\r\n        let t = 1.0;\r\n        for (let i = 2; i < 12; i++) {\r\n            t += 0.1;\r\n            let vertex = Vector3.add(rayStart, rayDir.multipleBy(t));\r\n            this.rayVertices[i * 3] = vertex.x;\r\n            this.rayVertices[i * 3 + 1] = vertex.y;\r\n            this.rayVertices[i * 3 + 2] = vertex.z;\r\n        }\r\n        this.createRay();\r\n\r\n        // Define a sphere\r\n        let sphere = {\r\n            center: new Vector3([0.0, 1.0, 0.0]),\r\n            radius: 2.0\r\n        };\r\n\r\n        let rayToSphere = Vector3.subtract(sphere.center, rayStart);\r\n        let tca = Vector3.dot(rayToSphere, rayDir);\r\n\r\n        if (tca < 0.0) {\r\n            console.log(\"miss\");\r\n            return false;\r\n        }\r\n\r\n        let d = Math.sqrt(Vector3.dot(rayToSphere, rayToSphere) - tca*tca);\r\n        if (d > sphere.radius) {\r\n            console.log(\"miss\");\r\n            return false;\r\n        }\r\n        else {\r\n            console.log(\"hit\");\r\n            return true;\r\n        }\r\n        /*\r\n        let thc = Math.sqrt(sphere.radius*sphere.radius - d*d);\r\n        let intersectionPoint1 = tca - thc;\r\n        let intersectionPoint2 = tca + thc;\r\n        */\r\n    }\r\n\r\n    drawRay() {\r\n        if (this.rayVertices === null)\r\n            return;\r\n\r\n        // Use the combined shader program object\r\n        this.gl.useProgram(this.shaderProgram);\r\n\r\n        /*======= Associating shaders to buffer objects ======*/\r\n\r\n        // Bind vertex buffer object\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertex_buffer);\r\n\r\n        // Get the attribute location\r\n        let coord = this.gl.getAttribLocation(this.shaderProgram, \"coordinates\");\r\n\r\n        // Point an attribute to the currently bound VBO\r\n        this. gl.vertexAttribPointer(coord, 3, this.gl.FLOAT, false, 0, 0);\r\n\r\n        // Enable the attribute\r\n        this.gl.enableVertexAttribArray(coord);\r\n\r\n        /*============ Drawing the triangle =============*/\r\n\r\n        // Draw the triangle\r\n        this.gl.drawArrays(this.gl.LINES, 0, 10);\r\n\r\n        // POINTS, LINE_STRIP, LINE_LOOP, LINES,\r\n        // TRIANGLE_STRIP,TRIANGLE_FAN, TRIANGLES\r\n    }\r\n\r\n    createRay(vertices) {\r\n\r\n        // Create an empty buffer object\r\n        this.vertex_buffer = this.gl.createBuffer();\r\n\r\n        // Bind appropriate array buffer to it\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertex_buffer);\r\n\r\n        // Pass the vertex data to the buffer\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind the buffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n\r\n        /*=================== Shaders ====================*/\r\n\r\n        // Vertex shader source code\r\n        let vertCode =\r\n            'attribute vec3 coordinates;' +\r\n            'void main(void) {' +\r\n            ' gl_Position = vec4(coordinates, 1.0);' +\r\n            '}';\r\n\r\n        // Create a vertex shader object\r\n        let vertShader = this.gl.createShader(this.gl.VERTEX_SHADER);\r\n\r\n        // Attach vertex shader source code\r\n        this.gl.shaderSource(vertShader, vertCode);\r\n\r\n        // Compile the vertex shader\r\n        this.gl.compileShader(vertShader);\r\n\r\n        // Fragment shader source code\r\n        let fragCode =\r\n            'void main(void) {' +\r\n            'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\r\n            '}';\r\n\r\n        // Create fragment shader object\r\n        let fragShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\r\n\r\n        // Attach fragment shader source code\r\n        this.gl.shaderSource(fragShader, fragCode);\r\n\r\n        // Compile the fragmentt shader\r\n        this.gl.compileShader(fragShader);\r\n\r\n        // Create a shader program object to store\r\n        // the combined shader program\r\n        this.shaderProgram = this.gl.createProgram();\r\n\r\n        // Attach a vertex shader\r\n        this.gl.attachShader(this.shaderProgram, vertShader);\r\n\r\n        // Attach a fragment shader\r\n        this.gl.attachShader(this.shaderProgram, fragShader);\r\n\r\n        // Link both the programs\r\n        this.gl.linkProgram(this.shaderProgram);\r\n    }\r\n}\r\n\r\nexport default Engine;"]},"metadata":{},"sourceType":"module"}