{"ast":null,"code":"import Time from \"./Time\";\nimport Transform from \"./Transform\";\nimport ShapeGenerator from \"./ShapeGenerator\";\n\nclass Mesh {\n  constructor(shader) {\n    this.shader = shader;\n    this.gl = shader.gl;\n    this.positionAttributeLocation = shader.positionAttributeLocation;\n    this.normalAttributeLocation = shader.normalAttributeLocation;\n    this.textureAttributeLocation = shader.textureAttributeLocation;\n    this.colorUniformLocation = shader.colorUniformLocation;\n    this.matrixUniformLocation = shader.modelViewUniformLocation;\n    this.timeUniformLocation = shader.timeUniformLocation;\n    this.totalVertices = 0;\n    this.color = [0.5, 0.5, 0.5];\n    this.shape = null;\n    this.transform = new Transform();\n  }\n\n  clone() {\n    let clone = new Mesh(this.shader);\n    if (this.shape === 'cube') clone.createCube();else if (this.shape === 'sphere') clone.createSphere(64);\n    clone.setColor(this.color);\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  setPosition(pos) {\n    this.transform.setPosition(pos);\n  }\n\n  setScale(scale) {\n    this.transform.setScale(scale);\n  }\n\n  setRotation(rot) {\n    this.transform.setRotation(rot);\n  }\n\n  render() {\n    if (this.shape) {\n      this.shader.use();\n      this.updateUniforms();\n      this.bindBuffersAndEnableAttributes(); // Draw our graphics\n      // Param 1 specifies how to draw from vertices,\n      // param 2 is how many vertices we use to draw\n      // param 3 is what type the elements are\n      // param 4 is the starting point from the array\n\n      this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\n      this.unbindBuffers();\n    } else {\n      console.log(\"ERROR! The mesh got no shape!\");\n    }\n  }\n\n  updateUniforms() {\n    this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\n    this.gl.uniform3fv(this.colorUniformLocation, this.color);\n    this.gl.uniform1f(this.timeUniformLocation, Time.time);\n  }\n\n  unbindBuffers() {\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  bindBuffersAndEnableAttributes() {\n    // Vertex buffer\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); // Enable vertex attribute\n\n    this.gl.vertexAttribPointer(this.positionAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.FALSE, // Don't normalize the data\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\n    0 // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.positionAttributeLocation); // Enable normal attribute\n\n    this.gl.vertexAttribPointer(this.normalAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.TRUE, // Not normalized\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\n    3 * Float32Array.BYTES_PER_ELEMENT // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.normalAttributeLocation); // Index buffer\n\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  }\n\n  createCylinder(vertSeg, horizSeg) {\n    this.shape = 'cylinder';\n    let cylinderData = ShapeGenerator.createCylinder(vertSeg, horizSeg, 1.0, 2.0);\n    this.totalVertices = cylinderData.numVertices; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cylinderData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createSphere(segments) {\n    this.shape = 'sphere';\n    let sphereData = ShapeGenerator.createSphere(segments, 1.0);\n    this.totalVertices = sphereData.numVertices; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sphereData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createCube() {\n    this.shape = 'cube';\n    let cubeData = ShapeGenerator.generateCubeData();\n    this.totalVertices = cubeData.numVertices; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cubeData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createPlane(rows, columns) {\n    this.shape = 'plane';\n    let index = 0;\n    let x = 0;\n    let vertexArray = []; // Generate and store coordinates in vertex array\n\n    for (let i = 0; i <= columns; ++i) {\n      x = -(rows / 2);\n\n      for (let k = 0; k <= rows; ++k) {\n        // Storing one vertex at the time (x,y,z)\n        vertexArray[index] = x;\n        vertexArray[index + 1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\n\n        vertexArray[index + 2] = -i; // Set normals\n\n        vertexArray[index + 3] = 0.0;\n        vertexArray[index + 4] = 1.0;\n        vertexArray[index + 5] = 0.0; // Texture coordinates\n\n        vertexArray[index + 6] = 0.0;\n        vertexArray[index + 7] = 0.0; // We go from left to right in the direction of x-axis\n\n        ++x; // Increase by three since we store values in three indices at the time\n\n        index += 8;\n      }\n    } // v0-v3 represent the four vertices in one quad\n\n\n    let v0 = 0;\n    let v1 = 1;\n    let v2 = rows + 2;\n    let v3 = rows + 1;\n    index = 0;\n    let indexArray = []; // Store indices in index array\n\n    for (let j = 0; j < columns; ++j) {\n      // Each iteration generates the order of vertex indices for one full quad\n      for (let l = 0; l < rows; ++l) {\n        // Triangle 1\n        indexArray[index] = v0;\n        indexArray[index + 1] = v1;\n        indexArray[index + 2] = v2; // Triangle 2\n\n        indexArray[index + 3] = v2;\n        indexArray[index + 4] = v3;\n        indexArray[index + 5] = v0; // Increase for next quad\n\n        ++v0;\n        ++v1;\n        ++v2;\n        ++v3;\n        index += 6;\n      } // Increase one more time after a full row of quads\n\n\n      ++v0;\n      ++v1;\n      ++v2;\n      ++v3;\n    } //this.totalTriangles = rows*columns*2;\n    //this.totalVertices = this.totalTriangles*3;\n\n\n    this.totalVertices = indexArray.length; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n}\n\nexport default Mesh;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Mesh.js"],"names":["Time","Transform","ShapeGenerator","Mesh","constructor","shader","gl","positionAttributeLocation","normalAttributeLocation","textureAttributeLocation","colorUniformLocation","matrixUniformLocation","modelViewUniformLocation","timeUniformLocation","totalVertices","color","shape","transform","clone","createCube","createSphere","setColor","setPosition","pos","setScale","scale","setRotation","rot","render","use","updateUniforms","bindBuffersAndEnableAttributes","drawElements","TRIANGLES","UNSIGNED_SHORT","unbindBuffers","console","log","uniformMatrix4fv","FALSE","matrix","uniform3fv","uniform1f","time","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","vertexBuffer","vertexAttribPointer","FLOAT","Float32Array","BYTES_PER_ELEMENT","enableVertexAttribArray","TRUE","indexBuffer","createCylinder","vertSeg","horizSeg","cylinderData","numVertices","createBuffer","bufferData","vertices","STATIC_DRAW","Uint16Array","indices","segments","sphereData","cubeData","generateCubeData","createPlane","rows","columns","index","x","vertexArray","i","k","v0","v1","v2","v3","indexArray","j","l","length"],"mappings":"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","sourcesContent":["import Time from \"./Time\";\r\nimport Transform from \"./Transform\";\r\nimport ShapeGenerator from \"./ShapeGenerator\";\r\n\r\nclass Mesh {\r\n    constructor(shader) {\r\n        this.shader = shader;\r\n        this.gl = shader.gl;\r\n        this.positionAttributeLocation = shader.positionAttributeLocation;\r\n        this.normalAttributeLocation = shader.normalAttributeLocation;\r\n        this.textureAttributeLocation = shader.textureAttributeLocation;\r\n        this.colorUniformLocation = shader.colorUniformLocation;\r\n        this.matrixUniformLocation = shader.modelViewUniformLocation;\r\n        this.timeUniformLocation = shader.timeUniformLocation;\r\n\r\n        this.totalVertices = 0;\r\n\r\n        this.color = [0.5, 0.5, 0.5];\r\n        this.shape = null;\r\n\r\n        this.transform = new Transform();\r\n    }\r\n\r\n    clone() {\r\n        let clone = new Mesh(this.shader);\r\n\r\n        if (this.shape === 'cube')\r\n            clone.createCube();\r\n        else if (this.shape === 'sphere')\r\n            clone.createSphere(64);\r\n\r\n        clone.setColor(this.color);\r\n        clone.transform = this.transform.clone();\r\n        return clone;\r\n    }\r\n\r\n    setColor(color) {\r\n        this.color = color;\r\n    }\r\n\r\n    setPosition(pos) {\r\n        this.transform.setPosition(pos);\r\n    }\r\n\r\n    setScale (scale) {\r\n        this.transform.setScale(scale);\r\n    }\r\n\r\n    setRotation (rot) {\r\n        this.transform.setRotation(rot);\r\n    }\r\n\r\n    render() {\r\n        if (this.shape) {\r\n            this.shader.use();\r\n            this.updateUniforms();\r\n            this.bindBuffersAndEnableAttributes();\r\n            // Draw our graphics\r\n            // Param 1 specifies how to draw from vertices,\r\n            // param 2 is how many vertices we use to draw\r\n            // param 3 is what type the elements are\r\n            // param 4 is the starting point from the array\r\n            this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\r\n            this.unbindBuffers();\r\n        }\r\n        else {\r\n            console.log(\"ERROR! The mesh got no shape!\");\r\n        }\r\n    }\r\n\r\n    updateUniforms() {\r\n        this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\r\n        this.gl.uniform3fv(this.colorUniformLocation, this.color);\r\n        this.gl.uniform1f(this.timeUniformLocation, Time.time);\r\n    }\r\n\r\n    unbindBuffers() {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    bindBuffersAndEnableAttributes() {\r\n        // Vertex buffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n\r\n        // Enable vertex attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.positionAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.FALSE, // Don't normalize the data\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\r\n            0// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.positionAttributeLocation);\r\n\r\n        // Enable normal attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.normalAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.TRUE, // Not normalized\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\r\n            3 * Float32Array.BYTES_PER_ELEMENT// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.normalAttributeLocation);\r\n\r\n        // Index buffer\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n    }\r\n\r\n    createCylinder (vertSeg, horizSeg) {\r\n        this.shape = 'cylinder';\r\n\r\n        let cylinderData = ShapeGenerator.createCylinder(vertSeg, horizSeg, 1.0, 2.0);\r\n        this.totalVertices = cylinderData.numVertices;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cylinderData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createSphere (segments) {\r\n        this.shape = 'sphere';\r\n\r\n        let sphereData = ShapeGenerator.createSphere(segments, 1.0);\r\n        this.totalVertices = sphereData.numVertices;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sphereData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createCube() {\r\n        this.shape = 'cube';\r\n        let cubeData = ShapeGenerator.generateCubeData();\r\n        this.totalVertices = cubeData.numVertices;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cubeData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createPlane (rows, columns) {\r\n        this.shape = 'plane';\r\n\r\n        let index = 0;\r\n        let x = 0;\r\n        let vertexArray = [];\r\n        // Generate and store coordinates in vertex array\r\n        for (let i = 0; i <= columns; ++i) {\r\n            x = -(rows/2);\r\n            for (let k = 0; k <= rows; ++k) {\r\n                // Storing one vertex at the time (x,y,z)\r\n                vertexArray[index] = x;\r\n                vertexArray[index+1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\r\n                vertexArray[index+2] = -i;\r\n\r\n                // Set normals\r\n                vertexArray[index+3] = 0.0;\r\n                vertexArray[index+4] = 1.0;\r\n                vertexArray[index+5] = 0.0;\r\n\r\n                // Texture coordinates\r\n                vertexArray[index+6] = 0.0;\r\n                vertexArray[index+7] = 0.0;\r\n\r\n                // We go from left to right in the direction of x-axis\r\n                ++x;\r\n                // Increase by three since we store values in three indices at the time\r\n                index += 8;\r\n            }\r\n        }\r\n\r\n        // v0-v3 represent the four vertices in one quad\r\n        let v0 = 0;\r\n        let v1 = 1;\r\n        let v2 = rows+2;\r\n        let v3 = rows+1;\r\n        index = 0;\r\n        let indexArray = [];\r\n        // Store indices in index array\r\n        for (let j = 0; j < columns; ++j) {\r\n            // Each iteration generates the order of vertex indices for one full quad\r\n            for (let l = 0; l < rows; ++l) {\r\n                // Triangle 1\r\n                indexArray[index] = v0;\r\n                indexArray[index + 1] = v1;\r\n                indexArray[index + 2] = v2;\r\n                // Triangle 2\r\n                indexArray[index + 3] = v2;\r\n                indexArray[index + 4] = v3;\r\n                indexArray[index + 5] = v0;\r\n\r\n                // Increase for next quad\r\n                ++v0;\r\n                ++v1;\r\n                ++v2;\r\n                ++v3;\r\n                index += 6;\r\n            }\r\n            // Increase one more time after a full row of quads\r\n            ++v0;\r\n            ++v1;\r\n            ++v2;\r\n            ++v3;\r\n        }\r\n        //this.totalTriangles = rows*columns*2;\r\n        //this.totalVertices = this.totalTriangles*3;\r\n        this.totalVertices = indexArray.length;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    };\r\n}\r\n\r\nexport default Mesh;"]},"metadata":{},"sourceType":"module"}