{"ast":null,"code":"import SphereCollider from \"./SphereCollider\";\nimport Vector3 from \"./math/Vector3\";\nimport Raycast from \"./Raycast\";\nimport CollisionManager from \"./CollisionManager\";\n\nclass RigidBody {\n  constructor(position, mass = 1.0) {\n    this.position = new Vector3(position);\n    this.velocity = new Vector3([0.0, 0.0, 0.0]);\n    this.acceleration = new Vector3([0.0, 0.0, 0.0]);\n    this.collider = new SphereCollider();\n    this.mass = mass;\n    this.enableGravity(true);\n    this.inCollision = false;\n  }\n\n  setVelocity(vel) {\n    this.velocity.set(vel);\n  }\n\n  setAcceleration(acc) {\n    this.acceleration.set(acc);\n  }\n\n  setPosition(pos) {\n    this.position.set(pos);\n  }\n\n  enableGravity(state) {\n    if (state) this.gravity = 9.82;else this.gravity = 0.0;\n  }\n\n  get gravityIsEnabled() {\n    return this.gravity > 0.1;\n  }\n\n  update(timeStep) {\n    //if (this.velocity.magnitude < 0.1)\n    //return false;\n    if (this.inCollision) return;\n    let nextVelocity = [this.velocity.x + this.acceleration.x * timeStep, this.velocity.y + (this.acceleration.y - this.gravity) * timeStep, this.velocity.z + this.acceleration.z * timeStep];\n    this.velocity.set(nextVelocity);\n    let nextPosition = [this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep];\n    this.position.set(nextPosition);\n    this.handleCollision(timeStep);\n    return true;\n  }\n\n  handleCollision(timeStep) {\n    let planes = CollisionManager.getPlaneColliders();\n    let rayDir = this.velocity.normalized();\n    let rayOrigin = this.position.clone();\n    let closestPoint = null;\n    let closestPlane = null; // Find closest intersectionPoint\n\n    planes.forEach(plane => {\n      let intersectionTest = Raycast.planeIntersectionTest(rayDir, rayOrigin, plane);\n\n      if (intersectionTest.point !== null) {\n        if (closestPoint) {\n          let distOld = Vector3.distance(closestPoint, rayOrigin);\n          let distNew = Vector3.distance(intersectionTest.point, rayOrigin);\n\n          if (distNew < distOld) {\n            closestPoint = intersectionTest.point;\n            closestPlane = plane;\n          }\n        } else {\n          closestPoint = intersectionTest.point;\n          closestPlane = plane;\n        }\n      }\n    });\n\n    if (closestPoint !== null) {\n      if (Vector3.distance(closestPoint, rayOrigin) < this.collider.radius * 3.0) {\n        let reflectDirection = Vector3.subtract(closestPlane.normal.clone().multipleBy(2.0 * Vector3.dot(closestPlane.normal, rayDir)), rayDir);\n        let bounce = this.velocity.magnitude * 0.75;\n        console.log(bounce);\n\n        if (bounce > 0.5) {\n          this.velocity.set([-reflectDirection.x * bounce, -reflectDirection.y * bounce + 9.82 * timeStep, -reflectDirection.z * bounce]);\n          let nextPosition = [this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep];\n          this.position.set(nextPosition);\n        } else {\n          let pos = [closestPoint[0] + closestPlane.normal.x * this.collider.radius, closestPoint[1] + closestPlane.normal.y * this.collider.radius, closestPoint[2] + closestPlane.normal.z * this.collider.radius];\n          this.position.set(pos);\n        }\n      }\n    }\n  }\n\n}\n\nexport default RigidBody;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\RigidBody.js"],"names":["SphereCollider","Vector3","Raycast","CollisionManager","RigidBody","constructor","position","mass","velocity","acceleration","collider","enableGravity","inCollision","setVelocity","vel","set","setAcceleration","acc","setPosition","pos","state","gravity","gravityIsEnabled","update","timeStep","nextVelocity","x","y","z","nextPosition","handleCollision","planes","getPlaneColliders","rayDir","normalized","rayOrigin","clone","closestPoint","closestPlane","forEach","plane","intersectionTest","planeIntersectionTest","point","distOld","distance","distNew","radius","reflectDirection","subtract","normal","multipleBy","dot","bounce","magnitude","console","log"],"mappings":"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","sourcesContent":["import SphereCollider from \"./SphereCollider\";\r\nimport Vector3 from \"./math/Vector3\";\r\nimport Raycast from \"./Raycast\";\r\nimport CollisionManager from \"./CollisionManager\";\r\n\r\nclass RigidBody {\r\n    constructor(position, mass = 1.0) {\r\n        this.position = new Vector3(position);\r\n        this.velocity = new Vector3([0.0, 0.0, 0.0]);\r\n        this.acceleration = new Vector3([0.0, 0.0, 0.0]);\r\n\r\n        this.collider = new SphereCollider();\r\n\r\n        this.mass = mass;\r\n        this.enableGravity(true);\r\n\r\n        this.inCollision = false;\r\n    }\r\n\r\n    setVelocity(vel) {\r\n        this.velocity.set(vel);\r\n    }\r\n\r\n    setAcceleration(acc) {\r\n        this.acceleration.set(acc);\r\n    }\r\n\r\n    setPosition(pos) {\r\n        this.position.set(pos);\r\n    }\r\n\r\n    enableGravity(state) {\r\n        if (state)\r\n            this.gravity = 9.82;\r\n        else\r\n            this.gravity = 0.0;\r\n    }\r\n\r\n    get gravityIsEnabled () {\r\n        return this.gravity > 0.1;\r\n    }\r\n\r\n    update(timeStep) {\r\n        //if (this.velocity.magnitude < 0.1)\r\n            //return false;\r\n\r\n        if (this.inCollision)\r\n            return;\r\n\r\n        let nextVelocity = [\r\n            this.velocity.x + this.acceleration.x * timeStep,\r\n            this.velocity.y + (this.acceleration.y - this.gravity) * timeStep,\r\n            this.velocity.z + this.acceleration.z * timeStep,\r\n        ];\r\n        this.velocity.set(nextVelocity);\r\n\r\n        let nextPosition = [\r\n            this.position.x + this.velocity.x * timeStep,\r\n            this.position.y + this.velocity.y * timeStep,\r\n            this.position.z + this.velocity.z * timeStep,\r\n        ];\r\n        this.position.set(nextPosition);\r\n\r\n        this.handleCollision(timeStep);\r\n\r\n        return true;\r\n    }\r\n\r\n    handleCollision(timeStep) {\r\n\r\n        let planes = CollisionManager.getPlaneColliders();\r\n\r\n        let rayDir = this.velocity.normalized();\r\n        let rayOrigin = this.position.clone();\r\n\r\n        let closestPoint = null;\r\n        let closestPlane = null;\r\n\r\n        // Find closest intersectionPoint\r\n        planes.forEach((plane) => {\r\n            let intersectionTest = Raycast.planeIntersectionTest(rayDir, rayOrigin, plane);\r\n            if (intersectionTest.point !== null) {\r\n                if (closestPoint) {\r\n                    let distOld = Vector3.distance(closestPoint, rayOrigin);\r\n                    let distNew = Vector3.distance(intersectionTest.point, rayOrigin);\r\n\r\n                    if (distNew < distOld) {\r\n                        closestPoint = intersectionTest.point;\r\n                        closestPlane = plane;\r\n                    }\r\n                }\r\n                else {\r\n                    closestPoint = intersectionTest.point;\r\n                    closestPlane = plane;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (closestPoint !== null) {\r\n\r\n            if (Vector3.distance(closestPoint, rayOrigin) < this.collider.radius*3.0) {\r\n                let reflectDirection = Vector3.subtract(closestPlane.normal.clone().multipleBy(2.0 * Vector3.dot(closestPlane.normal, rayDir)), rayDir);\r\n                let bounce = this.velocity.magnitude*0.75;\r\n\r\n                console.log(bounce);\r\n                if (bounce > 0.5) {\r\n                    this.velocity.set([\r\n                        -reflectDirection.x*bounce,\r\n                        -reflectDirection.y*bounce + 9.82 * timeStep,\r\n                        -reflectDirection.z*bounce\r\n                    ]);\r\n\r\n                    let nextPosition = [\r\n                        this.position.x + this.velocity.x * timeStep,\r\n                        this.position.y + this.velocity.y * timeStep,\r\n                        this.position.z + this.velocity.z * timeStep,\r\n                    ];\r\n                    this.position.set(nextPosition);\r\n                }\r\n                else {\r\n                    let pos = [\r\n                        closestPoint[0] + closestPlane.normal.x*this.collider.radius,\r\n                        closestPoint[1] + closestPlane.normal.y*this.collider.radius,\r\n                        closestPoint[2] + closestPlane.normal.z*this.collider.radius\r\n                    ];\r\n                    this.position.set(pos)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default RigidBody;"]},"metadata":{},"sourceType":"module"}