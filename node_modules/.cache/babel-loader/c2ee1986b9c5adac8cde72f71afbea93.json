{"ast":null,"code":"class ShapeGenerator {\n  constructor() {}\n\n  static generateCubeData(x = 1.0, y = 1.0, z = 1.0) {\n    // Vertex coordinates, normals and texture coordinates\n    let vertexArray = [// Vertex         Normal             Texture coordinates\n    // Vertex 0\n    -x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, // Vertex 1\n    -x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, -y, z, -1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 2\n    x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, -y, z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 3\n    x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, -y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 4\n    -x, y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, -x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 5\n    -x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, y, z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 6\n    x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, y, z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 7\n    x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0]; // Vertex indices\n\n    let indexArray = [// Bottom\n    0, 9, 6, // v0, v3, v2\n    6, 3, 0, // v2, v1, v0\n    // Front\n    4, 7, 18, // v1, v2, v6\n    18, 15, 4, // v6, v5, v1\n    // Left\n    1, 5, 16, // v0, v1, v5\n    16, 12, 1, // v5, v4, v0\n    // Back\n    2, 13, 21, // v0, v4, v7\n    21, 10, 2, // v7, v3, v0\n    // Right\n    8, 11, 22, // v2, v3, v7\n    22, 19, 8, // v7, v6, v2\n    // Top\n    14, 17, 20, // v4, v5, v6\n    20, 23, 14 // v6, v7, v4\n    ];\n    let totalTriangles = 12;\n    let totalVertices = totalTriangles * 3;\n    return {\n      numVertices: totalVertices,\n      vertices: vertexArray,\n      indices: indexArray\n    };\n  }\n\n  static generateSphereData(segments) {\n    let horizontalSegments = segments;\n\n    if (horizontalSegments < 2) {\n      horizontalSegments = 2;\n    }\n\n    let verticalSegments = 2 * horizontalSegments;\n    let vertices = []; // Bottom vertex and its normal (x, y, z)\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0;\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0;\n    vertices[6] = 0.0;\n    vertices[7] = 0.0;\n    let sampleResolution = Math.PI / horizontalSegments;\n    let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n    // Generate middle part vertices with normals\n\n    let index = 7;\n\n    for (let i = 0; i < horizontalSegments - 1; ++i) {\n      let y = Math.cos(theta);\n      let R = Math.sin(theta); // radius\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += sampleResolution;\n      }\n\n      theta += sampleResolution;\n    } // Top vertex and its normal (x, y, z)\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom cap\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = 1;\n\n    for (let i = 0; i < horizontalSegments - 2; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top cap\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static generateCylinderData(vertSeg, horizSeg) {\n    let horizontalSegments = horizSeg;\n    let verticalSegments = vertSeg;\n\n    if (horizontalSegments < 1) {\n      horizontalSegments = 1;\n    }\n\n    if (verticalSegments < 4) {\n      verticalSegments = 4;\n    }\n\n    let vertices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.0;\n    vertices[7] = 0.0; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -Math.PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0;\n    let index = 7; // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = -1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0; // Generate middle part vertices with normals\n\n    for (let i = 0; i <= horizontalSegments; ++i) {\n      let y = Math.cos(theta);\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += 2 * Math.PI / verticalSegments;\n      }\n\n      theta += Math.PI / horizontalSegments;\n    }\n\n    phi = 0; // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = 1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = verticalSegments + 2;\n\n    for (let i = 0; i < horizontalSegments; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top circle plane\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n}\n\nexport default ShapeGenerator;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\ShapeGenerator.js"],"names":["ShapeGenerator","constructor","generateCubeData","x","y","z","vertexArray","indexArray","totalTriangles","totalVertices","numVertices","vertices","indices","generateSphereData","segments","horizontalSegments","verticalSegments","sampleResolution","Math","PI","theta","phi","index","i","cos","R","sin","j","v0","lastVertexIndex","length","generateCylinderData","vertSeg","horizSeg"],"mappings":"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","sourcesContent":["class ShapeGenerator {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    static generateCubeData(x = 1.0, y = 1.0, z = 1.0) {\r\n        // Vertex coordinates, normals and texture coordinates\r\n        let vertexArray = [\r\n            // Vertex         Normal             Texture coordinates\r\n            // Vertex 0\r\n            -x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n\r\n            // Vertex 1\r\n            -x, -y,  z,     0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y,  z,     0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, -y,  z,    -1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 2\r\n            x, -y,  z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y,  z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, -y,  z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 3\r\n            x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, -y, -z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 4\r\n            -x, y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 5\r\n            -x, y, z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, y, z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 6\r\n            x, y, z,       0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, y, z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, z,       0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 7\r\n            x, y, -z,       0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, y, -z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, -z,       0.0,  1.0,  0.0,      0.0, 0.0\r\n        ];\r\n\r\n        // Vertex indices\r\n        let indexArray = [\t// Bottom\r\n            0, 9, 6,  // v0, v3, v2\r\n            6, 3, 0,  // v2, v1, v0\r\n\r\n            // Front\r\n            4, 7, 18,  // v1, v2, v6\r\n            18, 15, 4, // v6, v5, v1\r\n\r\n            // Left\r\n            1, 5, 16,  // v0, v1, v5\r\n            16, 12, 1, // v5, v4, v0\r\n\r\n            // Back\r\n            2, 13, 21, // v0, v4, v7\r\n            21, 10, 2, // v7, v3, v0\r\n\r\n            // Right\r\n            8, 11, 22, // v2, v3, v7\r\n            22, 19, 8, // v7, v6, v2\r\n\r\n            // Top\r\n            14, 17, 20, // v4, v5, v6\r\n            20, 23, 14  // v6, v7, v4\r\n        ];\r\n\r\n        let totalTriangles = 12;\r\n        let totalVertices = totalTriangles*3;\r\n\r\n        return {\r\n            numVertices: totalVertices,\r\n            vertices: vertexArray,\r\n            indices: indexArray\r\n        };\r\n    }\r\n\r\n    static generateSphereData(segments) {\r\n        let horizontalSegments = segments;\r\n\r\n        if (horizontalSegments < 2) {\r\n            horizontalSegments = 2;\r\n        }\r\n        let verticalSegments = 2*horizontalSegments;\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom vertex and its normal (x, y, z)\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        let sampleResolution = Math.PI/horizontalSegments;\r\n        let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = 7;\r\n        for(let i = 0; i < horizontalSegments-1; ++i) {\r\n            let y = Math.cos(theta);\r\n            let R = Math.sin(theta); // radius\r\n\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += sampleResolution;\r\n            }\r\n            theta += sampleResolution;\r\n        }\r\n\r\n        // Top vertex and its normal (x, y, z)\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom cap\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for(let i = 0; i < horizontalSegments-2; i++) {\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top cap\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static generateCylinderData (vertSeg, horizSeg) {\r\n        let horizontalSegments = horizSeg;\r\n        let verticalSegments = vertSeg;\r\n\r\n        if (horizontalSegments < 1) {\r\n            horizontalSegments = 1;\r\n        }\r\n        if (verticalSegments < 4) {\r\n            verticalSegments = 4;\r\n        }\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -Math.PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0;\r\n\r\n        let index = 7;\r\n        // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0;\r\n        // Generate middle part vertices with normals\r\n        for(let i = 0; i <= horizontalSegments; ++i) {\r\n\r\n            let y = Math.cos(theta);\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += (2*Math.PI)/verticalSegments;\r\n            }\r\n            theta += Math.PI/horizontalSegments;\r\n        }\r\n\r\n        phi = 0;\r\n        // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = verticalSegments+2;\r\n        for(let i = 0; i < horizontalSegments; i++) {\r\n\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n\r\n        // Top circle plane\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n}\r\n\r\nexport default ShapeGenerator;"]},"metadata":{},"sourceType":"module"}