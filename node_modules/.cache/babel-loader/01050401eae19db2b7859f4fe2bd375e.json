{"ast":null,"code":"import Matrix4 from './math/Matrix4';\n\nclass IntersectionField {\n  constructor(vertices) {\n    this.vertices = vertices;\n    this.borders = {\n      xMin: 0,\n      xMax: 0,\n      yMin: 0,\n      yMax: 0\n    };\n  }\n\n  static setCanvasSize(w, h) {\n    this.width = w;\n    this.height = h;\n  }\n\n  static setCameraView(camera) {\n    this.cameraView = camera;\n    console.log(camera);\n  }\n\n  updateBorders(matrix) {\n    let camera = IntersectionField.cameraView;\n    let width = IntersectionField.width;\n    let height = IntersectionField.height;\n\n    if (camera) {\n      this.borders.xMin = width + 1;\n      this.borders.xMax = -1;\n      this.borders.yMin = height + 1;\n      this.borders.yMax = -1; // Set the width and height of the viewport\n\n      let screenW = width / (width * Math.sqrt(width / height));\n      let screenH = height / (width * Math.sqrt(width / height));\n\n      for (let i = 0; i < this.vertices.length; ++i) {\n        // Take one point from a local coordinate system\n        let screenCoordinates = this.vertices[i]; // Transform the local coordinate system point to the world coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates); // Transform this point to the cameras local coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates); // Compute the coordinates from camera space onto the canvas by using perspective projection\n        // px = x/(-z), py = y/(-z)\n\n        let px = screenCoordinates[0] / -screenCoordinates[2];\n        let py = screenCoordinates[1] / -screenCoordinates[2]; // Check if the point is visible in the viewport\n\n        /*\r\n        if (Math.abs(px) > (screenW/2) || Math.abs(py) > (screenH/2)) {\r\n            console.log(\"Not Visible\");\r\n        }\r\n        else {\r\n            console.log(\"Visible\");\r\n        }\r\n        */\n        // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\n\n        let pxNormalized = (px + screenW / 2) / screenW;\n        let pyNormalized = (py + screenH / 2) / screenH; // Covert to pixel coordinates (Raster space)\n\n        let pxRaster = Math.floor(pxNormalized * width);\n        let pyRaster = Math.floor((1 - pyNormalized) * height);\n        if (pxRaster < 0) pxRaster = 0;else if (pxRaster > width) pxRaster = width;\n        if (pyRaster < 0) pyRaster = 0;else if (pyRaster > height) pyRaster = height;\n\n        if (pxRaster < this.borders.xMin) {\n          this.borders.xMin = pxRaster;\n        } else if (pxRaster > this.borders.xMax) {\n          this.borders.xMax = pxRaster;\n        }\n\n        if (pyRaster < this.borders.yMin) {\n          this.borders.yMin = pyRaster;\n        } else if (pyRaster > this.borders.yMax) {\n          this.borders.yMax = pyRaster;\n        }\n      }\n    }\n  }\n\n}\n\nexport default IntersectionField;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\IntersectionField.js"],"names":["Matrix4","IntersectionField","constructor","vertices","borders","xMin","xMax","yMin","yMax","setCanvasSize","w","h","width","height","setCameraView","camera","cameraView","console","log","updateBorders","matrix","screenW","Math","sqrt","screenH","i","length","screenCoordinates","multiplyVector","transform","px","py","pxNormalized","pyNormalized","pxRaster","floor","pyRaster"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,gBAApB;;AAEA,MAAMC,iBAAN,CAAwB;AACpBC,EAAAA,WAAW,CAACC,QAAD,EAAW;AAClB,SAAKA,QAAL,GAAgBA,QAAhB;AACA,SAAKC,OAAL,GAAe;AACXC,MAAAA,IAAI,EAAE,CADK;AAEXC,MAAAA,IAAI,EAAE,CAFK;AAGXC,MAAAA,IAAI,EAAE,CAHK;AAIXC,MAAAA,IAAI,EAAE;AAJK,KAAf;AAMH;;AAED,SAAOC,aAAP,CAAsBC,CAAtB,EAAyBC,CAAzB,EAA4B;AACxB,SAAKC,KAAL,GAAaF,CAAb;AACA,SAAKG,MAAL,GAAcF,CAAd;AACH;;AAED,SAAOG,aAAP,CAAsBC,MAAtB,EAA6B;AACzB,SAAKC,UAAL,GAAkBD,MAAlB;AACAE,IAAAA,OAAO,CAACC,GAAR,CAAYH,MAAZ;AACH;;AAEDI,EAAAA,aAAa,CAACC,MAAD,EAAS;AAClB,QAAIL,MAAM,GAAGd,iBAAiB,CAACe,UAA/B;AACA,QAAIJ,KAAK,GAAGX,iBAAiB,CAACW,KAA9B;AACA,QAAIC,MAAM,GAAGZ,iBAAiB,CAACY,MAA/B;;AAEA,QAAIE,MAAJ,EAAY;AACR,WAAKX,OAAL,CAAaC,IAAb,GAAoBO,KAAK,GAAC,CAA1B;AACA,WAAKR,OAAL,CAAaE,IAAb,GAAoB,CAAC,CAArB;AACA,WAAKF,OAAL,CAAaG,IAAb,GAAoBM,MAAM,GAAC,CAA3B;AACA,WAAKT,OAAL,CAAaI,IAAb,GAAoB,CAAC,CAArB,CAJQ,CAMR;;AACA,UAAIa,OAAO,GAAGT,KAAK,IAAEA,KAAK,GAACU,IAAI,CAACC,IAAL,CAAUX,KAAK,GAACC,MAAhB,CAAR,CAAnB;AACA,UAAIW,OAAO,GAAGX,MAAM,IAAED,KAAK,GAACU,IAAI,CAACC,IAAL,CAAUX,KAAK,GAACC,MAAhB,CAAR,CAApB;;AAEA,WAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtB,QAAL,CAAcuB,MAAlC,EAA0C,EAAED,CAA5C,EAA+C;AAC3C;AACA,YAAIE,iBAAiB,GAAG,KAAKxB,QAAL,CAAcsB,CAAd,CAAxB,CAF2C,CAG3C;;AACAE,QAAAA,iBAAiB,GAAG3B,OAAO,CAAC4B,cAAR,CAAuBR,MAAvB,EAA+BO,iBAA/B,CAApB,CAJ2C,CAK3C;;AACAA,QAAAA,iBAAiB,GAAG3B,OAAO,CAAC4B,cAAR,CAAuBb,MAAM,CAACc,SAAP,CAAiBT,MAAxC,EAAgDO,iBAAhD,CAApB,CAN2C,CAQ3C;AACA;;AACA,YAAIG,EAAE,GAAIH,iBAAiB,CAAC,CAAD,CAAjB,GAAsB,CAACA,iBAAiB,CAAC,CAAD,CAAlD;AACA,YAAII,EAAE,GAAIJ,iBAAiB,CAAC,CAAD,CAAjB,GAAsB,CAACA,iBAAiB,CAAC,CAAD,CAAlD,CAX2C,CAa3C;;AACA;;;;;;;;AASA;;AACA,YAAIK,YAAY,GAAG,CAACF,EAAE,GAAET,OAAO,GAAC,CAAb,IAAmBA,OAAtC;AACA,YAAIY,YAAY,GAAG,CAACF,EAAE,GAAEP,OAAO,GAAC,CAAb,IAAmBA,OAAtC,CAzB2C,CA2B3C;;AACA,YAAIU,QAAQ,GAAGZ,IAAI,CAACa,KAAL,CAAWH,YAAY,GAAGpB,KAA1B,CAAf;AACA,YAAIwB,QAAQ,GAAGd,IAAI,CAACa,KAAL,CAAW,CAAC,IAAEF,YAAH,IAAmBpB,MAA9B,CAAf;AAEA,YAAIqB,QAAQ,GAAG,CAAf,EACIA,QAAQ,GAAG,CAAX,CADJ,KAEK,IAAIA,QAAQ,GAAGtB,KAAf,EACDsB,QAAQ,GAAGtB,KAAX;AACJ,YAAIwB,QAAQ,GAAG,CAAf,EACIA,QAAQ,GAAG,CAAX,CADJ,KAEK,IAAIA,QAAQ,GAAGvB,MAAf,EACDuB,QAAQ,GAAGvB,MAAX;;AAEJ,YAAIqB,QAAQ,GAAG,KAAK9B,OAAL,CAAaC,IAA5B,EAAkC;AAC9B,eAAKD,OAAL,CAAaC,IAAb,GAAoB6B,QAApB;AACH,SAFD,MAGK,IAAIA,QAAQ,GAAG,KAAK9B,OAAL,CAAaE,IAA5B,EAAkC;AACnC,eAAKF,OAAL,CAAaE,IAAb,GAAoB4B,QAApB;AACH;;AAED,YAAIE,QAAQ,GAAG,KAAKhC,OAAL,CAAaG,IAA5B,EAAkC;AAC9B,eAAKH,OAAL,CAAaG,IAAb,GAAoB6B,QAApB;AACH,SAFD,MAGK,IAAIA,QAAQ,GAAG,KAAKhC,OAAL,CAAaI,IAA5B,EAAkC;AACnC,eAAKJ,OAAL,CAAaI,IAAb,GAAoB4B,QAApB;AACH;AACJ;AACJ;AACJ;;AA3FmB;;AA8FxB,eAAenC,iBAAf","sourcesContent":["import Matrix4 from './math/Matrix4';\r\n\r\nclass IntersectionField {\r\n    constructor(vertices) {\r\n        this.vertices = vertices;\r\n        this.borders = {\r\n            xMin: 0,\r\n            xMax: 0,\r\n            yMin: 0,\r\n            yMax: 0\r\n        };\r\n    }\r\n\r\n    static setCanvasSize (w, h) {\r\n        this.width = w;\r\n        this.height = h;\r\n    }\r\n\r\n    static setCameraView (camera){\r\n        this.cameraView = camera;\r\n        console.log(camera);\r\n    }\r\n\r\n    updateBorders(matrix) {\r\n        let camera = IntersectionField.cameraView;\r\n        let width = IntersectionField.width;\r\n        let height = IntersectionField.height;\r\n\r\n        if (camera) {\r\n            this.borders.xMin = width+1;\r\n            this.borders.xMax = -1;\r\n            this.borders.yMin = height+1;\r\n            this.borders.yMax = -1;\r\n\r\n            // Set the width and height of the viewport\r\n            let screenW = width/(width*Math.sqrt(width/height));\r\n            let screenH = height/(width*Math.sqrt(width/height));\r\n\r\n            for (let i = 0; i < this.vertices.length; ++i) {\r\n                // Take one point from a local coordinate system\r\n                let screenCoordinates = this.vertices[i];\r\n                // Transform the local coordinate system point to the world coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates);\r\n                // Transform this point to the cameras local coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates);\r\n\r\n                // Compute the coordinates from camera space onto the canvas by using perspective projection\r\n                // px = x/(-z), py = y/(-z)\r\n                let px = (screenCoordinates[0]/(-screenCoordinates[2]));\r\n                let py = (screenCoordinates[1]/(-screenCoordinates[2]));\r\n\r\n                // Check if the point is visible in the viewport\r\n                /*\r\n                if (Math.abs(px) > (screenW/2) || Math.abs(py) > (screenH/2)) {\r\n                    console.log(\"Not Visible\");\r\n                }\r\n                else {\r\n                    console.log(\"Visible\");\r\n                }\r\n                */\r\n\r\n                // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\r\n                let pxNormalized = (px+(screenW/2)) / screenW;\r\n                let pyNormalized = (py+(screenH/2)) / screenH;\r\n\r\n                // Covert to pixel coordinates (Raster space)\r\n                let pxRaster = Math.floor(pxNormalized * width);\r\n                let pyRaster = Math.floor((1-pyNormalized) * height);\r\n\r\n                if (pxRaster < 0)\r\n                    pxRaster = 0;\r\n                else if (pxRaster > width)\r\n                    pxRaster = width;\r\n                if (pyRaster < 0)\r\n                    pyRaster = 0;\r\n                else if (pyRaster > height)\r\n                    pyRaster = height;\r\n\r\n                if (pxRaster < this.borders.xMin) {\r\n                    this.borders.xMin = pxRaster;\r\n                }\r\n                else if (pxRaster > this.borders.xMax) {\r\n                    this.borders.xMax = pxRaster;\r\n                }\r\n\r\n                if (pyRaster < this.borders.yMin) {\r\n                    this.borders.yMin = pyRaster;\r\n                }\r\n                else if (pyRaster > this.borders.yMax) {\r\n                    this.borders.yMax = pyRaster;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default IntersectionField;"]},"metadata":{},"sourceType":"module"}