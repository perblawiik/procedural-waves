{"ast":null,"code":"import Matrix4 from './math/Matrix4';\n\nclass IntersectionField {\n  constructor() {\n    this.vertices = [// V0\n    [-1.0, -1.0, -1.0, 1.0], // V1\n    [-1.0, -1.0, 1.0, 1.0], // V2\n    [1.0, -1.0, 1.0, 1.0], // V3\n    [1.0, -1.0, -1.0, 1.0], // V4\n    [-1.0, 1.0, -1.0, 1.0], // V5\n    [-1.0, 1.0, 1.0, 1.0], // V6\n    [1.0, 1.0, 1.0, 1.0], // V7\n    [1.0, 1.0, -1.0, 1.0]];\n    this.borders = {\n      xMin: 0,\n      xMax: 0,\n      yMin: 0,\n      yMax: 0\n    };\n  }\n\n  updateBorders(camera, matrix, width, height) {\n    if (camera) {\n      this.borders.xMin = width + 1;\n      this.borders.xMax = -1;\n      this.borders.yMin = height + 1;\n      this.borders.yMax = -1; // Set the width and height of the viewport\n\n      let screenW = width / (width * Math.sqrt(width / height));\n      let screenH = height / (width * Math.sqrt(width / height));\n\n      for (let i = 0; i < this.vertices.length; ++i) {\n        // Take one point from a local coordinate system\n        let screenCoordinates = this.vertices[i]; // Transform the local coordinate system point to the world coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates); // Transform this point to the cameras local coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates); // Compute the coordinates from camera space onto the canvas by using perspective projection\n        // px = x/(-z), py = y/(-z)\n\n        let px = screenCoordinates[0] / -screenCoordinates[2];\n        let py = screenCoordinates[1] / -screenCoordinates[2]; // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\n\n        let pxNormalized = (px + screenW / 2) / screenW;\n        let pyNormalized = (py + screenH / 2) / screenH; // Covert to pixel coordinates (Raster space)\n\n        let pxRaster = Math.floor(pxNormalized * width);\n        let pyRaster = Math.floor((1 - pyNormalized) * height);\n        if (pxRaster < 0) pxRaster = 0;else if (pxRaster > width) pxRaster = width;\n        if (pyRaster < 0) pyRaster = 0;else if (pyRaster > height) pyRaster = height;\n\n        if (pxRaster < this.borders.xMin) {\n          this.borders.xMin = pxRaster;\n        } else if (pxRaster > this.borders.xMax) {\n          this.borders.xMax = pxRaster;\n        }\n\n        if (pyRaster < this.borders.yMin) {\n          this.borders.yMin = pyRaster;\n        } else if (pyRaster > this.borders.yMax) {\n          this.borders.yMax = pyRaster;\n        }\n      }\n    }\n  }\n\n}\n\nexport default IntersectionField;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\IntersectionField.js"],"names":["Matrix4","IntersectionField","constructor","vertices","borders","xMin","xMax","yMin","yMax","updateBorders","camera","matrix","width","height","screenW","Math","sqrt","screenH","i","length","screenCoordinates","multiplyVector","transform","px","py","pxNormalized","pyNormalized","pxRaster","floor","pyRaster"],"mappings":"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","sourcesContent":["import Matrix4 from './math/Matrix4';\r\n\r\nclass IntersectionField {\r\n    constructor() {\r\n        this.vertices = [\r\n            // V0\r\n            [-1.0, -1.0, -1.0, 1.0],\r\n            // V1\r\n            [-1.0, -1.0, 1.0, 1.0],\r\n            // V2\r\n            [1.0, -1.0, 1.0, 1.0],\r\n            // V3\r\n            [1.0, -1.0, -1.0, 1.0],\r\n            // V4\r\n            [-1.0, 1.0, -1.0, 1.0],\r\n            // V5\r\n            [-1.0, 1.0, 1.0, 1.0],\r\n            // V6\r\n            [1.0, 1.0, 1.0, 1.0],\r\n            // V7\r\n            [1.0, 1.0, -1.0, 1.0]\r\n        ];\r\n\r\n        this.borders = {\r\n            xMin: 0,\r\n            xMax: 0,\r\n            yMin: 0,\r\n            yMax: 0\r\n        };\r\n    }\r\n\r\n    updateBorders(camera, matrix, width, height) {\r\n        if (camera) {\r\n            this.borders.xMin = width+1;\r\n            this.borders.xMax = -1;\r\n            this.borders.yMin = height+1;\r\n            this.borders.yMax = -1;\r\n\r\n            // Set the width and height of the viewport\r\n            let screenW = width/(width*Math.sqrt(width/height));\r\n            let screenH = height/(width*Math.sqrt(width/height));\r\n\r\n            for (let i = 0; i < this.vertices.length; ++i) {\r\n                // Take one point from a local coordinate system\r\n                let screenCoordinates = this.vertices[i];\r\n                // Transform the local coordinate system point to the world coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates);\r\n                // Transform this point to the cameras local coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates);\r\n\r\n                // Compute the coordinates from camera space onto the canvas by using perspective projection\r\n                // px = x/(-z), py = y/(-z)\r\n                let px = (screenCoordinates[0]/(-screenCoordinates[2]));\r\n                let py = (screenCoordinates[1]/(-screenCoordinates[2]));\r\n\r\n                // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\r\n                let pxNormalized = (px+(screenW/2)) / screenW;\r\n                let pyNormalized = (py+(screenH/2)) / screenH;\r\n\r\n                // Covert to pixel coordinates (Raster space)\r\n                let pxRaster = Math.floor(pxNormalized * width);\r\n                let pyRaster = Math.floor((1-pyNormalized) * height);\r\n\r\n                if (pxRaster < 0)\r\n                    pxRaster = 0;\r\n                else if (pxRaster > width)\r\n                    pxRaster = width;\r\n                if (pyRaster < 0)\r\n                    pyRaster = 0;\r\n                else if (pyRaster > height)\r\n                    pyRaster = height;\r\n\r\n                if (pxRaster < this.borders.xMin) {\r\n                    this.borders.xMin = pxRaster;\r\n                }\r\n                else if (pxRaster > this.borders.xMax) {\r\n                    this.borders.xMax = pxRaster;\r\n                }\r\n\r\n                if (pyRaster < this.borders.yMin) {\r\n                    this.borders.yMin = pyRaster;\r\n                }\r\n                else if (pyRaster > this.borders.yMax) {\r\n                    this.borders.yMax = pyRaster;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default IntersectionField;"]},"metadata":{},"sourceType":"module"}