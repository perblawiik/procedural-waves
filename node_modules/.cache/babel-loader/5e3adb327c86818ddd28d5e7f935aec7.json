{"ast":null,"code":"import Vector3 from \"./math/Vector3\";\nimport Matrix4 from \"./math/Matrix4\";\n\nclass Raycast {\n  static init() {\n    this.intersectableObjects = [];\n  }\n\n  static raycastFromMouseCursor(mouseX, mouseY, cameraTransform, projectionMatrix, canvasWidth, canvasHeight) {\n    // Transform from mouse cursor's viewport coordinates from [0 : width/height] to the range [-1.0 : 1.0]\n    let xNorm = mouseX / (canvasWidth * 0.5) - 1.0;\n    let yNorm = 1.0 - mouseY / (canvasHeight * 0.5); // Reverse the Y-axis\n    // Combine the transform matrix for perspective and camera view\n\n    let transform = Matrix4.multiply(projectionMatrix, cameraTransform.matrix); // Invert the transform matrix since we are reversing the process (from normalized device coordinates to world coordinates)\n\n    Matrix4.invert(transform, transform); // Transform screen coordinates to world coordinates\n\n    let ndc = [xNorm, yNorm, 1.0, 1.0];\n    let worldCoordinates = Matrix4.multiplyVector(transform, ndc); // Normalize the world coordinates to finish the ray direction vector\n\n    const rayDirection = new Vector3([worldCoordinates[0], worldCoordinates[1], worldCoordinates[2]]).normalized();\n    const rayOrigin = cameraTransform.position.clone();\n    return {\n      direction: rayDirection,\n      origin: rayOrigin\n    };\n  }\n\n  static findObjectIntersection(ray) {\n    let objectFound = null;\n    let t = -1;\n    this.intersectableObjects.forEach(object => {\n      t = this.sphereIntersectionTest(ray, object.collider);\n\n      if (t > 0) {\n        objectFound = object;\n        console.log(\"yippie\");\n      }\n    });\n    return objectFound;\n  }\n\n  static sphereIntersectionTest(ray, sphere) {\n    let rayToSphere = Vector3.subtract(sphere.worldPosition, ray.origin);\n    let tca = Vector3.dot(rayToSphere, ray.direction); // If tca is negative, the ray is facing the opposite direction of the sphere collider\n\n    if (tca < 0.0) {\n      return -1;\n    }\n\n    let shortestFromRayToCenter = Math.sqrt(Vector3.dot(rayToSphere, rayToSphere) - tca * tca); // If this distance is greater than the sphere radius the ray has missed the sphere\n\n    if (shortestFromRayToCenter > sphere.radius) {\n      return -1;\n    }\n\n    let thc = Math.sqrt(sphere.radius * sphere.radius - shortestFromRayToCenter * shortestFromRayToCenter);\n    let intersectionDistancePoint1 = tca - thc;\n    let intersectionDistancePoint2 = tca + thc;\n    console.log(\"Sphere intersection hit\"); // Return the closest intersection of the two possible intersections\n\n    return intersectionDistancePoint1 < intersectionDistancePoint2 ? intersectionDistancePoint1 : intersectionDistancePoint2;\n  }\n\n  static planeIntersectionTest(ray, plane) {\n    // Compute distance from ray origin and intersection point\n    let intersectionPointDist = -(Vector3.dot(ray.origin, plane.normal) + plane.offset) / Vector3.dot(ray.direction, plane.normal);\n\n    if (intersectionPointDist < 0) {\n      console.log(\"Plane intersection missed\");\n      return false;\n    } //console.log(\"Intersection point distance: \" + intersectionPointDist);\n\n\n    let intersectionPoint = new Vector3([ray.origin.x + ray.direction.x * intersectionPointDist, ray.origin.y + ray.direction.y * intersectionPointDist, ray.origin.z + ray.direction.z * intersectionPointDist]); //console.log(\"Intersection point: \" + intersectionPoint.x.toFixed(2) + \", \" + intersectionPoint.y.toFixed(2) + \", \" + intersectionPoint.z.toFixed(2));\n\n    return true;\n  }\n\n  static addIntersectableObject(gameObject) {\n    this.intersectableObjects.push(gameObject);\n  }\n\n}\n\nexport default Raycast;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Raycast.js"],"names":["Vector3","Matrix4","Raycast","init","intersectableObjects","raycastFromMouseCursor","mouseX","mouseY","cameraTransform","projectionMatrix","canvasWidth","canvasHeight","xNorm","yNorm","transform","multiply","matrix","invert","ndc","worldCoordinates","multiplyVector","rayDirection","normalized","rayOrigin","position","clone","direction","origin","findObjectIntersection","ray","objectFound","t","forEach","object","sphereIntersectionTest","collider","console","log","sphere","rayToSphere","subtract","worldPosition","tca","dot","shortestFromRayToCenter","Math","sqrt","radius","thc","intersectionDistancePoint1","intersectionDistancePoint2","planeIntersectionTest","plane","intersectionPointDist","normal","offset","intersectionPoint","x","y","z","addIntersectableObject","gameObject","push"],"mappings":"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","sourcesContent":["import Vector3 from \"./math/Vector3\";\r\nimport Matrix4 from \"./math/Matrix4\";\r\n\r\nclass Raycast {\r\n    static init() {\r\n        this.intersectableObjects = [];\r\n    }\r\n\r\n    static raycastFromMouseCursor(mouseX, mouseY, cameraTransform, projectionMatrix, canvasWidth, canvasHeight) {\r\n        // Transform from mouse cursor's viewport coordinates from [0 : width/height] to the range [-1.0 : 1.0]\r\n        let xNorm = (mouseX / (canvasWidth  * 0.5)) - 1.0;\r\n        let yNorm = 1.0 - (mouseY / (canvasHeight * 0.5)); // Reverse the Y-axis\r\n\r\n        // Combine the transform matrix for perspective and camera view\r\n        let transform = Matrix4.multiply(projectionMatrix, cameraTransform.matrix);\r\n        // Invert the transform matrix since we are reversing the process (from normalized device coordinates to world coordinates)\r\n        Matrix4.invert(transform, transform);\r\n\r\n        // Transform screen coordinates to world coordinates\r\n        let ndc = [xNorm, yNorm, 1.0, 1.0];\r\n        let worldCoordinates = Matrix4.multiplyVector(transform, ndc);\r\n\r\n        // Normalize the world coordinates to finish the ray direction vector\r\n        const rayDirection = (new Vector3([worldCoordinates[0], worldCoordinates[1], worldCoordinates[2]])).normalized();\r\n        const rayOrigin = cameraTransform.position.clone();\r\n\r\n        return {\r\n            direction: rayDirection,\r\n            origin: rayOrigin\r\n        };\r\n    }\r\n\r\n    static findObjectIntersection(ray) {\r\n        let objectFound = null;\r\n\r\n        let t = -1;\r\n        this.intersectableObjects.forEach((object) => {\r\n            t = this.sphereIntersectionTest(ray, object.collider);\r\n            if (t > 0) {\r\n                objectFound = object;\r\n                console.log(\"yippie\");\r\n            }\r\n\r\n        });\r\n\r\n        return objectFound;\r\n    }\r\n\r\n    static sphereIntersectionTest(ray, sphere) {\r\n        let rayToSphere = Vector3.subtract(sphere.worldPosition, ray.origin);\r\n        let tca = Vector3.dot(rayToSphere, ray.direction);\r\n\r\n        // If tca is negative, the ray is facing the opposite direction of the sphere collider\r\n        if (tca < 0.0) {\r\n            return -1;\r\n        }\r\n\r\n        let shortestFromRayToCenter = Math.sqrt(Vector3.dot(rayToSphere, rayToSphere) - tca*tca);\r\n\r\n        // If this distance is greater than the sphere radius the ray has missed the sphere\r\n        if (shortestFromRayToCenter > sphere.radius) {\r\n            return -1;\r\n        }\r\n\r\n        let thc = Math.sqrt(sphere.radius*sphere.radius - shortestFromRayToCenter*shortestFromRayToCenter);\r\n        let intersectionDistancePoint1 = tca - thc;\r\n        let intersectionDistancePoint2 = tca + thc;\r\n\r\n        console.log(\"Sphere intersection hit\");\r\n        // Return the closest intersection of the two possible intersections\r\n        return (intersectionDistancePoint1 < intersectionDistancePoint2) ? intersectionDistancePoint1 : intersectionDistancePoint2;\r\n    }\r\n\r\n    static planeIntersectionTest(ray, plane) {\r\n        // Compute distance from ray origin and intersection point\r\n        let intersectionPointDist = -(Vector3.dot(ray.origin, plane.normal) + plane.offset) / Vector3.dot(ray.direction, plane.normal);\r\n\r\n        if (intersectionPointDist < 0) {\r\n            console.log(\"Plane intersection missed\");\r\n            return false;\r\n        }\r\n\r\n        //console.log(\"Intersection point distance: \" + intersectionPointDist);\r\n\r\n        let intersectionPoint = new Vector3([\r\n            ray.origin.x + ray.direction.x*intersectionPointDist,\r\n            ray.origin.y + ray.direction.y*intersectionPointDist,\r\n            ray.origin.z + ray.direction.z*intersectionPointDist,\r\n        ]);\r\n\r\n        //console.log(\"Intersection point: \" + intersectionPoint.x.toFixed(2) + \", \" + intersectionPoint.y.toFixed(2) + \", \" + intersectionPoint.z.toFixed(2));\r\n        return true;\r\n    }\r\n\r\n    static addIntersectableObject(gameObject) {\r\n        this.intersectableObjects.push(gameObject);\r\n    }\r\n}\r\n\r\nexport default Raycast;"]},"metadata":{},"sourceType":"module"}