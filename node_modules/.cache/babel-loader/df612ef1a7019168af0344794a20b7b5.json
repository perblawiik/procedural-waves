{"ast":null,"code":"import Transform from './Transform';\n\nclass Mesh {\n  constructor(shader) {\n    this.shader = shader;\n    this.gl = shader.gl;\n    this.positionAttributeLocation = shader.positionAttributeLocation;\n    this.normalAttributeLocation = shader.normalAttributeLocation;\n    this.textureAttributeLocation = shader.textureAttributeLocation;\n    this.colorUniformLocation = shader.colorUniformLocation;\n    this.matrixUniformLocation = shader.worldViewUniformLocation;\n    this.timeUniformLocation = shader.timeUniformLocation;\n    this.totalVertices = 0;\n    this.color = [0.5, 0.5, 0.5];\n    this.shape = null;\n    this.time = 0;\n    this.transform = new Transform();\n  }\n\n  clone() {\n    let clone = new Mesh(this.shader);\n    if (this.shape === 'cube') clone.createCube();else if (this.shape === 'sphere') clone.createSphere(64);\n    clone.setColor(this.color);\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  setPosition(pos) {\n    this.transform.setPosition(pos);\n  }\n\n  setScale(scale) {\n    this.transform.setScale(scale);\n  }\n\n  setRotation(rot) {\n    this.transform.setRotation(rot);\n  }\n\n  render(time) {\n    if (this.shape) {\n      this.time = time;\n      this.updateUniforms();\n      this.bindBuffersAndEnableAttributes(); // Draw our graphics\n      // Param 1 specifies how to draw from vertices,\n      // param 2 is how many vertices we use to draw\n      // param 3 is what type the elements are\n      // param 4 is the starting point from the array\n\n      this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\n      this.unbindBuffers();\n    } else {\n      console.log(\"ERROR! The mesh got no shape!\");\n    }\n  }\n\n  updateUniforms() {\n    this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\n    this.gl.uniform3fv(this.colorUniformLocation, this.color);\n    this.gl.uniform1f(this.timeUniformLocation, this.time);\n  }\n\n  unbindBuffers() {\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  bindBuffersAndEnableAttributes() {\n    // Vertex buffer\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); // Enable vertex attribute\n\n    this.gl.vertexAttribPointer(this.positionAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.FALSE, // Don't normalize the data\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\n    0 // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.positionAttributeLocation); // Enable normal attribute\n\n    this.gl.vertexAttribPointer(this.normalAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.TRUE, // Not normalized\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\n    3 * Float32Array.BYTES_PER_ELEMENT // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.normalAttributeLocation); // Index buffer\n\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  }\n\n  createCylinder(vertSeg, horizSeg) {\n    this.shape = 'cylinder';\n    let horizontalSegments = horizSeg;\n    let verticalSegments = vertSeg;\n\n    if (horizontalSegments < 1) {\n      horizontalSegments = 1;\n    }\n\n    if (verticalSegments < 4) {\n      verticalSegments = 4;\n    }\n\n    let vertices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.0;\n    vertices[7] = 0.0; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -Math.PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0;\n    let index = 7; // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = -1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0; // Generate middle part vertices with normals\n\n    for (let i = 0; i <= horizontalSegments; ++i) {\n      let y = Math.cos(theta);\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += 2 * Math.PI / verticalSegments;\n      }\n\n      theta += Math.PI / horizontalSegments;\n    }\n\n    phi = 0; // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = 1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = verticalSegments + 2;\n\n    for (let i = 0; i < horizontalSegments; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top circle plane\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    this.totalVertices = indices.length; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  CreateSphere(segments) {\n    this.shape = 'sphere';\n    let horizontalSegments = segments;\n\n    if (horizontalSegments < 2) {\n      horizontalSegments = 2;\n    }\n\n    let verticalSegments = 2 * horizontalSegments;\n    let vertices = []; // Bottom vertex and its normal (x, y, z)\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0;\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0;\n    vertices[6] = 0.0;\n    vertices[7] = 0.0;\n    let sampleResolution = Math.PI / horizontalSegments;\n    let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n    // Generate middle part vertices with normals\n\n    let index = 7;\n\n    for (let i = 0; i < horizontalSegments - 1; ++i) {\n      let y = Math.cos(theta);\n      let R = Math.sin(theta); // radius\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += sampleResolution;\n      }\n\n      theta += sampleResolution;\n    } // Top vertex and its normal (x, y, z)\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom cap\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = 1;\n\n    for (let i = 0; i < horizontalSegments - 2; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top cap\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    this.totalVertices = indices.length; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  CreateCube() {\n    this.shape = 'cube';\n    let x = 1.0;\n    let y = 1.0;\n    let z = 1.0; // Vertex coordinates, normals and texture coordinates\n\n    let vertexArray = [// Vertex         Normal             Texture coordinates\n    // Vertex 0\n    -x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, // Vertex 1\n    -x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, -y, z, -1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 2\n    x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, -y, z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 3\n    x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, -y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 4\n    -x, y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, -x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 5\n    -x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, y, z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 6\n    x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, y, z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 7\n    x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0]; // Vertex indices\n\n    let indexArray = [// Bottom\n    0, 9, 6, // v0, v3, v2\n    6, 3, 0, // v2, v1, v0\n    // Front\n    4, 7, 18, // v1, v2, v6\n    18, 15, 4, // v6, v5, v1\n    // Left\n    1, 5, 16, // v0, v1, v5\n    16, 12, 1, // v5, v4, v0\n    // Back\n    2, 13, 21, // v0, v4, v7\n    21, 10, 2, // v7, v3, v0\n    // Right\n    8, 11, 22, // v2, v3, v7\n    22, 19, 8, // v7, v6, v2\n    // Top\n    14, 17, 20, // v4, v5, v6\n    20, 23, 14 // v6, v7, v4\n    ];\n    let totalTriangles = 12;\n    this.totalVertices = totalTriangles * 3; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  CreatePlane(rows, columns) {\n    this.shape = 'plane';\n    let index = 0;\n    let x = 0;\n    let vertexArray = []; // Generate and store coordinates in vertex array\n\n    for (let i = 0; i <= columns; ++i) {\n      x = -(rows / 2);\n\n      for (let k = 0; k <= rows; ++k) {\n        // Storing one vertex at the time (x,y,z)\n        vertexArray[index] = x;\n        vertexArray[index + 1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\n\n        vertexArray[index + 2] = -i; // Set normals\n\n        vertexArray[index + 3] = 0.0;\n        vertexArray[index + 4] = 1.0;\n        vertexArray[index + 5] = 0.0; // Texture coordinates\n\n        vertexArray[index + 6] = 0.0;\n        vertexArray[index + 7] = 0.0; // We go from left to right in the direction of x-axis\n\n        ++x; // Increase by three since we store values in three indices at the time\n\n        index += 8;\n      }\n    } // v0-v3 represent the four vertices in one quad\n\n\n    let v0 = 0;\n    let v1 = 1;\n    let v2 = rows + 2;\n    let v3 = rows + 1;\n    index = 0;\n    let indexArray = []; // Store indices in index array\n\n    for (let j = 0; j < columns; ++j) {\n      // Each iteration generates the order of vertex indices for one full quad\n      for (let l = 0; l < rows; ++l) {\n        // Triangle 1\n        indexArray[index] = v0;\n        indexArray[index + 1] = v1;\n        indexArray[index + 2] = v2; // Triangle 2\n\n        indexArray[index + 3] = v2;\n        indexArray[index + 4] = v3;\n        indexArray[index + 5] = v0; // Increase for next quad\n\n        ++v0;\n        ++v1;\n        ++v2;\n        ++v3;\n        index += 6;\n      } // Increase one more time after a full row of quads\n\n\n      ++v0;\n      ++v1;\n      ++v2;\n      ++v3;\n    } //this.totalTriangles = rows*columns*2;\n    //this.totalVertices = this.totalTriangles*3;\n\n\n    this.totalVertices = indexArray.length; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n}\n\nexport default Mesh;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Mesh.js"],"names":["Transform","Mesh","constructor","shader","gl","positionAttributeLocation","normalAttributeLocation","textureAttributeLocation","colorUniformLocation","matrixUniformLocation","worldViewUniformLocation","timeUniformLocation","totalVertices","color","shape","time","transform","clone","createCube","createSphere","setColor","setPosition","pos","setScale","scale","setRotation","rot","render","updateUniforms","bindBuffersAndEnableAttributes","drawElements","TRIANGLES","UNSIGNED_SHORT","unbindBuffers","console","log","uniformMatrix4fv","FALSE","matrix","uniform3fv","uniform1f","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","vertexBuffer","vertexAttribPointer","FLOAT","Float32Array","BYTES_PER_ELEMENT","enableVertexAttribArray","TRUE","indexBuffer","createCylinder","vertSeg","horizSeg","horizontalSegments","verticalSegments","vertices","theta","Math","PI","phi","index","j","sin","cos","i","y","indices","v0","lastVertexIndex","length","createBuffer","bufferData","STATIC_DRAW","Uint16Array","CreateSphere","segments","sampleResolution","R","CreateCube","x","z","vertexArray","indexArray","totalTriangles","CreatePlane","rows","columns","k","v1","v2","v3","l"],"mappings":"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","sourcesContent":["\r\nimport Transform from './Transform';\r\n\r\nclass Mesh {\r\n\r\n    constructor(shader) {\r\n\r\n        this.shader = shader;\r\n        this.gl = shader.gl;\r\n        this.positionAttributeLocation = shader.positionAttributeLocation;\r\n        this.normalAttributeLocation = shader.normalAttributeLocation;\r\n        this.textureAttributeLocation = shader.textureAttributeLocation;\r\n        this.colorUniformLocation = shader.colorUniformLocation;\r\n        this.matrixUniformLocation = shader.worldViewUniformLocation;\r\n        this.timeUniformLocation = shader.timeUniformLocation;\r\n\r\n        this.totalVertices = 0;\r\n\r\n        this.color = [0.5, 0.5, 0.5];\r\n        this.shape = null;\r\n        this.time = 0;\r\n\r\n        this.transform = new Transform();\r\n    }\r\n\r\n    clone() {\r\n        let clone = new Mesh(this.shader);\r\n\r\n        if (this.shape === 'cube')\r\n            clone.createCube();\r\n        else if (this.shape === 'sphere')\r\n            clone.createSphere(64);\r\n\r\n        clone.setColor(this.color);\r\n        clone.transform = this.transform.clone();\r\n        return clone;\r\n    }\r\n\r\n    setColor(color) {\r\n\r\n        this.color = color;\r\n    }\r\n\r\n    setPosition(pos) {\r\n\r\n        this.transform.setPosition(pos);\r\n    }\r\n\r\n    setScale (scale) {\r\n        this.transform.setScale(scale);\r\n    }\r\n\r\n    setRotation (rot) {\r\n        this.transform.setRotation(rot);\r\n    }\r\n\r\n    render(time) {\r\n\r\n        if (this.shape) {\r\n            this.time = time;\r\n            this.updateUniforms();\r\n            this.bindBuffersAndEnableAttributes();\r\n            // Draw our graphics\r\n            // Param 1 specifies how to draw from vertices,\r\n            // param 2 is how many vertices we use to draw\r\n            // param 3 is what type the elements are\r\n            // param 4 is the starting point from the array\r\n            this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\r\n            this.unbindBuffers();\r\n        }\r\n        else {\r\n            console.log(\"ERROR! The mesh got no shape!\");\r\n        }\r\n    }\r\n\r\n    updateUniforms() {\r\n\r\n        this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\r\n        this.gl.uniform3fv(this.colorUniformLocation, this.color);\r\n        this.gl.uniform1f(this.timeUniformLocation, this.time);\r\n    }\r\n\r\n    unbindBuffers() {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    bindBuffersAndEnableAttributes() {\r\n\r\n        // Vertex buffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n\r\n        // Enable vertex attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.positionAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.FALSE, // Don't normalize the data\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\r\n            0// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.positionAttributeLocation);\r\n\r\n        // Enable normal attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.normalAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.TRUE, // Not normalized\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\r\n            3 * Float32Array.BYTES_PER_ELEMENT// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.normalAttributeLocation);\r\n\r\n        // Index buffer\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n    }\r\n\r\n    createCylinder (vertSeg, horizSeg) {\r\n\r\n        this.shape = 'cylinder';\r\n\r\n        let horizontalSegments = horizSeg;\r\n        let verticalSegments = vertSeg;\r\n\r\n        if (horizontalSegments < 1) {\r\n            horizontalSegments = 1;\r\n        }\r\n        if (verticalSegments < 4) {\r\n            verticalSegments = 4;\r\n        }\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -Math.PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0;\r\n\r\n        let index = 7;\r\n        // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0;\r\n        // Generate middle part vertices with normals\r\n        for(let i = 0; i <= horizontalSegments; ++i) {\r\n\r\n            let y = Math.cos(theta);\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += (2*Math.PI)/verticalSegments;\r\n            }\r\n            theta += Math.PI/horizontalSegments;\r\n        }\r\n\r\n        phi = 0;\r\n        // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = verticalSegments+2;\r\n        for(let i = 0; i < horizontalSegments; i++) {\r\n\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n\r\n        // Top circle plane\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        this.totalVertices = indices.length;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    CreateSphere (segments) {\r\n\r\n        this.shape = 'sphere';\r\n\r\n        let horizontalSegments = segments;\r\n\r\n        if (horizontalSegments < 2) {\r\n            horizontalSegments = 2;\r\n        }\r\n        let verticalSegments = 2*horizontalSegments;\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom vertex and its normal (x, y, z)\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        let sampleResolution = Math.PI/horizontalSegments;\r\n        let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = 7;\r\n        for(let i = 0; i < horizontalSegments-1; ++i) {\r\n\r\n            let y = Math.cos(theta);\r\n            let R = Math.sin(theta); // radius\r\n\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += sampleResolution;\r\n            }\r\n            theta += sampleResolution;\r\n        }\r\n\r\n        // Top vertex and its normal (x, y, z)\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom cap\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for(let i = 0; i < horizontalSegments-2; i++) {\r\n\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n\r\n        // Top cap\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        this.totalVertices = indices.length;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    CreateCube() {\r\n\r\n        this.shape = 'cube';\r\n\r\n        let x = 1.0;\r\n        let y = 1.0;\r\n        let z = 1.0;\r\n\r\n        // Vertex coordinates, normals and texture coordinates\r\n        let vertexArray = [\r\n            // Vertex         Normal             Texture coordinates\r\n            // Vertex 0\r\n            -x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n\r\n            // Vertex 1\r\n            -x, -y,  z,     0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y,  z,     0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, -y,  z,    -1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 2\r\n            x, -y,  z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y,  z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, -y,  z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 3\r\n            x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, -y, -z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 4\r\n            -x, y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 5\r\n            -x, y, z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, y, z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 6\r\n            x, y, z,       0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, y, z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, z,       0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 7\r\n            x, y, -z,       0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, y, -z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, -z,       0.0,  1.0,  0.0,      0.0, 0.0\r\n        ];\r\n\r\n        // Vertex indices\r\n        let indexArray = [\t// Bottom\r\n            0, 9, 6,  // v0, v3, v2\r\n            6, 3, 0,  // v2, v1, v0\r\n\r\n            // Front\r\n            4, 7, 18,  // v1, v2, v6\r\n            18, 15, 4, // v6, v5, v1\r\n\r\n            // Left\r\n            1, 5, 16,  // v0, v1, v5\r\n            16, 12, 1, // v5, v4, v0\r\n\r\n            // Back\r\n            2, 13, 21, // v0, v4, v7\r\n            21, 10, 2, // v7, v3, v0\r\n\r\n            // Right\r\n            8, 11, 22, // v2, v3, v7\r\n            22, 19, 8, // v7, v6, v2\r\n\r\n            // Top\r\n            14, 17, 20, // v4, v5, v6\r\n            20, 23, 14  // v6, v7, v4\r\n        ];\r\n\r\n        let totalTriangles = 12;\r\n        this.totalVertices = totalTriangles*3;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    CreatePlane (rows, columns) {\r\n\r\n        this.shape = 'plane';\r\n\r\n        let index = 0;\r\n        let x = 0;\r\n        let vertexArray = [];\r\n        // Generate and store coordinates in vertex array\r\n        for (let i = 0; i <= columns; ++i) {\r\n            x = -(rows/2);\r\n            for (let k = 0; k <= rows; ++k) {\r\n                // Storing one vertex at the time (x,y,z)\r\n                vertexArray[index] = x;\r\n                vertexArray[index+1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\r\n                vertexArray[index+2] = -i;\r\n\r\n                // Set normals\r\n                vertexArray[index+3] = 0.0;\r\n                vertexArray[index+4] = 1.0;\r\n                vertexArray[index+5] = 0.0;\r\n\r\n                // Texture coordinates\r\n                vertexArray[index+6] = 0.0;\r\n                vertexArray[index+7] = 0.0;\r\n\r\n                // We go from left to right in the direction of x-axis\r\n                ++x;\r\n                // Increase by three since we store values in three indices at the time\r\n                index += 8;\r\n            }\r\n        }\r\n\r\n        // v0-v3 represent the four vertices in one quad\r\n        let v0 = 0;\r\n        let v1 = 1;\r\n        let v2 = rows+2;\r\n        let v3 = rows+1;\r\n        index = 0;\r\n        let indexArray = [];\r\n        // Store indices in index array\r\n        for (let j = 0; j < columns; ++j) {\r\n            // Each iteration generates the order of vertex indices for one full quad\r\n            for (let l = 0; l < rows; ++l) {\r\n                // Triangle 1\r\n                indexArray[index] = v0;\r\n                indexArray[index + 1] = v1;\r\n                indexArray[index + 2] = v2;\r\n                // Triangle 2\r\n                indexArray[index + 3] = v2;\r\n                indexArray[index + 4] = v3;\r\n                indexArray[index + 5] = v0;\r\n\r\n                // Increase for next quad\r\n                ++v0;\r\n                ++v1;\r\n                ++v2;\r\n                ++v3;\r\n                index += 6;\r\n            }\r\n            // Increase one more time after a full row of quads\r\n            ++v0;\r\n            ++v1;\r\n            ++v2;\r\n            ++v3;\r\n        }\r\n        //this.totalTriangles = rows*columns*2;\r\n        //this.totalVertices = this.totalTriangles*3;\r\n        this.totalVertices = indexArray.length;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    };\r\n}\r\n\r\nexport default Mesh;"]},"metadata":{},"sourceType":"module"}