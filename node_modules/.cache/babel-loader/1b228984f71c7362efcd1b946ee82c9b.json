{"ast":null,"code":"import Matrix4 from './math/Matrix4';\n\nclass IntersectionField {\n  constructor(vertices) {\n    this.vertices = vertices;\n    this.borders = {\n      xMin: 0,\n      xMax: 0,\n      yMin: 0,\n      yMax: 0\n    };\n  }\n\n  updateBorders(camera, matrix, width, height) {\n    if (camera) {\n      this.borders.xMin = width + 1;\n      this.borders.xMax = -1;\n      this.borders.yMin = height + 1;\n      this.borders.yMax = -1; // Set the width and height of the viewport\n\n      let screenW = width / (width * Math.sqrt(width / height));\n      let screenH = height / (width * Math.sqrt(width / height));\n\n      for (let i = 0; i < this.vertices.length; ++i) {\n        // Take one point from a local coordinate system\n        let screenCoordinates = this.vertices[i]; // Transform the local coordinate system point to the world coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates); // Transform this point to the cameras local coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates); // Compute the coordinates from camera space onto the canvas by using perspective projection\n        // px = x/(-z), py = y/(-z)\n\n        let px = screenCoordinates[0] / -screenCoordinates[2];\n        let py = screenCoordinates[1] / -screenCoordinates[2]; // Check if the point is visible in the viewport\n\n        if (Math.abs(px) > screenW / 2 || Math.abs(py) > screenH / 2) {\n          console.log(\"Not Visible\");\n        } else {\n          console.log(\"Visible\");\n        } // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\n\n\n        let pxNormalized = (px + screenW / 2) / screenW;\n        let pyNormalized = (py + screenH / 2) / screenH; // Covert to pixel coordinates (Raster space)\n\n        let pxRaster = Math.floor(pxNormalized * width);\n        let pyRaster = Math.floor((1 - pyNormalized) * height);\n        if (pxRaster < 0) pxRaster = 0;else if (pxRaster > width) pxRaster = width;\n        if (pyRaster < 0) pyRaster = 0;else if (pyRaster > height) pyRaster = height;\n\n        if (pxRaster < this.borders.xMin) {\n          this.borders.xMin = pxRaster;\n        } else if (pxRaster > this.borders.xMax) {\n          this.borders.xMax = pxRaster;\n        }\n\n        if (pyRaster < this.borders.yMin) {\n          this.borders.yMin = pyRaster;\n        } else if (pyRaster > this.borders.yMax) {\n          this.borders.yMax = pyRaster;\n        }\n      }\n    }\n  }\n\n}\n\nexport default IntersectionField;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\IntersectionField.js"],"names":["Matrix4","IntersectionField","constructor","vertices","borders","xMin","xMax","yMin","yMax","updateBorders","camera","matrix","width","height","screenW","Math","sqrt","screenH","i","length","screenCoordinates","multiplyVector","transform","px","py","abs","console","log","pxNormalized","pyNormalized","pxRaster","floor","pyRaster"],"mappings":"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","sourcesContent":["import Matrix4 from './math/Matrix4';\r\n\r\nclass IntersectionField {\r\n    constructor(vertices) {\r\n        this.vertices = vertices;\r\n        this.borders = {\r\n            xMin: 0,\r\n            xMax: 0,\r\n            yMin: 0,\r\n            yMax: 0\r\n        };\r\n    }\r\n\r\n    updateBorders(camera, matrix, width, height) {\r\n        if (camera) {\r\n            this.borders.xMin = width+1;\r\n            this.borders.xMax = -1;\r\n            this.borders.yMin = height+1;\r\n            this.borders.yMax = -1;\r\n\r\n            // Set the width and height of the viewport\r\n            let screenW = width/(width*Math.sqrt(width/height));\r\n            let screenH = height/(width*Math.sqrt(width/height));\r\n\r\n            for (let i = 0; i < this.vertices.length; ++i) {\r\n                // Take one point from a local coordinate system\r\n                let screenCoordinates = this.vertices[i];\r\n                // Transform the local coordinate system point to the world coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates);\r\n                // Transform this point to the cameras local coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates);\r\n\r\n                // Compute the coordinates from camera space onto the canvas by using perspective projection\r\n                // px = x/(-z), py = y/(-z)\r\n                let px = (screenCoordinates[0]/(-screenCoordinates[2]));\r\n                let py = (screenCoordinates[1]/(-screenCoordinates[2]));\r\n\r\n                // Check if the point is visible in the viewport\r\n                if (Math.abs(px) > (screenW/2) || Math.abs(py) > (screenH/2)) {\r\n                    console.log(\"Not Visible\");\r\n                }\r\n                else {\r\n                    console.log(\"Visible\");\r\n                }\r\n                \r\n\r\n                // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\r\n                let pxNormalized = (px+(screenW/2)) / screenW;\r\n                let pyNormalized = (py+(screenH/2)) / screenH;\r\n\r\n                // Covert to pixel coordinates (Raster space)\r\n                let pxRaster = Math.floor(pxNormalized * width);\r\n                let pyRaster = Math.floor((1-pyNormalized) * height);\r\n\r\n                if (pxRaster < 0)\r\n                    pxRaster = 0;\r\n                else if (pxRaster > width)\r\n                    pxRaster = width;\r\n                if (pyRaster < 0)\r\n                    pyRaster = 0;\r\n                else if (pyRaster > height)\r\n                    pyRaster = height;\r\n\r\n                if (pxRaster < this.borders.xMin) {\r\n                    this.borders.xMin = pxRaster;\r\n                }\r\n                else if (pxRaster > this.borders.xMax) {\r\n                    this.borders.xMax = pxRaster;\r\n                }\r\n\r\n                if (pyRaster < this.borders.yMin) {\r\n                    this.borders.yMin = pyRaster;\r\n                }\r\n                else if (pyRaster > this.borders.yMax) {\r\n                    this.borders.yMax = pyRaster;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default IntersectionField;"]},"metadata":{},"sourceType":"module"}