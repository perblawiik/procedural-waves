{"ast":null,"code":"class PhongLightingShader {\n  static get vertex() {\n    return [\"precision highp float;\", \"\", // Attribute locations\n    \"attribute vec3 vertPosition;\", \"attribute vec3 vertNormal;\", \"attribute vec2 vertTexCoord;\", \"\", // Transformation matrices\n    \"uniform mat4 cameraView;\", \"uniform mat4 modelView;\", \"uniform mat4 perspective;\", \"\", /////////////////////////////\n    \"uniform vec3 viewPosition;\", \"uniform vec3 lightPosition;\", // Fragment shader input variables\n    \"varying vec2 TexCoords;\", \"varying vec3 Normal;\", \"varying vec3 FragPosition;\", ///////\n    \"varying vec3 LightDirection;\", \"varying vec3 ReflectDirection;\", \"varying vec3 ViewDirection;\", \"\", \"void main() {\", // Final transformation ( Perspective multiplied with the model view )\n    \"mat4 T = perspective * cameraView * modelView;\", // Transform (x,y,z) vertex coordinates with a 4x4 matrix T\n    \"gl_Position = T * vec4(vertPosition, 1.0);\", \"\", // Fragment shader input variables\n    \"Normal = normalize(mat3(modelView)*vertNormal);\", \"TexCoords = vertTexCoord;\", \"FragPosition = vec3(modelView * vec4(vertPosition, 1.0));\", ////////////////\n    \"LightDirection = normalize(lightPosition - FragPosition);\", \"ReflectDirection = reflect(-LightDirection, Normal);\", \"ViewDirection = normalize(viewPosition - FragPosition);\", \"\", \"}\"].join(\"\\n\");\n  }\n\n  static get fragment() {\n    return [// Float precision\n    \"precision highp float;\", // Fragment shader input variables\n    \"varying vec2 TexCoords;\", \"varying vec3 Normal;\", \"varying vec3 FragPosition;\", \"\", // Shader inputs\n    //\"uniform vec3 viewPosition;\",\n    //\"uniform vec3 lightPosition;\",\n    \"uniform vec3 diffuseColor;\", \"uniform vec3 lightColor;\", \"uniform vec3 lightPositions[3];\", ///////////\n    \"varying vec3 LightDirection;\", \"varying vec3 ReflectDirection;\", \"varying vec3 ViewDirection;\", \"\", \"vec3 computeSpecular(vec3 lightColor) {\", \"float specularStrength = 0.5;\", \"float shininess = 32.0;\", \"float spec = pow(max(dot(ViewDirection, ReflectDirection), 0.0), shininess);\", \"return spec * specularStrength * lightColor;\", \"}\", \"\", \"vec3 computeDiffuseSpecular(vec3 lightPosition, float lightStrength) {\", // Diffuse lighting\n    //\"vec3 lightDirection = normalize(lightPosition - FragPosition);\",\n    //\"vec3 reflectDirection = reflect(-lightDirection, Normal);\",\n    \"float diff = max(dot(Normal, LightDirection), 0.0);\", \"vec3 diffuse = (diff * lightColor * diffuseColor);\", \"\", // Compute the view direction vector from the pixel to the camera\n    //\"vec3 viewDirection = normalize(viewPosition - FragPosition);\",\n    // Specular lighting\n    \"vec3 specular = computeSpecular(lightColor) * diff;\", \"\", // Calculate the intensity decrement\n    //\"float dist = distance(lightPosition, FragPosition);\",\n    //\"float intensity = min(lightStrength / dist, 1.0);\",\n    \"float intensity = 1.0;\", \"\", // Phong lighting model\n    \"return (diffuse + specular) * intensity;\", \"}\", \"\", \"void main() {\", // Ambient lighting\n    \"float ambientStrength = 0.05;\", \"vec3 ambient = ambientStrength * lightColor * diffuseColor;\", // Add the ambient light to the phong model\n    \"vec3 phong = ambient;\", // Add first point light\n    \"phong += computeDiffuseSpecular(lightPositions[0], 100.0);\", // Add second point light\n    \"phong += computeDiffuseSpecular(lightPositions[1], 100.0);\", // Add third point light\n    \"phong += computeDiffuseSpecular(lightPositions[2], 100.0);\", // Final shaded color (texture * lighting)\n    \"gl_FragColor = vec4 (phong, 1.0);\", \"}\"].join(\"\\n\");\n  }\n\n}\n\nexport default PhongLightingShader;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\shaders\\PhongLightingShader.js"],"names":["PhongLightingShader","vertex","join","fragment"],"mappings":"AAAA,MAAMA,mBAAN,CAA0B;AACtB,aAAWC,MAAX,GAAqB;AACjB,WAAO,CACH,wBADG,EAEH,EAFG,EAGH;AACA,kCAJG,EAKH,4BALG,EAMH,8BANG,EAOH,EAPG,EAQH;AACA,8BATG,EAUH,yBAVG,EAWH,2BAXG,EAYH,EAZG,EAaH;AACA,gCAdG,EAeH,6BAfG,EAgBH;AACA,6BAjBG,EAkBH,sBAlBG,EAmBH,4BAnBG,EAoBH;AACA,kCArBG,EAsBH,gCAtBG,EAuBH,6BAvBG,EAwBH,EAxBG,EAyBH,eAzBG,EA0BC;AACA,oDA3BD,EA4BC;AACA,gDA7BD,EA8BC,EA9BD,EA+BC;AACA,qDAhCD,EAiCC,2BAjCD,EAkCC,2DAlCD,EAmCC;AACA,+DApCD,EAqCC,sDArCD,EAsCC,yDAtCD,EAuCC,EAvCD,EAwCH,GAxCG,EAyCLC,IAzCK,CAyCA,IAzCA,CAAP;AA0CH;;AAED,aAAWC,QAAX,GAAuB;AACnB,WAAO,CACH;AACA,4BAFG,EAGH;AACA,6BAJG,EAKH,sBALG,EAMH,4BANG,EAOH,EAPG,EAQH;AACA;AACA;AACA,gCAXG,EAYH,0BAZG,EAaH,iCAbG,EAcH;AACA,kCAfG,EAgBH,gCAhBG,EAiBH,6BAjBG,EAkBH,EAlBG,EAmBH,yCAnBG,EAoBC,+BApBD,EAqBC,yBArBD,EAsBC,8EAtBD,EAuBC,8CAvBD,EAwBH,GAxBG,EAyBH,EAzBG,EA0BH,wEA1BG,EA2BC;AACA;AACA;AACA,yDA9BD,EA+BC,oDA/BD,EAgCC,EAhCD,EAiCC;AACA;AACA;AACA,yDApCD,EAqCC,EArCD,EAsCC;AACA;AACA;AACA,4BAzCD,EA0CC,EA1CD,EA2CC;AACA,8CA5CD,EA6CH,GA7CG,EA8CH,EA9CG,EA+CH,eA/CG,EAgDC;AACA,mCAjDD,EAkDC,6DAlDD,EAmDC;AACA,2BApDD,EAqDC;AACA,gEAtDD,EAuDC;AACA,gEAxDD,EAyDC;AACA,gEA1DD,EA2DC;AACA,uCA5DD,EA6DH,GA7DG,EA8DLD,IA9DK,CA8DA,IA9DA,CAAP;AA+DH;;AA9GqB;;AAiH1B,eAAeF,mBAAf","sourcesContent":["class PhongLightingShader {\r\n    static get vertex () {\r\n        return [\r\n            \"precision highp float;\",\r\n            \"\",\r\n            // Attribute locations\r\n            \"attribute vec3 vertPosition;\",\r\n            \"attribute vec3 vertNormal;\",\r\n            \"attribute vec2 vertTexCoord;\",\r\n            \"\",\r\n            // Transformation matrices\r\n            \"uniform mat4 cameraView;\",\r\n            \"uniform mat4 modelView;\",\r\n            \"uniform mat4 perspective;\",\r\n            \"\",\r\n            /////////////////////////////\r\n            \"uniform vec3 viewPosition;\",\r\n            \"uniform vec3 lightPosition;\",\r\n            // Fragment shader input variables\r\n            \"varying vec2 TexCoords;\",\r\n            \"varying vec3 Normal;\",\r\n            \"varying vec3 FragPosition;\",\r\n            ///////\r\n            \"varying vec3 LightDirection;\",\r\n            \"varying vec3 ReflectDirection;\",\r\n            \"varying vec3 ViewDirection;\",\r\n            \"\",\r\n            \"void main() {\",\r\n                // Final transformation ( Perspective multiplied with the model view )\r\n                \"mat4 T = perspective * cameraView * modelView;\",\r\n                // Transform (x,y,z) vertex coordinates with a 4x4 matrix T\r\n                \"gl_Position = T * vec4(vertPosition, 1.0);\",\r\n                \"\",\r\n                // Fragment shader input variables\r\n                \"Normal = normalize(mat3(modelView)*vertNormal);\",\r\n                \"TexCoords = vertTexCoord;\",\r\n                \"FragPosition = vec3(modelView * vec4(vertPosition, 1.0));\",\r\n                ////////////////\r\n                \"LightDirection = normalize(lightPosition - FragPosition);\",\r\n                \"ReflectDirection = reflect(-LightDirection, Normal);\",\r\n                \"ViewDirection = normalize(viewPosition - FragPosition);\",\r\n                \"\",\r\n            \"}\"\r\n        ].join(\"\\n\");\r\n    }\r\n\r\n    static get fragment () {\r\n        return [\r\n            // Float precision\r\n            \"precision highp float;\",\r\n            // Fragment shader input variables\r\n            \"varying vec2 TexCoords;\",\r\n            \"varying vec3 Normal;\",\r\n            \"varying vec3 FragPosition;\",\r\n            \"\",\r\n            // Shader inputs\r\n            //\"uniform vec3 viewPosition;\",\r\n            //\"uniform vec3 lightPosition;\",\r\n            \"uniform vec3 diffuseColor;\",\r\n            \"uniform vec3 lightColor;\",\r\n            \"uniform vec3 lightPositions[3];\",\r\n            ///////////\r\n            \"varying vec3 LightDirection;\",\r\n            \"varying vec3 ReflectDirection;\",\r\n            \"varying vec3 ViewDirection;\",\r\n            \"\",\r\n            \"vec3 computeSpecular(vec3 lightColor) {\",\r\n                \"float specularStrength = 0.5;\",\r\n                \"float shininess = 32.0;\",\r\n                \"float spec = pow(max(dot(ViewDirection, ReflectDirection), 0.0), shininess);\",\r\n                \"return spec * specularStrength * lightColor;\",\r\n            \"}\",\r\n            \"\",\r\n            \"vec3 computeDiffuseSpecular(vec3 lightPosition, float lightStrength) {\",\r\n                // Diffuse lighting\r\n                //\"vec3 lightDirection = normalize(lightPosition - FragPosition);\",\r\n                //\"vec3 reflectDirection = reflect(-lightDirection, Normal);\",\r\n                \"float diff = max(dot(Normal, LightDirection), 0.0);\",\r\n                \"vec3 diffuse = (diff * lightColor * diffuseColor);\",\r\n                \"\",\r\n                // Compute the view direction vector from the pixel to the camera\r\n                //\"vec3 viewDirection = normalize(viewPosition - FragPosition);\",\r\n                // Specular lighting\r\n                \"vec3 specular = computeSpecular(lightColor) * diff;\",\r\n                \"\",\r\n                // Calculate the intensity decrement\r\n                //\"float dist = distance(lightPosition, FragPosition);\",\r\n                //\"float intensity = min(lightStrength / dist, 1.0);\",\r\n                \"float intensity = 1.0;\",\r\n                \"\",\r\n                // Phong lighting model\r\n                \"return (diffuse + specular) * intensity;\",\r\n            \"}\",\r\n            \"\",\r\n            \"void main() {\",\r\n                // Ambient lighting\r\n                \"float ambientStrength = 0.05;\",\r\n                \"vec3 ambient = ambientStrength * lightColor * diffuseColor;\",\r\n                // Add the ambient light to the phong model\r\n                \"vec3 phong = ambient;\",\r\n                // Add first point light\r\n                \"phong += computeDiffuseSpecular(lightPositions[0], 100.0);\",\r\n                // Add second point light\r\n                \"phong += computeDiffuseSpecular(lightPositions[1], 100.0);\",\r\n                // Add third point light\r\n                \"phong += computeDiffuseSpecular(lightPositions[2], 100.0);\",\r\n                // Final shaded color (texture * lighting)\r\n                \"gl_FragColor = vec4 (phong, 1.0);\",\r\n            \"}\"\r\n        ].join(\"\\n\");\r\n    }\r\n}\r\n\r\nexport default PhongLightingShader;"]},"metadata":{},"sourceType":"module"}