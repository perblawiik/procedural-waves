{"ast":null,"code":"import Matrix4 from './math/Matrix4';\n\nclass IntersectionField {\n  constructor(vertices) {\n    this.vertices = vertices;\n    this.borders = {\n      xMin: 0,\n      xMax: 0,\n      yMin: 0,\n      yMax: 0\n    };\n  }\n\n  setCanvasSize(w, h) {\n    this.width = w;\n    this.height = h;\n  }\n\n  setCamera(camera) {\n    this.cameraView = camera;\n  }\n\n  updateBorders(matrix) {\n    let camera = this.cameraView;\n    let width = this.width;\n    let height = this.height;\n\n    if (camera) {\n      this.borders.xMin = width + 1;\n      this.borders.xMax = -1;\n      this.borders.yMin = height + 1;\n      this.borders.yMax = -1; // Set the width and height of the viewport\n\n      let screenW = width / (width * Math.sqrt(width / height));\n      let screenH = height / (width * Math.sqrt(width / height));\n\n      for (let i = 0; i < this.vertices.length; ++i) {\n        // Take one point from a local coordinate system\n        let screenCoordinates = this.vertices[i]; // Transform the local coordinate system point to the world coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates); // Transform this point to the cameras local coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates); // Compute the coordinates from camera space onto the canvas by using perspective projection\n        // px = x/(-z), py = y/(-z)\n\n        let px = screenCoordinates[0] / -screenCoordinates[2];\n        let py = screenCoordinates[1] / -screenCoordinates[2]; // Check if the point is visible in the viewport\n\n        /*\r\n        if (Math.abs(px) > (screenW/2) || Math.abs(py) > (screenH/2)) {\r\n            console.log(\"Not Visible\");\r\n        }\r\n        else {\r\n            console.log(\"Visible\");\r\n        }\r\n        */\n        // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\n\n        let pxNormalized = (px + screenW / 2) / screenW;\n        let pyNormalized = (py + screenH / 2) / screenH; // Covert to pixel coordinates (Raster space)\n\n        let pxRaster = Math.floor(pxNormalized * width);\n        let pyRaster = Math.floor((1 - pyNormalized) * height);\n        if (pxRaster < 0) pxRaster = 0;else if (pxRaster > width) pxRaster = width;\n        if (pyRaster < 0) pyRaster = 0;else if (pyRaster > height) pyRaster = height;\n\n        if (pxRaster < this.borders.xMin) {\n          this.borders.xMin = pxRaster;\n        } else if (pxRaster > this.borders.xMax) {\n          this.borders.xMax = pxRaster;\n        }\n\n        if (pyRaster < this.borders.yMin) {\n          this.borders.yMin = pyRaster;\n        } else if (pyRaster > this.borders.yMax) {\n          this.borders.yMax = pyRaster;\n        }\n      }\n    }\n  }\n\n}\n\nexport default IntersectionField;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\IntersectionField.js"],"names":["Matrix4","IntersectionField","constructor","vertices","borders","xMin","xMax","yMin","yMax","setCanvasSize","w","h","width","height","setCamera","camera","cameraView","updateBorders","matrix","screenW","Math","sqrt","screenH","i","length","screenCoordinates","multiplyVector","transform","px","py","pxNormalized","pyNormalized","pxRaster","floor","pyRaster"],"mappings":"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","sourcesContent":["import Matrix4 from './math/Matrix4';\r\n\r\nclass IntersectionField {\r\n    constructor(vertices) {\r\n        this.vertices = vertices;\r\n        this.borders = {\r\n            xMin: 0,\r\n            xMax: 0,\r\n            yMin: 0,\r\n            yMax: 0\r\n        };\r\n    }\r\n\r\n    setCanvasSize (w, h) {\r\n        this.width = w;\r\n        this.height = h;\r\n    }\r\n\r\n    setCamera (camera){\r\n        this.cameraView = camera;\r\n    }\r\n\r\n    updateBorders(matrix) {\r\n        let camera = this.cameraView;\r\n        let width = this.width;\r\n        let height = this.height;\r\n\r\n        if (camera) {\r\n            this.borders.xMin = width+1;\r\n            this.borders.xMax = -1;\r\n            this.borders.yMin = height+1;\r\n            this.borders.yMax = -1;\r\n\r\n            // Set the width and height of the viewport\r\n            let screenW = width/(width*Math.sqrt(width/height));\r\n            let screenH = height/(width*Math.sqrt(width/height));\r\n\r\n            for (let i = 0; i < this.vertices.length; ++i) {\r\n                // Take one point from a local coordinate system\r\n                let screenCoordinates = this.vertices[i];\r\n                // Transform the local coordinate system point to the world coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(matrix, screenCoordinates);\r\n                // Transform this point to the cameras local coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates);\r\n\r\n                // Compute the coordinates from camera space onto the canvas by using perspective projection\r\n                // px = x/(-z), py = y/(-z)\r\n                let px = (screenCoordinates[0]/(-screenCoordinates[2]));\r\n                let py = (screenCoordinates[1]/(-screenCoordinates[2]));\r\n\r\n                // Check if the point is visible in the viewport\r\n                /*\r\n                if (Math.abs(px) > (screenW/2) || Math.abs(py) > (screenH/2)) {\r\n                    console.log(\"Not Visible\");\r\n                }\r\n                else {\r\n                    console.log(\"Visible\");\r\n                }\r\n                */\r\n\r\n                // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\r\n                let pxNormalized = (px+(screenW/2)) / screenW;\r\n                let pyNormalized = (py+(screenH/2)) / screenH;\r\n\r\n                // Covert to pixel coordinates (Raster space)\r\n                let pxRaster = Math.floor(pxNormalized * width);\r\n                let pyRaster = Math.floor((1-pyNormalized) * height);\r\n\r\n                if (pxRaster < 0)\r\n                    pxRaster = 0;\r\n                else if (pxRaster > width)\r\n                    pxRaster = width;\r\n                if (pyRaster < 0)\r\n                    pyRaster = 0;\r\n                else if (pyRaster > height)\r\n                    pyRaster = height;\r\n\r\n                if (pxRaster < this.borders.xMin) {\r\n                    this.borders.xMin = pxRaster;\r\n                }\r\n                else if (pxRaster > this.borders.xMax) {\r\n                    this.borders.xMax = pxRaster;\r\n                }\r\n\r\n                if (pyRaster < this.borders.yMin) {\r\n                    this.borders.yMin = pyRaster;\r\n                }\r\n                else if (pyRaster > this.borders.yMax) {\r\n                    this.borders.yMax = pyRaster;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default IntersectionField;"]},"metadata":{},"sourceType":"module"}