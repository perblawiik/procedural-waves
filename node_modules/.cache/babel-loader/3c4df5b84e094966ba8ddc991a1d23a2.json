{"ast":null,"code":"import Vector3 from \"./math/Vector3\";\n\nclass Raycast {\n  static sphereIntersectionTest(ray, sphere) {\n    let rayToSphere = Vector3.subtract(sphere.center, ray.origin);\n    let tca = Vector3.dot(rayToSphere, ray.direction);\n\n    if (tca < 0.0) {\n      console.log(\"Sphere intersection missed\");\n      return -1;\n    }\n\n    let shortestFromRayToCenter = Math.sqrt(Vector3.dot(rayToSphere, rayToSphere) - tca * tca); // If this distance is greater than the sphere radius the ray has missed the sphere\n\n    if (shortestFromRayToCenter > sphere.radius) {\n      console.log(\"Sphere intersection missed\");\n      return -1;\n    } //let thc = Math.sqrt(sphere.radius*sphere.radius - shortestFromRayToCenter*shortestFromRayToCenter);\n    //let intersectionDistancePoint1 = tca - thc;\n    //let intersectionDistancePoint2 = tca + thc;\n\n\n    console.log(\"Sphere intersection hit\");\n    return true;\n  }\n\n  static planeIntersectionTest(ray, plane) {\n    // Compute distance from ray origin and intersection point\n    let intersectionPointDist = -(Vector3.dot(ray.origin, plane.normal) + plane.offset) / Vector3.dot(ray.direction, plane.normal);\n\n    if (intersectionPointDist < 0) {\n      console.log(\"Plane intersection missed\");\n      return false;\n    }\n\n    console.log(\"Intersection point distance: \" + intersectionPointDist);\n    let intersectionPoint = new Vector3([ray.origin.x + ray.direction.x * intersectionPointDist, ray.origin.y + ray.direction.y * intersectionPointDist, ray.origin.z + ray.direction.z * intersectionPointDist]);\n    console.log(\"Intersection point: \" + intersectionPoint.x.toFixed(2) + \", \" + intersectionPoint.y.toFixed(2) + \", \" + intersectionPoint.z.toFixed(2));\n    return true;\n  }\n\n}\n\nexport default Raycast;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Raycast.js"],"names":["Vector3","Raycast","sphereIntersectionTest","ray","sphere","rayToSphere","subtract","center","origin","tca","dot","direction","console","log","shortestFromRayToCenter","Math","sqrt","radius","planeIntersectionTest","plane","intersectionPointDist","normal","offset","intersectionPoint","x","y","z","toFixed"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,gBAApB;;AAEA,MAAMC,OAAN,CAAc;AACV,SAAOC,sBAAP,CAA8BC,GAA9B,EAAmCC,MAAnC,EAA2C;AACvC,QAAIC,WAAW,GAAGL,OAAO,CAACM,QAAR,CAAiBF,MAAM,CAACG,MAAxB,EAAgCJ,GAAG,CAACK,MAApC,CAAlB;AACA,QAAIC,GAAG,GAAGT,OAAO,CAACU,GAAR,CAAYL,WAAZ,EAAyBF,GAAG,CAACQ,SAA7B,CAAV;;AACA,QAAIF,GAAG,GAAG,GAAV,EAAe;AACXG,MAAAA,OAAO,CAACC,GAAR,CAAY,4BAAZ;AACA,aAAO,CAAC,CAAR;AACH;;AAED,QAAIC,uBAAuB,GAAGC,IAAI,CAACC,IAAL,CAAUhB,OAAO,CAACU,GAAR,CAAYL,WAAZ,EAAyBA,WAAzB,IAAwCI,GAAG,GAACA,GAAtD,CAA9B,CARuC,CASvC;;AACA,QAAIK,uBAAuB,GAAGV,MAAM,CAACa,MAArC,EAA6C;AACzCL,MAAAA,OAAO,CAACC,GAAR,CAAY,4BAAZ;AACA,aAAO,CAAC,CAAR;AACH,KAbsC,CAevC;AACA;AACA;;;AAEAD,IAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AACA,WAAO,IAAP;AACH;;AAED,SAAOK,qBAAP,CAA6Bf,GAA7B,EAAkCgB,KAAlC,EAAyC;AACrC;AACA,QAAIC,qBAAqB,GAAG,EAAEpB,OAAO,CAACU,GAAR,CAAYP,GAAG,CAACK,MAAhB,EAAwBW,KAAK,CAACE,MAA9B,IAAwCF,KAAK,CAACG,MAAhD,IAA0DtB,OAAO,CAACU,GAAR,CAAYP,GAAG,CAACQ,SAAhB,EAA2BQ,KAAK,CAACE,MAAjC,CAAtF;;AAEA,QAAID,qBAAqB,GAAG,CAA5B,EAA+B;AAC3BR,MAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ;AACA,aAAO,KAAP;AACH;;AAEDD,IAAAA,OAAO,CAACC,GAAR,CAAY,kCAAkCO,qBAA9C;AAEA,QAAIG,iBAAiB,GAAG,IAAIvB,OAAJ,CAAY,CAChCG,GAAG,CAACK,MAAJ,CAAWgB,CAAX,GAAerB,GAAG,CAACQ,SAAJ,CAAca,CAAd,GAAgBJ,qBADC,EAEhCjB,GAAG,CAACK,MAAJ,CAAWiB,CAAX,GAAetB,GAAG,CAACQ,SAAJ,CAAcc,CAAd,GAAgBL,qBAFC,EAGhCjB,GAAG,CAACK,MAAJ,CAAWkB,CAAX,GAAevB,GAAG,CAACQ,SAAJ,CAAce,CAAd,GAAgBN,qBAHC,CAAZ,CAAxB;AAMAR,IAAAA,OAAO,CAACC,GAAR,CAAY,yBAAyBU,iBAAiB,CAACC,CAAlB,CAAoBG,OAApB,CAA4B,CAA5B,CAAzB,GAA0D,IAA1D,GAAiEJ,iBAAiB,CAACE,CAAlB,CAAoBE,OAApB,CAA4B,CAA5B,CAAjE,GAAkG,IAAlG,GAAyGJ,iBAAiB,CAACG,CAAlB,CAAoBC,OAApB,CAA4B,CAA5B,CAArH;AACA,WAAO,IAAP;AACH;;AA3CS;;AA8Cd,eAAe1B,OAAf","sourcesContent":["import Vector3 from \"./math/Vector3\";\r\n\r\nclass Raycast {\r\n    static sphereIntersectionTest(ray, sphere) {\r\n        let rayToSphere = Vector3.subtract(sphere.center, ray.origin);\r\n        let tca = Vector3.dot(rayToSphere, ray.direction);\r\n        if (tca < 0.0) {\r\n            console.log(\"Sphere intersection missed\");\r\n            return -1;\r\n        }\r\n\r\n        let shortestFromRayToCenter = Math.sqrt(Vector3.dot(rayToSphere, rayToSphere) - tca*tca);\r\n        // If this distance is greater than the sphere radius the ray has missed the sphere\r\n        if (shortestFromRayToCenter > sphere.radius) {\r\n            console.log(\"Sphere intersection missed\");\r\n            return -1;\r\n        }\r\n\r\n        //let thc = Math.sqrt(sphere.radius*sphere.radius - shortestFromRayToCenter*shortestFromRayToCenter);\r\n        //let intersectionDistancePoint1 = tca - thc;\r\n        //let intersectionDistancePoint2 = tca + thc;\r\n\r\n        console.log(\"Sphere intersection hit\");\r\n        return true;\r\n    }\r\n\r\n    static planeIntersectionTest(ray, plane) {\r\n        // Compute distance from ray origin and intersection point\r\n        let intersectionPointDist = -(Vector3.dot(ray.origin, plane.normal) + plane.offset) / Vector3.dot(ray.direction, plane.normal);\r\n\r\n        if (intersectionPointDist < 0) {\r\n            console.log(\"Plane intersection missed\");\r\n            return false;\r\n        }\r\n\r\n        console.log(\"Intersection point distance: \" + intersectionPointDist);\r\n\r\n        let intersectionPoint = new Vector3([\r\n            ray.origin.x + ray.direction.x*intersectionPointDist,\r\n            ray.origin.y + ray.direction.y*intersectionPointDist,\r\n            ray.origin.z + ray.direction.z*intersectionPointDist,\r\n        ]);\r\n\r\n        console.log(\"Intersection point: \" + intersectionPoint.x.toFixed(2) + \", \" + intersectionPoint.y.toFixed(2) + \", \" + intersectionPoint.z.toFixed(2));\r\n        return true;\r\n    }\r\n}\r\n\r\nexport default Raycast;"]},"metadata":{},"sourceType":"module"}