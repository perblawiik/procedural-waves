{"ast":null,"code":"/**\r\n * Author: Per Bl√•wiik\r\n * Date: 2019-12-29\r\n */\n\n/* POSSIBLE IMPROVEMENTS:\r\n*  - Surface breaking foam\r\n*  - Wave sharpness based on the water depth\r\n* */\nclass ProceduralShader {\n  static get perlinNoise() {\n    //\n    // Description : Array and textureless GLSL 3D simplex noise function.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    //\n    return [\"vec3 mod289(vec3 x) {\", \"return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"vec4 mod289(vec4 x) {\", \"return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"vec4 permute(vec4 x) {\", \"return mod289(((x*34.0)+1.0)*x);\", \"}\", \"vec4 taylorInvSqrt(vec4 r) {\", \"return 1.79284291400159 - 0.85373472095314 * r;\", \"}\", \"float snoise(vec3 v) {\", \"const vec2  C = vec2(1.0/6.0, 1.0/3.0);\", \"const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\", // First corner\n    \"vec3 i  = floor(v + dot(v, C.yyy) );\", \"vec3 x0 =   v - i + dot(i, C.xxx) ;\", // Other corners\n    \"vec3 g = step(x0.yzx, x0.xyz);\", \"vec3 l = 1.0 - g;\", \"vec3 i1 = min( g.xyz, l.zxy );\", \"vec3 i2 = max( g.xyz, l.zxy );\", \"vec3 x1 = x0 - i1 + C.xxx;\", \"vec3 x2 = x0 - i2 + C.yyy;\", // 2.0*C.x = 1/3 = C.y\n    \"vec3 x3 = x0 - D.yyy;\", // -1.0+3.0*C.x = -0.5 = -D.y\n    // Permutations\n    \"i = mod289(i);\", \"vec4 p = permute( permute( permute(\", \"i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\", \"+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\", \"+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\", // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    \"float n_ = 0.142857142857; // 1.0/7.0\", \"vec3  ns = n_ * D.wyz - D.xzx;\", \"vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\", //  mod(p,7*7)\n    \"vec4 x_ = floor(j * ns.z);\", \"vec4 y_ = floor(j - 7.0 * x_ );\", // mod(j,N)\n    \"vec4 x = x_ *ns.x + ns.yyyy;\", \"vec4 y = y_ *ns.x + ns.yyyy;\", \"vec4 h = 1.0 - abs(x) - abs(y);\", \"vec4 b0 = vec4( x.xy, y.xy );\", \"vec4 b1 = vec4( x.zw, y.zw );\", \"vec4 s0 = floor(b0)*2.0 + 1.0;\", \"vec4 s1 = floor(b1)*2.0 + 1.0;\", \"vec4 sh = -step(h, vec4(0.0));\", \"vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\", \"vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\", \"vec3 p0 = vec3(a0.xy,h.x);\", \"vec3 p1 = vec3(a0.zw,h.y);\", \"vec3 p2 = vec3(a1.xy,h.z);\", \"vec3 p3 = vec3(a1.zw,h.w);\", //Normalise gradients\n    \"vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\", \"p0 *= norm.x;\", \"p1 *= norm.y;\", \"p2 *= norm.z;\", \"p3 *= norm.w;\", // Mix final noise value\n    \"vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\", \"m = m * m;\", \"return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\", \"dot(p2,x2), dot(p3,x3) ) );\", \"}\", \"float sdnoise(vec3 v, out vec3 gradient) {\", \"const vec2  C = vec2(1.0/6.0, 1.0/3.0);\", \"const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\", // First corner\n    \"vec3 i  = floor(v + dot(v, C.yyy) );\", \"vec3 x0 =   v - i + dot(i, C.xxx) ;\", // Other corners\n    \"vec3 g = step(x0.yzx, x0.xyz);\", \"vec3 l = 1.0 - g;\", \"vec3 i1 = min( g.xyz, l.zxy );\", \"vec3 i2 = max( g.xyz, l.zxy );\", \"vec3 x1 = x0 - i1 + C.xxx;\", \"vec3 x2 = x0 - i2 + C.yyy;\", // 2.0*C.x = 1/3 = C.y\n    \"vec3 x3 = x0 - D.yyy;\", // -1.0+3.0*C.x = -0.5 = -D.y\n    // Permutations\n    \"i = mod289(i);\", \"vec4 p = permute( permute( permute(\", \"i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\", \"+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\", \"+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\", // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    \"float n_ = 0.142857142857;\", // 1.0/7.0\n    \"vec3  ns = n_ * D.wyz - D.xzx;\", \"vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\", //  mod(p,7*7)\n    \"vec4 x_ = floor(j * ns.z);\", \"vec4 y_ = floor(j - 7.0 * x_ );\", // mod(j,N)\n    \"vec4 x = x_ *ns.x + ns.yyyy;\", \"vec4 y = y_ *ns.x + ns.yyyy;\", \"vec4 h = 1.0 - abs(x) - abs(y);\", \"vec4 b0 = vec4( x.xy, y.xy );\", \"vec4 b1 = vec4( x.zw, y.zw );\", \"vec4 s0 = floor(b0)*2.0 + 1.0;\", \"vec4 s1 = floor(b1)*2.0 + 1.0;\", \"vec4 sh = -step(h, vec4(0.0));\", \"vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\", \"vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\", \"vec3 p0 = vec3(a0.xy,h.x);\", \"vec3 p1 = vec3(a0.zw,h.y);\", \"vec3 p2 = vec3(a1.xy,h.z);\", \"vec3 p3 = vec3(a1.zw,h.w);\", //Normalise gradients\n    \"vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\", \"p0 *= norm.x;\", \"p1 *= norm.y;\", \"p2 *= norm.z;\", \"p3 *= norm.w;\", // Mix final noise value\n    \"vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\", \"vec4 m2 = m * m;\", \"vec4 m4 = m2 * m2;\", \"vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));\", // Determine noise gradient\n    \"vec4 temp = m2 * m * pdotx;\", \"gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\", \"gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\", \"gradient *= 42.0;\", \"return 42.0 * dot(m4, pdotx);\", \"}\"].join(\"\\n\");\n  }\n\n  static get vertex() {\n    return [\"precision highp float;\", // Attribute locations\n    \"attribute vec3 vertPosition;\", \"attribute vec3 vertNormal;\", \"attribute vec2 vertTexCoord;\", // Transformation matrices\n    \"uniform mat4 cameraView;\", \"uniform mat4 modelView;\", \"uniform mat4 perspective;\", // Other inputs\n    \"uniform float time;\", \"uniform float harmonicAmplitude;\", \"uniform float harmonicWaveLength;\", \"uniform float harmonicSpeed;\", \"uniform float waveSharpness;\", \"uniform float harmonicDirectionAngle;\", // Fragment shader input variables\n    \"varying vec2 TexCoords;\", \"varying vec3 Normal;\", \"varying vec3 FragPosition;\", \"varying float Time;\", // Perlin noise function\n    this.perlinNoise, \"void main() {\", // Compute the world position before generating the noise and wave functions\n    \"vec4 worldPos = modelView*vec4(vertPosition, 1.0);\", // Compute wave direction\n    \"vec2 direction = vec2(sin(harmonicDirectionAngle), cos(harmonicDirectionAngle));\", \"vec2 xzRotated = vec2(worldPos.x*direction.x, worldPos.z*direction.y);\", // Add three layers of perlin noise to the wave\n    \"float waveNoise = 2.0*snoise(0.0025*vec3(worldPos.x, worldPos.x, 20.0*time));\", \"waveNoise += 0.25*snoise(0.1*vec3(worldPos.xz, 4.0*time));\", // Create a harmonic base for the wave with a sharp nonnegative sine function\n    // Compute frequency based on the wave length (w = 2/L)\n    \"float harmonicFrequency = 2.0/harmonicWaveLength;\", // Compute the phase based on the speed and frequency\n    \"float harmonicPhase = harmonicSpeed * harmonicFrequency;\", \"float theta = (xzRotated.x + xzRotated.y)*harmonicFrequency + harmonicPhase*time;\", \"float harmonicWave = 2.0*(harmonicAmplitude+waveNoise)*pow((sin(theta) + 1.0)/2.0, waveSharpness);\", // Add the noise and the harmonic wave together as the final wave function\n    //\"float waveFunction = harmonicWave + waveNoise;\",\n    \"float waveFunction = harmonicWave;\", // Displace the surface y-coordinate (up/down)\n    \"vec3 displacedPosition = vec3(vertPosition.x, vertPosition.y + waveFunction, vertPosition.z);\", // Compute the normal for the displaced surface\n    \"float A = waveSharpness*harmonicFrequency*harmonicAmplitude;\", \"float B = pow((sin(theta) + 1.0)/2.0, waveSharpness - 1.0);\", \"float C = cos(theta);\", \"float partialDerivativeX = direction.x*A*B*C;\", \"float partialDerivativeZ = direction.y*A*B*C;\", // Compute the displaced normal\n    \"vec3 displacedNormal = normalize(vec3(-partialDerivativeX, 1.0, -partialDerivativeZ));\", \"Normal = normalize(mat3(modelView)*displacedNormal);\", \"vertNormal;\", // Final transformation ( Perspective multiplied with the model view )\n    \"mat4 T = perspective * cameraView * modelView;\", // Transform (x,y,z) vertex coordinates with the transform matrix\n    \"gl_Position = T * vec4(displacedPosition, 1.0);\", // Fragment shader input variables\n    \"TexCoords = vertTexCoord;\", \"FragPosition = vec3(modelView * vec4(displacedPosition, 1.0));\", // Pass over the time variable to fragment shader\n    \"Time = time;\", \"}\"].join(\"\\n\");\n  }\n\n  static get fragment() {\n    return [\"\", \"#ifdef GL_OES_standard_derivatives\", \"#extension GL_OES_standard_derivatives : enable\", \"#endif\", \"#ifdef GL_ES\", // Float precision\n    \"precision highp float;\", \"#endif\", // Fragment shader input variables\n    \"varying vec2 TexCoords;\", \"varying vec3 Normal;\", \"varying vec3 FragPosition;\", \"varying float Time;\", \"struct PointLight {\", \"vec3 position;\", \"vec3 color;\", \"vec2 attenuationConstants;\", \"};\", // Shader inputs\n    \"uniform vec3 viewPosition;\", // Current camera position\n    \"uniform vec3 diffuseColor;\", // Object surface color\n    \"uniform int lightCount;\", // Number of light sources\n    \"uniform PointLight pointLights[10];\", // Set maximum point light sources to 10 per scene shader\n    // Computes the specular light effect based on the dot product of the reflected light vector and the camera view vector\n    \"vec3 computeSpecularLight(vec3 viewDirection, vec3 reflectDirection, vec3 lightColor) {\", \"float specularStrength = 1.0;\", \"float shininess = 96.0;\", \"float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), shininess);\", \"return spec * specularStrength * lightColor;\", \"}\", // Computes the intensity based on the distance from the light source\n    \"float computeLightAttenuation(vec3 lightPosition, vec2 attenuationConstants) {\", // Calculate the distance from current pixel to the light source\n    \"float dist = distance(lightPosition, FragPosition);\", // The constants are set to simulate the light's intensity drop off over distance\n    \"return min(1.0 / (1.0 + dist*attenuationConstants.x + dist*dist*attenuationConstants.y), 1.0);\", \"}\", \"vec3 computeDiffuseSpecular(PointLight pointLight, vec3 viewDirection, vec3 normal) {\", // Compute the vector from the pixel to the light source\n    \"vec3 lightDirection = normalize(pointLight.position - FragPosition);\", // Diffuse lighting\n    \"float diff = max(dot(normal, lightDirection), 0.0);\", \"vec3 diffuse = (diff * pointLight.color * diffuseColor);\", // Compute the vector of the reflected light based on the incoming light vector\n    \"vec3 reflectDirection = reflect(-lightDirection, normal);\", // Specular lighting\n    \"vec3 specular = computeSpecularLight(viewDirection, reflectDirection, pointLight.color) * diff;\", // Compute attenuation (intensity decrement over distance).\n    \"float attenuation = computeLightAttenuation(pointLight.position, pointLight.attenuationConstants);\", // Phong lighting model\n    \"return (diffuse + specular) * attenuation;\", \"}\", // 3D Perlin noise function\n    this.perlinNoise, \"void main() {\", // Bump then fragment normal with four layers of perlin noise\n    \"float baseSpeed = 2.0;\", \"float baseFrequency = 0.5;\", \"vec3 gradient1 = vec3(0.0);\", \"float noise = sdnoise(baseFrequency*vec3(FragPosition.xz, Time*baseSpeed), gradient1);\", \"vec3 gradient2 = vec3(0.0);\", \"noise += 0.25*sdnoise(4.0*baseFrequency*vec3(FragPosition.xz, 0.25*Time*baseSpeed), gradient2);\", \"vec3 gradient3 = vec3(0.0);\", \"noise += 0.125*sdnoise(8.0*baseFrequency*vec3(FragPosition.xz, 0.125*Time*baseSpeed), gradient3);\", \"vec3 gradient4 = vec3(0.0);\", \"noise += 0.0625*sdnoise(16.0*baseFrequency*vec3(FragPosition.xz, 0.0625*Time*baseSpeed), gradient4);\", \"float bumpStrength = 0.05;\", \"vec3 bumb = normalize(0.5*gradient1 + mix(mix(gradient2, gradient3, 0.5), gradient4, 0.5));\", \"vec3 bumpedNormal = normalize(vec3(Normal + bumpStrength*bumb));\", // Ambient lighting\n    \"float ambientStrength = 0.1;\", \"vec3 ambientColor = vec3(1.0, 1.0, 1.0);\", \"vec3 ambient = ambientStrength * ambientColor * diffuseColor;\", // Compute the vector from the pixel to the camera\n    \"vec3 viewDirection = normalize(viewPosition - FragPosition);\", // Add point light sources\n    \"vec3 phong = ambient;\", \"for(int i = 0; i < 10; i++) {\", \"if (i > lightCount) break;\", \"phong += computeDiffuseSpecular(pointLights[i], viewDirection, bumpedNormal);\", \"}\", // Final shaded color (texture * lighting)\n    \"gl_FragColor = vec4 (phong, 1.0);\", \"}\"].join(\"\\n\");\n  }\n\n}\n\nexport default ProceduralShader;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\Waves\\procedural-waves\\src\\js\\bluebox\\shaders\\ProceduralShader.js"],"names":["ProceduralShader","perlinNoise","join","vertex","fragment"],"mappings":"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","sourcesContent":["/**\r\n * Author: Per Bl√•wiik\r\n * Date: 2019-12-29\r\n */\r\n\r\n/* POSSIBLE IMPROVEMENTS:\r\n*  - Surface breaking foam\r\n*  - Wave sharpness based on the water depth\r\n* */\r\n\r\nclass ProceduralShader {\r\n        static get perlinNoise() {\r\n        //\r\n        // Description : Array and textureless GLSL 3D simplex noise function.\r\n        //      Author : Ian McEwan, Ashima Arts.\r\n        //  Maintainer : ijm\r\n        //     Lastmod : 20110822 (ijm)\r\n        //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n        //               Distributed under the MIT License. See LICENSE file.\r\n        //               https://github.com/ashima/webgl-noise\r\n        //\r\n        return [\r\n            \"vec3 mod289(vec3 x) {\",\r\n                \"return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n            \"}\",\r\n\r\n            \"vec4 mod289(vec4 x) {\",\r\n                \"return x - floor(x * (1.0 / 289.0)) * 289.0;\",\r\n            \"}\",\r\n\r\n            \"vec4 permute(vec4 x) {\",\r\n                \"return mod289(((x*34.0)+1.0)*x);\",\r\n            \"}\",\r\n\r\n            \"vec4 taylorInvSqrt(vec4 r) {\",\r\n                \"return 1.79284291400159 - 0.85373472095314 * r;\",\r\n            \"}\",\r\n\r\n            \"float snoise(vec3 v) {\",\r\n                \"const vec2  C = vec2(1.0/6.0, 1.0/3.0);\",\r\n                \"const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\",\r\n\r\n                // First corner\r\n                \"vec3 i  = floor(v + dot(v, C.yyy) );\",\r\n                \"vec3 x0 =   v - i + dot(i, C.xxx) ;\",\r\n\r\n                // Other corners\r\n                \"vec3 g = step(x0.yzx, x0.xyz);\",\r\n                \"vec3 l = 1.0 - g;\",\r\n                \"vec3 i1 = min( g.xyz, l.zxy );\",\r\n                \"vec3 i2 = max( g.xyz, l.zxy );\",\r\n\r\n                \"vec3 x1 = x0 - i1 + C.xxx;\",\r\n                \"vec3 x2 = x0 - i2 + C.yyy;\", // 2.0*C.x = 1/3 = C.y\r\n                \"vec3 x3 = x0 - D.yyy;\",      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n                // Permutations\r\n                \"i = mod289(i);\",\r\n                \"vec4 p = permute( permute( permute(\",\r\n                \"i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\",\r\n                \"+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\",\r\n                \"+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\",\r\n\r\n                // Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n                \"float n_ = 0.142857142857; // 1.0/7.0\",\r\n                \"vec3  ns = n_ * D.wyz - D.xzx;\",\r\n\r\n                \"vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\",  //  mod(p,7*7)\r\n\r\n                \"vec4 x_ = floor(j * ns.z);\",\r\n                \"vec4 y_ = floor(j - 7.0 * x_ );\",   // mod(j,N)\r\n\r\n                \"vec4 x = x_ *ns.x + ns.yyyy;\",\r\n                \"vec4 y = y_ *ns.x + ns.yyyy;\",\r\n                \"vec4 h = 1.0 - abs(x) - abs(y);\",\r\n\r\n                \"vec4 b0 = vec4( x.xy, y.xy );\",\r\n                \"vec4 b1 = vec4( x.zw, y.zw );\",\r\n\r\n                \"vec4 s0 = floor(b0)*2.0 + 1.0;\",\r\n                \"vec4 s1 = floor(b1)*2.0 + 1.0;\",\r\n                \"vec4 sh = -step(h, vec4(0.0));\",\r\n\r\n                \"vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\",\r\n                \"vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\",\r\n\r\n                \"vec3 p0 = vec3(a0.xy,h.x);\",\r\n                \"vec3 p1 = vec3(a0.zw,h.y);\",\r\n                \"vec3 p2 = vec3(a1.xy,h.z);\",\r\n                \"vec3 p3 = vec3(a1.zw,h.w);\",\r\n\r\n                //Normalise gradients\r\n                \"vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\",\r\n                \"p0 *= norm.x;\",\r\n                \"p1 *= norm.y;\",\r\n                \"p2 *= norm.z;\",\r\n                \"p3 *= norm.w;\",\r\n\r\n                // Mix final noise value\r\n                \"vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\",\r\n                \"m = m * m;\",\r\n                \"return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\",\r\n                \"dot(p2,x2), dot(p3,x3) ) );\",\r\n            \"}\",\r\n\r\n            \"float sdnoise(vec3 v, out vec3 gradient) {\",\r\n                \"const vec2  C = vec2(1.0/6.0, 1.0/3.0);\",\r\n                \"const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\",\r\n\r\n                // First corner\r\n                \"vec3 i  = floor(v + dot(v, C.yyy) );\",\r\n                \"vec3 x0 =   v - i + dot(i, C.xxx) ;\",\r\n\r\n                // Other corners\r\n                \"vec3 g = step(x0.yzx, x0.xyz);\",\r\n                \"vec3 l = 1.0 - g;\",\r\n                \"vec3 i1 = min( g.xyz, l.zxy );\",\r\n                \"vec3 i2 = max( g.xyz, l.zxy );\",\r\n\r\n                \"vec3 x1 = x0 - i1 + C.xxx;\",\r\n                \"vec3 x2 = x0 - i2 + C.yyy;\", // 2.0*C.x = 1/3 = C.y\r\n                \"vec3 x3 = x0 - D.yyy;\",      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n                // Permutations\r\n                \"i = mod289(i);\",\r\n                \"vec4 p = permute( permute( permute(\",\r\n                \"i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\",\r\n                \"+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\",\r\n                \"+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\",\r\n\r\n                // Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n                \"float n_ = 0.142857142857;\", // 1.0/7.0\r\n                \"vec3  ns = n_ * D.wyz - D.xzx;\",\r\n\r\n                \"vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\",  //  mod(p,7*7)\r\n\r\n                \"vec4 x_ = floor(j * ns.z);\",\r\n                \"vec4 y_ = floor(j - 7.0 * x_ );\",    // mod(j,N)\r\n\r\n                \"vec4 x = x_ *ns.x + ns.yyyy;\",\r\n                \"vec4 y = y_ *ns.x + ns.yyyy;\",\r\n                \"vec4 h = 1.0 - abs(x) - abs(y);\",\r\n\r\n                \"vec4 b0 = vec4( x.xy, y.xy );\",\r\n                \"vec4 b1 = vec4( x.zw, y.zw );\",\r\n\r\n                \"vec4 s0 = floor(b0)*2.0 + 1.0;\",\r\n                \"vec4 s1 = floor(b1)*2.0 + 1.0;\",\r\n                \"vec4 sh = -step(h, vec4(0.0));\",\r\n\r\n                \"vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\",\r\n                \"vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\",\r\n\r\n                \"vec3 p0 = vec3(a0.xy,h.x);\",\r\n                \"vec3 p1 = vec3(a0.zw,h.y);\",\r\n                \"vec3 p2 = vec3(a1.xy,h.z);\",\r\n                \"vec3 p3 = vec3(a1.zw,h.w);\",\r\n\r\n                //Normalise gradients\r\n                \"vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\",\r\n                \"p0 *= norm.x;\",\r\n                \"p1 *= norm.y;\",\r\n                \"p2 *= norm.z;\",\r\n                \"p3 *= norm.w;\",\r\n\r\n                // Mix final noise value\r\n                \"vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\",\r\n                \"vec4 m2 = m * m;\",\r\n                \"vec4 m4 = m2 * m2;\",\r\n                \"vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));\",\r\n\r\n                // Determine noise gradient\r\n                \"vec4 temp = m2 * m * pdotx;\",\r\n                \"gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\",\r\n                \"gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\",\r\n                \"gradient *= 42.0;\",\r\n\r\n                \"return 42.0 * dot(m4, pdotx);\",\r\n            \"}\"\r\n        ].join(\"\\n\");\r\n    }\r\n\r\n    static get vertex () {\r\n        return [\r\n            \"precision highp float;\",\r\n\r\n            // Attribute locations\r\n            \"attribute vec3 vertPosition;\",\r\n            \"attribute vec3 vertNormal;\",\r\n            \"attribute vec2 vertTexCoord;\",\r\n\r\n            // Transformation matrices\r\n            \"uniform mat4 cameraView;\",\r\n            \"uniform mat4 modelView;\",\r\n            \"uniform mat4 perspective;\",\r\n\r\n            // Other inputs\r\n            \"uniform float time;\",\r\n            \"uniform float harmonicAmplitude;\",\r\n            \"uniform float harmonicWaveLength;\",\r\n            \"uniform float harmonicSpeed;\",\r\n            \"uniform float waveSharpness;\",\r\n            \"uniform float harmonicDirectionAngle;\",\r\n\r\n            // Fragment shader input variables\r\n            \"varying vec2 TexCoords;\",\r\n            \"varying vec3 Normal;\",\r\n            \"varying vec3 FragPosition;\",\r\n            \"varying float Time;\",\r\n\r\n            // Perlin noise function\r\n            this.perlinNoise,\r\n\r\n            \"void main() {\",\r\n                // Compute the world position before generating the noise and wave functions\r\n                \"vec4 worldPos = modelView*vec4(vertPosition, 1.0);\",\r\n\r\n                // Compute wave direction\r\n                \"vec2 direction = vec2(sin(harmonicDirectionAngle), cos(harmonicDirectionAngle));\",\r\n                \"vec2 xzRotated = vec2(worldPos.x*direction.x, worldPos.z*direction.y);\",\r\n\r\n                // Add three layers of perlin noise to the wave\r\n                \"float waveNoise = 2.0*snoise(0.0025*vec3(worldPos.x, worldPos.x, 20.0*time));\",\r\n                \"waveNoise += 0.25*snoise(0.1*vec3(worldPos.xz, 4.0*time));\",\r\n\r\n                // Create a harmonic base for the wave with a sharp nonnegative sine function\r\n                // Compute frequency based on the wave length (w = 2/L)\r\n                \"float harmonicFrequency = 2.0/harmonicWaveLength;\",\r\n                // Compute the phase based on the speed and frequency\r\n                \"float harmonicPhase = harmonicSpeed * harmonicFrequency;\",\r\n                \"float theta = (xzRotated.x + xzRotated.y)*harmonicFrequency + harmonicPhase*time;\",\r\n                \"float harmonicWave = 2.0*(harmonicAmplitude+waveNoise)*pow((sin(theta) + 1.0)/2.0, waveSharpness);\",\r\n\r\n                // Add the noise and the harmonic wave together as the final wave function\r\n                //\"float waveFunction = harmonicWave + waveNoise;\",\r\n                \"float waveFunction = harmonicWave;\",\r\n\r\n                // Displace the surface y-coordinate (up/down)\r\n                \"vec3 displacedPosition = vec3(vertPosition.x, vertPosition.y + waveFunction, vertPosition.z);\",\r\n\r\n                // Compute the normal for the displaced surface\r\n                \"float A = waveSharpness*harmonicFrequency*harmonicAmplitude;\",\r\n                \"float B = pow((sin(theta) + 1.0)/2.0, waveSharpness - 1.0);\",\r\n                \"float C = cos(theta);\",\r\n                \"float partialDerivativeX = direction.x*A*B*C;\",\r\n                \"float partialDerivativeZ = direction.y*A*B*C;\",\r\n\r\n                // Compute the displaced normal\r\n                \"vec3 displacedNormal = normalize(vec3(-partialDerivativeX, 1.0, -partialDerivativeZ));\",\r\n                \"Normal = normalize(mat3(modelView)*displacedNormal);\",\r\n                \"vertNormal;\",\r\n\r\n                // Final transformation ( Perspective multiplied with the model view )\r\n                \"mat4 T = perspective * cameraView * modelView;\",\r\n                // Transform (x,y,z) vertex coordinates with the transform matrix\r\n                \"gl_Position = T * vec4(displacedPosition, 1.0);\",\r\n\r\n                // Fragment shader input variables\r\n                \"TexCoords = vertTexCoord;\",\r\n                \"FragPosition = vec3(modelView * vec4(displacedPosition, 1.0));\",\r\n\r\n                // Pass over the time variable to fragment shader\r\n                \"Time = time;\",\r\n            \"}\"\r\n        ].join(\"\\n\");\r\n    }\r\n\r\n    static get fragment () {\r\n        return [\r\n            \"\",\r\n            \"#ifdef GL_OES_standard_derivatives\",\r\n            \"#extension GL_OES_standard_derivatives : enable\",\r\n            \"#endif\",\r\n            \"#ifdef GL_ES\",\r\n            // Float precision\r\n            \"precision highp float;\",\r\n            \"#endif\",\r\n            // Fragment shader input variables\r\n            \"varying vec2 TexCoords;\",\r\n            \"varying vec3 Normal;\",\r\n            \"varying vec3 FragPosition;\",\r\n            \"varying float Time;\",\r\n\r\n            \"struct PointLight {\",\r\n                \"vec3 position;\",\r\n                \"vec3 color;\",\r\n                \"vec2 attenuationConstants;\",\r\n            \"};\",\r\n\r\n            // Shader inputs\r\n            \"uniform vec3 viewPosition;\", // Current camera position\r\n            \"uniform vec3 diffuseColor;\", // Object surface color\r\n            \"uniform int lightCount;\", // Number of light sources\r\n            \"uniform PointLight pointLights[10];\", // Set maximum point light sources to 10 per scene shader\r\n\r\n            // Computes the specular light effect based on the dot product of the reflected light vector and the camera view vector\r\n            \"vec3 computeSpecularLight(vec3 viewDirection, vec3 reflectDirection, vec3 lightColor) {\",\r\n                \"float specularStrength = 1.0;\",\r\n                \"float shininess = 96.0;\",\r\n                \"float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), shininess);\",\r\n                \"return spec * specularStrength * lightColor;\",\r\n            \"}\",\r\n\r\n            // Computes the intensity based on the distance from the light source\r\n            \"float computeLightAttenuation(vec3 lightPosition, vec2 attenuationConstants) {\",\r\n                // Calculate the distance from current pixel to the light source\r\n                \"float dist = distance(lightPosition, FragPosition);\",\r\n                // The constants are set to simulate the light's intensity drop off over distance\r\n                \"return min(1.0 / (1.0 + dist*attenuationConstants.x + dist*dist*attenuationConstants.y), 1.0);\",\r\n            \"}\",\r\n\r\n            \"vec3 computeDiffuseSpecular(PointLight pointLight, vec3 viewDirection, vec3 normal) {\",\r\n                // Compute the vector from the pixel to the light source\r\n                \"vec3 lightDirection = normalize(pointLight.position - FragPosition);\",\r\n                // Diffuse lighting\r\n                \"float diff = max(dot(normal, lightDirection), 0.0);\",\r\n                \"vec3 diffuse = (diff * pointLight.color * diffuseColor);\",\r\n\r\n                // Compute the vector of the reflected light based on the incoming light vector\r\n                \"vec3 reflectDirection = reflect(-lightDirection, normal);\",\r\n                // Specular lighting\r\n                \"vec3 specular = computeSpecularLight(viewDirection, reflectDirection, pointLight.color) * diff;\",\r\n\r\n                // Compute attenuation (intensity decrement over distance).\r\n                \"float attenuation = computeLightAttenuation(pointLight.position, pointLight.attenuationConstants);\",\r\n\r\n                // Phong lighting model\r\n                \"return (diffuse + specular) * attenuation;\",\r\n            \"}\",\r\n\r\n            // 3D Perlin noise function\r\n            this.perlinNoise,\r\n\r\n            \"void main() {\",\r\n                // Bump then fragment normal with four layers of perlin noise\r\n                \"float baseSpeed = 2.0;\",\r\n                \"float baseFrequency = 0.5;\",\r\n                \"vec3 gradient1 = vec3(0.0);\",\r\n                \"float noise = sdnoise(baseFrequency*vec3(FragPosition.xz, Time*baseSpeed), gradient1);\",\r\n                \"vec3 gradient2 = vec3(0.0);\",\r\n                \"noise += 0.25*sdnoise(4.0*baseFrequency*vec3(FragPosition.xz, 0.25*Time*baseSpeed), gradient2);\",\r\n                \"vec3 gradient3 = vec3(0.0);\",\r\n                \"noise += 0.125*sdnoise(8.0*baseFrequency*vec3(FragPosition.xz, 0.125*Time*baseSpeed), gradient3);\",\r\n                \"vec3 gradient4 = vec3(0.0);\",\r\n                \"noise += 0.0625*sdnoise(16.0*baseFrequency*vec3(FragPosition.xz, 0.0625*Time*baseSpeed), gradient4);\",\r\n\r\n                \"float bumpStrength = 0.05;\",\r\n                \"vec3 bumb = normalize(0.5*gradient1 + mix(mix(gradient2, gradient3, 0.5), gradient4, 0.5));\",\r\n                \"vec3 bumpedNormal = normalize(vec3(Normal + bumpStrength*bumb));\",\r\n\r\n                // Ambient lighting\r\n                \"float ambientStrength = 0.1;\",\r\n                \"vec3 ambientColor = vec3(1.0, 1.0, 1.0);\",\r\n                \"vec3 ambient = ambientStrength * ambientColor * diffuseColor;\",\r\n\r\n                // Compute the vector from the pixel to the camera\r\n                \"vec3 viewDirection = normalize(viewPosition - FragPosition);\",\r\n\r\n                // Add point light sources\r\n                \"vec3 phong = ambient;\",\r\n                \"for(int i = 0; i < 10; i++) {\",\r\n                    \"if (i > lightCount) break;\",\r\n                    \"phong += computeDiffuseSpecular(pointLights[i], viewDirection, bumpedNormal);\",\r\n                \"}\",\r\n\r\n                // Final shaded color (texture * lighting)\r\n                \"gl_FragColor = vec4 (phong, 1.0);\",\r\n            \"}\"\r\n        ].join(\"\\n\");\r\n    }\r\n}\r\n\r\nexport default ProceduralShader;"]},"metadata":{},"sourceType":"module"}