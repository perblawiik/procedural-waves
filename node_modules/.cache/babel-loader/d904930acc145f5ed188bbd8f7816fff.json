{"ast":null,"code":"/**\r\n * Author: Per Blåwiik\r\n * Date: 2019-12-29\r\n */\nimport Transform from \"./Transform\";\n\nclass Scene {\n  constructor(shaders) {\n    this.sceneObjects = [];\n    this.lightSources = [];\n    this.shaders = shaders;\n    this.currentTime = 0.0;\n    this.transform = new Transform();\n  }\n\n  setPosition(position) {\n    this.transform.setPosition(position);\n  }\n\n  setRotation(rotation) {\n    this.transform.setRotation(rotation);\n  }\n\n  setScale(scale) {\n    this.transform.setScale(scale);\n  }\n\n  addGameObject(gameObject) {\n    this.transform.addChild(gameObject.transform);\n    this.sceneObjects.push(gameObject);\n  }\n\n  addLightSource(lightSource) {\n    this.transform.addChild(lightSource.transform); // Update the shaders\n\n    this.shaders.forEach(shader => {\n      shader.activate();\n      let lightCount = this.lightSources.length;\n      let arrayName = \"pointLights[\" + lightCount + \"].\"; // Get uniform locations\n\n      let positionUniformLoc = shader.getUniformLoc(arrayName + \"position\");\n      let colorUniformLoc = shader.getUniformLoc(arrayName + \"color\");\n      let attenuationUniformLoc = shader.getUniformLoc(arrayName + \"attenuationConstants\");\n      let lightCountUniformLoc = shader.getUniformLoc(\"lightCount\"); // Set the uniforms in the fragment shader\n\n      shader.setUniformVec3f(positionUniformLoc, lightSource.worldPosition);\n      shader.setUniformVec3f(colorUniformLoc, lightSource.lightColor);\n      shader.setUniformVec2f(attenuationUniformLoc, [lightSource.attenuationConstants.kLinear, lightSource.attenuationConstants.kQuadratic]);\n      shader.setUniformInt(lightCountUniformLoc, lightCount);\n    }); // Add light source to the list\n\n    this.lightSources.push(lightSource);\n  } // Used for dynamic light sources\n\n\n  updateLightPositions() {\n    // Activate the main shader\n    let shader = this.shaders.get(\"phong\");\n    shader.activate();\n\n    for (let i = 0; i < this.lightSources.length; ++i) {\n      let lightSource = this.lightSources[i];\n      let lightCount = this.lightSources.length;\n      let arrayName = \"pointLights[\" + i + \"].\"; // Get uniform locations\n\n      let positionUniformLoc = shader.getUniformLoc(arrayName + \"position\");\n      let colorUniformLoc = shader.getUniformLoc(arrayName + \"color\");\n      let attenuationUniformLoc = shader.getUniformLoc(arrayName + \"attenuationConstants\");\n      let lightCountUniformLoc = shader.getUniformLoc(\"lightCount\"); // Set the uniforms in the fragment shader\n\n      shader.setUniformVec3f(positionUniformLoc, lightSource.worldPosition);\n      shader.setUniformVec3f(colorUniformLoc, lightSource.lightColor);\n      shader.setUniformVec2f(attenuationUniformLoc, [lightSource.attenuationConstants.kLinear, lightSource.attenuationConstants.kQuadratic]);\n      shader.setUniformInt(lightCountUniformLoc, lightCount);\n    }\n  }\n\n  draw() {\n    this.sceneObjects.forEach(object => {\n      object.render(this.shaders.get(object.shaderName));\n    });\n    this.lightSources.forEach(lightSource => {\n      lightSource.render(this.shaders.get(\"ambient\"));\n    });\n  }\n\n  update(timeStep) {\n    this.currentTime += timeStep;\n    let shader = this.shaders.get(\"procedural\");\n    shader.activate();\n    let timeUniformLocation = shader.getUniformLoc(\"time\");\n    shader.setUniformFloat(timeUniformLocation, this.currentTime);\n    this.sceneObjects.forEach(object => {\n      object.update(timeStep);\n    });\n  }\n\n}\n\nexport default Scene;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\Waves\\procedural-waves\\src\\js\\bluebox\\Scene.js"],"names":["Transform","Scene","constructor","shaders","sceneObjects","lightSources","currentTime","transform","setPosition","position","setRotation","rotation","setScale","scale","addGameObject","gameObject","addChild","push","addLightSource","lightSource","forEach","shader","activate","lightCount","length","arrayName","positionUniformLoc","getUniformLoc","colorUniformLoc","attenuationUniformLoc","lightCountUniformLoc","setUniformVec3f","worldPosition","lightColor","setUniformVec2f","attenuationConstants","kLinear","kQuadratic","setUniformInt","updateLightPositions","get","i","draw","object","render","shaderName","update","timeStep","timeUniformLocation","setUniformFloat"],"mappings":"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","sourcesContent":["/**\r\n * Author: Per Blåwiik\r\n * Date: 2019-12-29\r\n */\r\n\r\nimport Transform from \"./Transform\";\r\n\r\nclass Scene {\r\n    constructor(shaders) {\r\n        this.sceneObjects = [];\r\n        this.lightSources = [];\r\n        this.shaders = shaders;\r\n\r\n        this.currentTime = 0.0;\r\n        this.transform = new Transform();\r\n    }\r\n\r\n    setPosition(position) {\r\n        this.transform.setPosition(position);\r\n    }\r\n\r\n    setRotation(rotation) {\r\n        this.transform.setRotation(rotation);\r\n    };\r\n\r\n    setScale(scale) {\r\n        this.transform.setScale(scale);\r\n    }\r\n\r\n    addGameObject(gameObject) {\r\n        this.transform.addChild(gameObject.transform);\r\n        this.sceneObjects.push(gameObject);\r\n    }\r\n\r\n    addLightSource(lightSource) {\r\n        this.transform.addChild(lightSource.transform);\r\n        // Update the shaders\r\n        this.shaders.forEach((shader)=> {\r\n            shader.activate();\r\n            let lightCount = this.lightSources.length;\r\n            let arrayName = \"pointLights[\" + lightCount + \"].\";\r\n\r\n            // Get uniform locations\r\n            let positionUniformLoc = shader.getUniformLoc(arrayName + \"position\");\r\n            let colorUniformLoc = shader.getUniformLoc(arrayName + \"color\");\r\n            let attenuationUniformLoc = shader.getUniformLoc(arrayName + \"attenuationConstants\");\r\n            let lightCountUniformLoc = shader.getUniformLoc(\"lightCount\");\r\n\r\n            // Set the uniforms in the fragment shader\r\n            shader.setUniformVec3f(positionUniformLoc, lightSource.worldPosition);\r\n            shader.setUniformVec3f(colorUniformLoc, lightSource.lightColor);\r\n            shader.setUniformVec2f(attenuationUniformLoc, [lightSource.attenuationConstants.kLinear, lightSource.attenuationConstants.kQuadratic]);\r\n            shader.setUniformInt(lightCountUniformLoc, lightCount);\r\n        });\r\n\r\n        // Add light source to the list\r\n        this.lightSources.push(lightSource);\r\n    }\r\n\r\n    // Used for dynamic light sources\r\n    updateLightPositions() {\r\n        // Activate the main shader\r\n        let shader = this.shaders.get(\"phong\");\r\n        shader.activate();\r\n\r\n        for (let i = 0; i < this.lightSources.length; ++i) {\r\n            let lightSource = this.lightSources[i];\r\n            let lightCount = this.lightSources.length;\r\n            let arrayName = \"pointLights[\" + i + \"].\";\r\n\r\n            // Get uniform locations\r\n            let positionUniformLoc = shader.getUniformLoc(arrayName + \"position\");\r\n            let colorUniformLoc = shader.getUniformLoc(arrayName + \"color\");\r\n            let attenuationUniformLoc = shader.getUniformLoc(arrayName + \"attenuationConstants\");\r\n            let lightCountUniformLoc = shader.getUniformLoc(\"lightCount\");\r\n\r\n            // Set the uniforms in the fragment shader\r\n            shader.setUniformVec3f(positionUniformLoc, lightSource.worldPosition);\r\n            shader.setUniformVec3f(colorUniformLoc, lightSource.lightColor);\r\n            shader.setUniformVec2f(attenuationUniformLoc, [lightSource.attenuationConstants.kLinear, lightSource.attenuationConstants.kQuadratic]);\r\n            shader.setUniformInt(lightCountUniformLoc, lightCount);\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        this.sceneObjects.forEach((object)=> {\r\n            object.render(this.shaders.get(object.shaderName));\r\n        });\r\n\r\n        this.lightSources.forEach((lightSource) => {\r\n            lightSource.render(this.shaders.get(\"ambient\"));\r\n        });\r\n    }\r\n\r\n    update(timeStep) {\r\n        this.currentTime += timeStep;\r\n        let shader = this.shaders.get(\"procedural\");\r\n        shader.activate();\r\n        let timeUniformLocation = shader.getUniformLoc(\"time\");\r\n        shader.setUniformFloat(timeUniformLocation, this.currentTime);\r\n\r\n        this.sceneObjects.forEach((object) => {\r\n            object.update(timeStep);\r\n        });\r\n    }\r\n}\r\n\r\nexport default Scene;"]},"metadata":{},"sourceType":"module"}