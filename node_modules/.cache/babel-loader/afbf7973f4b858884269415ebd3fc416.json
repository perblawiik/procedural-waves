{"ast":null,"code":"import Matrix4 from './math/Matrix4';\n\nclass IntersectionField {\n  constructor(width, height) {\n    this.vertices = [// V0\n    [-1.0, -1.0, -1.0, 1.0], // V1\n    [-1.0, -1.0, 1.0, 1.0], // V2\n    [1.0, -1.0, 1.0, 1.0], // V3\n    [1.0, -1.0, -1.0, 1.0], // V4\n    [-1.0, 1.0, -1.0, 1.0], // V5\n    [-1.0, 1.0, 1.0, 1.0], // V6\n    [1.0, 1.0, 1.0, 1.0], // V7\n    [1.0, 1.0, -1.0, 1.0]];\n    this.borders = {\n      xMin: 0,\n      xMax: 0,\n      yMin: 0,\n      yMax: 0\n    };\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n  }\n\n  updateBorders(cameraViewMatrix, modelViewMatrix) {\n    let width = this.canvasWidth;\n    let height = this.canvasHeight;\n\n    if (cameraViewMatrix) {\n      this.borders.xMin = width + 1;\n      this.borders.xMax = -1;\n      this.borders.yMin = height + 1;\n      this.borders.yMax = -1; // Set the width and height of the viewport\n\n      let screenW = width / (width * Math.sqrt(width / height));\n      let screenH = height / (width * Math.sqrt(width / height));\n\n      for (let i = 0; i < this.vertices.length; ++i) {\n        // Take one point from a local coordinate system\n        let screenCoordinates = this.vertices[i]; // Transform the local coordinate system point to the world coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(modelViewMatrix, screenCoordinates); // Transform this point to the cameras local coordinate system\n\n        screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates); // Compute the coordinates from camera space onto the canvas by using perspective projection\n        // px = x/(-z), py = y/(-z)\n\n        let px = screenCoordinates[0] / -screenCoordinates[2];\n        let py = screenCoordinates[1] / -screenCoordinates[2]; // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\n\n        let pxNormalized = (px + screenW / 2) / screenW;\n        let pyNormalized = (py + screenH / 2) / screenH; // Covert to pixel coordinates (Raster space)\n\n        let pxRaster = Math.floor(pxNormalized * width);\n        let pyRaster = Math.floor((1 - pyNormalized) * height);\n        if (pxRaster < 0) pxRaster = 0;else if (pxRaster > width) pxRaster = width;\n        if (pyRaster < 0) pyRaster = 0;else if (pyRaster > height) pyRaster = height;\n\n        if (pxRaster < this.borders.xMin) {\n          this.borders.xMin = pxRaster;\n        } else if (pxRaster > this.borders.xMax) {\n          this.borders.xMax = pxRaster;\n        }\n\n        if (pyRaster < this.borders.yMin) {\n          this.borders.yMin = pyRaster;\n        } else if (pyRaster > this.borders.yMax) {\n          this.borders.yMax = pyRaster;\n        }\n      }\n    }\n  }\n\n}\n\nexport default IntersectionField;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\IntersectionField.js"],"names":["Matrix4","IntersectionField","constructor","width","height","vertices","borders","xMin","xMax","yMin","yMax","canvasWidth","canvasHeight","updateBorders","cameraViewMatrix","modelViewMatrix","screenW","Math","sqrt","screenH","i","length","screenCoordinates","multiplyVector","camera","transform","matrix","px","py","pxNormalized","pyNormalized","pxRaster","floor","pyRaster"],"mappings":"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","sourcesContent":["import Matrix4 from './math/Matrix4';\r\n\r\nclass IntersectionField {\r\n    constructor(width, height) {\r\n        this.vertices = [\r\n            // V0\r\n            [-1.0, -1.0, -1.0, 1.0],\r\n            // V1\r\n            [-1.0, -1.0, 1.0, 1.0],\r\n            // V2\r\n            [1.0, -1.0, 1.0, 1.0],\r\n            // V3\r\n            [1.0, -1.0, -1.0, 1.0],\r\n            // V4\r\n            [-1.0, 1.0, -1.0, 1.0],\r\n            // V5\r\n            [-1.0, 1.0, 1.0, 1.0],\r\n            // V6\r\n            [1.0, 1.0, 1.0, 1.0],\r\n            // V7\r\n            [1.0, 1.0, -1.0, 1.0]\r\n        ];\r\n\r\n        this.borders = {\r\n            xMin: 0,\r\n            xMax: 0,\r\n            yMin: 0,\r\n            yMax: 0\r\n        };\r\n\r\n        this.canvasWidth = width;\r\n        this.canvasHeight = height;\r\n    }\r\n\r\n    updateBorders(cameraViewMatrix, modelViewMatrix) {\r\n        let width = this.canvasWidth;\r\n        let height = this.canvasHeight;\r\n        if (cameraViewMatrix) {\r\n            this.borders.xMin = width+1;\r\n            this.borders.xMax = -1;\r\n            this.borders.yMin = height+1;\r\n            this.borders.yMax = -1;\r\n\r\n            // Set the width and height of the viewport\r\n            let screenW = width/(width*Math.sqrt(width/height));\r\n            let screenH = height/(width*Math.sqrt(width/height));\r\n\r\n            for (let i = 0; i < this.vertices.length; ++i) {\r\n                // Take one point from a local coordinate system\r\n                let screenCoordinates = this.vertices[i];\r\n                // Transform the local coordinate system point to the world coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(modelViewMatrix, screenCoordinates);\r\n                // Transform this point to the cameras local coordinate system\r\n                screenCoordinates = Matrix4.multiplyVector(camera.transform.matrix, screenCoordinates);\r\n\r\n                // Compute the coordinates from camera space onto the canvas by using perspective projection\r\n                // px = x/(-z), py = y/(-z)\r\n                let px = (screenCoordinates[0]/(-screenCoordinates[2]));\r\n                let py = (screenCoordinates[1]/(-screenCoordinates[2]));\r\n\r\n                // Convert coordinates from screen space to raster space (Normalized Device Coordinates)\r\n                let pxNormalized = (px+(screenW/2)) / screenW;\r\n                let pyNormalized = (py+(screenH/2)) / screenH;\r\n\r\n                // Covert to pixel coordinates (Raster space)\r\n                let pxRaster = Math.floor(pxNormalized * width);\r\n                let pyRaster = Math.floor((1-pyNormalized) * height);\r\n\r\n                if (pxRaster < 0)\r\n                    pxRaster = 0;\r\n                else if (pxRaster > width)\r\n                    pxRaster = width;\r\n                if (pyRaster < 0)\r\n                    pyRaster = 0;\r\n                else if (pyRaster > height)\r\n                    pyRaster = height;\r\n\r\n                if (pxRaster < this.borders.xMin) {\r\n                    this.borders.xMin = pxRaster;\r\n                }\r\n                else if (pxRaster > this.borders.xMax) {\r\n                    this.borders.xMax = pxRaster;\r\n                }\r\n\r\n                if (pyRaster < this.borders.yMin) {\r\n                    this.borders.yMin = pyRaster;\r\n                }\r\n                else if (pyRaster > this.borders.yMax) {\r\n                    this.borders.yMax = pyRaster;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default IntersectionField;"]},"metadata":{},"sourceType":"module"}