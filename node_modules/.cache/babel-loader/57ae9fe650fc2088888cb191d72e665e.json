{"ast":null,"code":"import SphereCollider from \"./SphereCollider\";\nimport Vector3 from \"./math/Vector3\";\nimport Raycast from \"./Raycast\";\nimport CollisionManager from \"./CollisionManager\";\n\nclass RigidBody {\n  constructor(position, mass = 1.0) {\n    this.id = -1;\n    this.position = new Vector3(position);\n    this.velocity = new Vector3([0.0, 0.0, 0.0]);\n    this.acceleration = new Vector3([0.0, 0.0, 0.0]);\n    this.angularVelocity = new Vector3([0.0, 0.0, 0.0]);\n    this.rotation = new Vector3([0.0, 0.0, 0.0]);\n    this.rotationAxis = new Vector3([0.0, 0.0, 0.0]);\n    this.rotationSpeed = 0.0;\n    this.collider = new SphereCollider();\n    this.mass = mass;\n    this.enableGravity(true);\n  }\n\n  setAngularVelocity(angularVel) {\n    this.angularVelocity.set(angularVel);\n  }\n\n  setVelocity(vel) {\n    this.velocity.set(vel);\n  }\n\n  setAcceleration(acc) {\n    this.acceleration.set(acc);\n  }\n\n  setPosition(pos) {\n    this.position.set(pos);\n  }\n\n  enableGravity(state) {\n    if (state) this.gravity = 9.82;else this.gravity = 0.0;\n  }\n\n  update(timeStep) {\n    this.updateMotion(timeStep);\n    this.handlePlaneCollisions(timeStep);\n    this.scanForBodyCollisions(timeStep);\n  }\n\n  updateMotion(timeStep) {\n    this.velocity.set([this.velocity.x + this.acceleration.x * timeStep, this.velocity.y + (this.acceleration.y - this.gravity) * timeStep, this.velocity.z + this.acceleration.z * timeStep]);\n    this.position.set([this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep]);\n    this.rotation.set([this.rotation.x + this.angularVelocity.x * timeStep, this.rotation.y + this.angularVelocity.y * timeStep, this.rotation.z + this.angularVelocity.z * timeStep]);\n  }\n\n  handlePlaneCollisions(timeStep) {\n    let planes = CollisionManager.getPlaneColliders();\n    let rayDir = this.velocity.normalized();\n    let rayOrigin = this.position.clone(); // Find closest intersectionPoint\n\n    planes.forEach(plane => {\n      // If the plane intersection test returns null, no plane was found\n      let intersectionPoint = Raycast.planeIntersectionTest(rayDir, rayOrigin, plane);\n\n      if (intersectionPoint !== null) {\n        // Calculate the closest distance from the rigid body collider and the plane\n        let distanceToPlane = Vector3.dot(plane.normal, Vector3.subtract(rayOrigin, intersectionPoint)); // Check if the sphere is intersecting the plane\n\n        if (distanceToPlane < this.collider.radius) {\n          // Move the object to the plane surface\n          let diff = this.collider.radius - distanceToPlane;\n          this.position.set([this.position.x + plane.normal.x * diff, this.position.y + plane.normal.y * diff, this.position.z + plane.normal.z * diff]); // Calculate the reflected velocity\n\n          let bounce = this.velocity.magnitude * 0.75;\n          let reflectDirection = Vector3.subtract(plane.normal.clone().multipleBy(2.0 * Vector3.dot(plane.normal, rayDir)), rayDir); // Apply new velocity and position\n\n          this.velocity.set([-reflectDirection.x * bounce, -reflectDirection.y * bounce, -reflectDirection.z * bounce]);\n          this.position.set([this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep]);\n          let frictionDirection = Vector3.crossProduct(plane.normal, Vector3.crossProduct(reflectDirection, plane.normal)).inverted();\n          let rotAxis = Vector3.crossProduct(frictionDirection, plane.normal);\n          let rotationSpeed = bounce;\n          this.rotationAxis.set([rotAxis.x, rotAxis.y, rotAxis.z]);\n          /*\r\n          this.angularVelocity.set([0.0, 0.0, 0.0]);\r\n          this.rotation.set([\r\n              this.rotation.x + this.angularVelocity.x * timeStep,\r\n              this.rotation.y + this.angularVelocity.y * timeStep,\r\n              this.rotation.z + this.angularVelocity.z * timeStep,\r\n          ]);\r\n          */\n        }\n      }\n    });\n  }\n\n  scanForBodyCollisions(timeStep) {\n    // If the rigid body is not moving, don't check for target collisions\n    if (this.velocity.magnitude < 0.1) {\n      return;\n    } //TODO: Optimize collision scanning (if two bodies have collided, we dont need to check collision again in this update\n    // Example: Sum ids of two bodies on collision. We can then simply check if this.id + target.id == markedCollision.\n\n\n    let rigidBodies = CollisionManager.getRigidBodies();\n    rigidBodies.forEach(target => {\n      // Don't check for collision with self\n      if (this.id !== target.id) {\n        // Compute the distance between the two sphere colliders\n        let targetDistance = Vector3.distance(target.position, this.position); // If the distance is within this collider radius and target collider radius, we have a collision\n\n        if (targetDistance < target.collider.radius + this.collider.radius) {\n          this.handleBodyCollision(timeStep, target, targetDistance);\n        }\n      }\n    });\n  }\n\n  handleBodyCollision(timeStep, target, targetDistance) {\n    // Get velocity directions\n    let thisVelocityDirection = this.velocity.normalized();\n    let targetVelocityDirection = target.velocity.normalized(); // Move the body outside of collision area\n\n    let diff = this.collider.radius + target.collider.radius - targetDistance;\n    this.position.set([this.position.x - thisVelocityDirection.x * diff, this.position.y - thisVelocityDirection.y * diff, this.position.z - thisVelocityDirection.z * diff]); // Compute new velocity directions (given by the normal of the collision point's tangent plane)\n\n    let thisTangentNormal = Vector3.subtract(target.position, this.position).normalized();\n    let targetTangentNormal = thisTangentNormal.inverted(); // Compute a multiplier based on the angle between the before and after velocities.\n    // Wider angles results in lesser impact (lower multipliers)\n\n    let thisMultiplier = Math.abs(Vector3.dot(thisVelocityDirection, thisTangentNormal));\n    let targetMultiplier = Math.abs(Vector3.dot(targetVelocityDirection, targetTangentNormal)); // Compute the speeds before collision\n\n    let thisSpeedBefore = this.velocity.magnitude * 0.9;\n    let targetSpeedBefore = target.velocity.magnitude * 0.9; // Compute elastic Collision Coefficients\n\n    let A = Math.abs(thisMultiplier * this.mass - target.mass) / (thisMultiplier * this.mass + target.mass);\n    let B = 2.0 * target.mass / (this.mass + target.mass); // Set new velocity and position\n\n    this.velocity.set([(targetTangentNormal.x * (1.0 - thisMultiplier) + thisVelocityDirection.x * thisMultiplier) * thisSpeedBefore * A + targetTangentNormal.x * targetSpeedBefore * B, (targetTangentNormal.y * (1.0 - thisMultiplier) + thisVelocityDirection.y * thisMultiplier) * thisSpeedBefore * A + targetTangentNormal.y * targetSpeedBefore * B, (targetTangentNormal.z * (1.0 - thisMultiplier) + thisVelocityDirection.z * thisMultiplier) * thisSpeedBefore * A + targetTangentNormal.z * targetSpeedBefore * B]);\n    this.position.set([this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep]); // Compute elastic Collision Coefficients\n\n    A = 2.0 * this.mass / (this.mass + target.mass);\n    B = Math.abs(targetMultiplier * target.mass - this.mass) / (this.mass + targetMultiplier * target.mass); // Set new velocity for the target\n\n    target.velocity.set([thisTangentNormal.x * thisSpeedBefore * A + (thisTangentNormal.x * (1.0 - targetMultiplier) + targetVelocityDirection.x * targetMultiplier) * targetSpeedBefore * B, thisTangentNormal.y * thisSpeedBefore * A + (thisTangentNormal.y * (1.0 - targetMultiplier) + targetVelocityDirection.y * targetMultiplier) * targetSpeedBefore * B, thisTangentNormal.z * thisSpeedBefore * A + (thisTangentNormal.z * (1.0 - targetMultiplier) + targetVelocityDirection.z * targetMultiplier) * targetSpeedBefore * B]);\n  }\n\n}\n\nexport default RigidBody;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\RigidBody.js"],"names":["SphereCollider","Vector3","Raycast","CollisionManager","RigidBody","constructor","position","mass","id","velocity","acceleration","angularVelocity","rotation","rotationAxis","rotationSpeed","collider","enableGravity","setAngularVelocity","angularVel","set","setVelocity","vel","setAcceleration","acc","setPosition","pos","state","gravity","update","timeStep","updateMotion","handlePlaneCollisions","scanForBodyCollisions","x","y","z","planes","getPlaneColliders","rayDir","normalized","rayOrigin","clone","forEach","plane","intersectionPoint","planeIntersectionTest","distanceToPlane","dot","normal","subtract","radius","diff","bounce","magnitude","reflectDirection","multipleBy","frictionDirection","crossProduct","inverted","rotAxis","rigidBodies","getRigidBodies","target","targetDistance","distance","handleBodyCollision","thisVelocityDirection","targetVelocityDirection","thisTangentNormal","targetTangentNormal","thisMultiplier","Math","abs","targetMultiplier","thisSpeedBefore","targetSpeedBefore","A","B"],"mappings":"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","sourcesContent":["import SphereCollider from \"./SphereCollider\";\r\nimport Vector3 from \"./math/Vector3\";\r\nimport Raycast from \"./Raycast\";\r\nimport CollisionManager from \"./CollisionManager\";\r\n\r\nclass RigidBody {\r\n    constructor(position, mass = 1.0) {\r\n        this.id = -1;\r\n        this.position = new Vector3(position);\r\n        this.velocity = new Vector3([0.0, 0.0, 0.0]);\r\n        this.acceleration = new Vector3([0.0, 0.0, 0.0]);\r\n\r\n        this.angularVelocity = new Vector3([0.0, 0.0, 0.0]);\r\n        this.rotation = new Vector3([0.0, 0.0, 0.0]);\r\n        this.rotationAxis = new Vector3([0.0, 0.0, 0.0]);\r\n        this.rotationSpeed = 0.0;\r\n\r\n        this.collider = new SphereCollider();\r\n\r\n        this.mass = mass;\r\n        this.enableGravity(true);\r\n    }\r\n\r\n    setAngularVelocity(angularVel) {\r\n        this.angularVelocity.set(angularVel);\r\n    }\r\n\r\n    setVelocity(vel) {\r\n        this.velocity.set(vel);\r\n    }\r\n\r\n    setAcceleration(acc) {\r\n        this.acceleration.set(acc);\r\n    }\r\n\r\n    setPosition(pos) {\r\n        this.position.set(pos);\r\n    }\r\n\r\n    enableGravity(state) {\r\n        if (state)\r\n            this.gravity = 9.82;\r\n        else\r\n            this.gravity = 0.0;\r\n    }\r\n\r\n    update(timeStep) {\r\n        this.updateMotion(timeStep);\r\n        this.handlePlaneCollisions(timeStep);\r\n        this.scanForBodyCollisions(timeStep);\r\n    }\r\n\r\n    updateMotion(timeStep) {\r\n        this.velocity.set([\r\n            this.velocity.x + this.acceleration.x * timeStep,\r\n            this.velocity.y + (this.acceleration.y - this.gravity) * timeStep,\r\n            this.velocity.z + this.acceleration.z * timeStep,\r\n        ]);\r\n        this.position.set([\r\n            this.position.x + this.velocity.x * timeStep,\r\n            this.position.y + this.velocity.y * timeStep,\r\n            this.position.z + this.velocity.z * timeStep,\r\n        ]);\r\n\r\n        this.rotation.set([\r\n            this.rotation.x + this.angularVelocity.x * timeStep,\r\n            this.rotation.y + this.angularVelocity.y * timeStep,\r\n            this.rotation.z + this.angularVelocity.z * timeStep,\r\n        ]);\r\n    }\r\n\r\n    handlePlaneCollisions(timeStep) {\r\n        let planes = CollisionManager.getPlaneColliders();\r\n\r\n        let rayDir = this.velocity.normalized();\r\n        let rayOrigin = this.position.clone();\r\n\r\n        // Find closest intersectionPoint\r\n        planes.forEach((plane) => {\r\n            // If the plane intersection test returns null, no plane was found\r\n            let intersectionPoint = Raycast.planeIntersectionTest(rayDir, rayOrigin, plane);\r\n            if (intersectionPoint !== null) {\r\n                // Calculate the closest distance from the rigid body collider and the plane\r\n                let distanceToPlane = Vector3.dot(plane.normal, Vector3.subtract(rayOrigin, intersectionPoint));\r\n\r\n                // Check if the sphere is intersecting the plane\r\n                if (distanceToPlane < this.collider.radius) {\r\n                    // Move the object to the plane surface\r\n                    let diff = (this.collider.radius - distanceToPlane);\r\n                    this.position.set([\r\n                        this.position.x + plane.normal.x * diff,\r\n                        this.position.y + plane.normal.y * diff,\r\n                        this.position.z + plane.normal.z * diff\r\n                    ]);\r\n\r\n                    // Calculate the reflected velocity\r\n                    let bounce = this.velocity.magnitude*0.75;\r\n                    let reflectDirection = Vector3.subtract(plane.normal.clone().multipleBy(2.0 * Vector3.dot(plane.normal, rayDir)), rayDir);\r\n\r\n                    // Apply new velocity and position\r\n                    this.velocity.set([\r\n                        -reflectDirection.x*bounce,\r\n                        -reflectDirection.y*bounce,\r\n                        -reflectDirection.z*bounce\r\n                    ]);\r\n                    this.position.set([\r\n                        this.position.x + this.velocity.x * timeStep,\r\n                        this.position.y + this.velocity.y * timeStep,\r\n                        this.position.z + this.velocity.z * timeStep,\r\n                    ]);\r\n\r\n                    let frictionDirection = (Vector3.crossProduct(plane.normal,Vector3.crossProduct(reflectDirection, plane.normal))).inverted();\r\n                    let rotAxis = Vector3.crossProduct(frictionDirection, plane.normal);\r\n                    let rotationSpeed = bounce;\r\n                    this.rotationAxis.set([rotAxis.x, rotAxis.y, rotAxis.z]);\r\n\r\n                    /*\r\n                    this.angularVelocity.set([0.0, 0.0, 0.0]);\r\n                    this.rotation.set([\r\n                        this.rotation.x + this.angularVelocity.x * timeStep,\r\n                        this.rotation.y + this.angularVelocity.y * timeStep,\r\n                        this.rotation.z + this.angularVelocity.z * timeStep,\r\n                    ]);\r\n                    */\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    scanForBodyCollisions(timeStep) {\r\n        // If the rigid body is not moving, don't check for target collisions\r\n        if (this.velocity.magnitude < 0.1) {\r\n            return;\r\n        }\r\n\r\n        //TODO: Optimize collision scanning (if two bodies have collided, we dont need to check collision again in this update\r\n        // Example: Sum ids of two bodies on collision. We can then simply check if this.id + target.id == markedCollision.\r\n\r\n        let rigidBodies = CollisionManager.getRigidBodies();\r\n        rigidBodies.forEach((target) => {\r\n            // Don't check for collision with self\r\n            if (this.id !== target.id){\r\n                // Compute the distance between the two sphere colliders\r\n                let targetDistance = Vector3.distance(target.position, this.position);\r\n                // If the distance is within this collider radius and target collider radius, we have a collision\r\n                if (targetDistance < (target.collider.radius + this.collider.radius)) {\r\n                    this.handleBodyCollision(timeStep, target, targetDistance);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    handleBodyCollision(timeStep, target, targetDistance) {\r\n        // Get velocity directions\r\n        let thisVelocityDirection = this.velocity.normalized();\r\n        let targetVelocityDirection = target.velocity.normalized();\r\n\r\n        // Move the body outside of collision area\r\n        let diff = (this.collider.radius + target.collider.radius) - targetDistance;\r\n        this.position.set([\r\n            this.position.x - thisVelocityDirection.x * diff,\r\n            this.position.y - thisVelocityDirection.y * diff,\r\n            this.position.z - thisVelocityDirection.z * diff\r\n        ]);\r\n\r\n        // Compute new velocity directions (given by the normal of the collision point's tangent plane)\r\n        let thisTangentNormal = Vector3.subtract(target.position, this.position).normalized();\r\n        let targetTangentNormal = thisTangentNormal.inverted();\r\n\r\n        // Compute a multiplier based on the angle between the before and after velocities.\r\n        // Wider angles results in lesser impact (lower multipliers)\r\n        let thisMultiplier = Math.abs(Vector3.dot(thisVelocityDirection, thisTangentNormal));\r\n        let targetMultiplier = Math.abs(Vector3.dot(targetVelocityDirection, targetTangentNormal));\r\n\r\n        // Compute the speeds before collision\r\n        let thisSpeedBefore = this.velocity.magnitude * 0.9;\r\n        let targetSpeedBefore = target.velocity.magnitude * 0.9;\r\n\r\n        // Compute elastic Collision Coefficients\r\n        let A = (Math.abs(thisMultiplier * this.mass - target.mass)) / (thisMultiplier * this.mass + target.mass);\r\n        let B = (2.0 * target.mass) / (this.mass + target.mass);\r\n\r\n        // Set new velocity and position\r\n        this.velocity.set([\r\n            ((targetTangentNormal.x * (1.0 - thisMultiplier) + thisVelocityDirection.x * thisMultiplier) * thisSpeedBefore * A) + (targetTangentNormal.x * targetSpeedBefore * B),\r\n            ((targetTangentNormal.y * (1.0 - thisMultiplier) + thisVelocityDirection.y * thisMultiplier) * thisSpeedBefore * A) + (targetTangentNormal.y * targetSpeedBefore * B),\r\n            ((targetTangentNormal.z * (1.0 - thisMultiplier) + thisVelocityDirection.z * thisMultiplier) * thisSpeedBefore * A) + (targetTangentNormal.z * targetSpeedBefore * B)\r\n        ]);\r\n        this.position.set([\r\n            this.position.x + this.velocity.x * timeStep,\r\n            this.position.y + this.velocity.y * timeStep,\r\n            this.position.z + this.velocity.z * timeStep,\r\n        ]);\r\n\r\n        // Compute elastic Collision Coefficients\r\n        A = (2.0 * this.mass) / (this.mass + target.mass);\r\n        B = (Math.abs(targetMultiplier * target.mass - this.mass)) / (this.mass + targetMultiplier * target.mass);\r\n\r\n        // Set new velocity for the target\r\n        target.velocity.set([\r\n            (thisTangentNormal.x * thisSpeedBefore * A) + ((thisTangentNormal.x * (1.0 - targetMultiplier) + targetVelocityDirection.x * targetMultiplier) * targetSpeedBefore * B),\r\n            (thisTangentNormal.y * thisSpeedBefore * A) + ((thisTangentNormal.y * (1.0 - targetMultiplier) + targetVelocityDirection.y * targetMultiplier) * targetSpeedBefore * B),\r\n            (thisTangentNormal.z * thisSpeedBefore * A) + ((thisTangentNormal.z * (1.0 - targetMultiplier) + targetVelocityDirection.z * targetMultiplier) * targetSpeedBefore * B)\r\n        ]);\r\n    }\r\n}\r\n\r\nexport default RigidBody;"]},"metadata":{},"sourceType":"module"}