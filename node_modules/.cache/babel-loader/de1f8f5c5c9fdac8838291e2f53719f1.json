{"ast":null,"code":"class ShapeGenerator {\n  constructor() {}\n\n  static generateCubeData(x = 1.0, y = 1.0, z = 1.0) {\n    // Vertex coordinates, normals and texture coordinates\n    let vertexArray = [// Vertex         Normal             Texture coordinates\n    // Vertex 0\n    -x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, // Vertex 1\n    -x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, -y, z, -1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 2\n    x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, -y, z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 3\n    x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, -y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 4\n    -x, y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, -x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 5\n    -x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, y, z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 6\n    x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, y, z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 7\n    x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0]; // Vertex indices\n\n    let indexArray = [// Bottom\n    0, 9, 6, // v0, v3, v2\n    6, 3, 0, // v2, v1, v0\n    // Front\n    4, 7, 18, // v1, v2, v6\n    18, 15, 4, // v6, v5, v1\n    // Left\n    1, 5, 16, // v0, v1, v5\n    16, 12, 1, // v5, v4, v0\n    // Back\n    2, 13, 21, // v0, v4, v7\n    21, 10, 2, // v7, v3, v0\n    // Right\n    8, 11, 22, // v2, v3, v7\n    22, 19, 8, // v7, v6, v2\n    // Top\n    14, 17, 20, // v4, v5, v6\n    20, 23, 14 // v6, v7, v4\n    ];\n    let totalTriangles = 12;\n    let totalVertices = totalTriangles * 3;\n    return {\n      numVertices: totalVertices,\n      vertices: vertexArray,\n      indices: indexArray\n    };\n  }\n\n  static generateSphere(segments, radius) {\n    let numHorizontalSegments = segments; // Minium amount of horizontal segments is 2\n\n    if (numHorizontalSegments < 2) {\n      numHorizontalSegments = 2;\n    } // Number of vertical segments of the sphere\n\n\n    let numVerticalSegments = 2 * numHorizontalSegments;\n    let numVertices = 1 + (numHorizontalSegments - 1) * numVerticalSegments + 1; // top + middle + bottom\n\n    let numTriangles = numVerticalSegments + (numHorizontalSegments - 2) * 4 * numHorizontalSegments + numVerticalSegments; // top + middle + bottom\n    // Floats per row: position(x,y,z), normal(x,y,z), texture(s,t)\n\n    let stride = 8;\n    console.log(\"Vertices size: \" + numVertices * stride);\n    let vertices = []; // Initialize vertex array\n\n    console.log(\"Indices size: \" + numTriangles * 3);\n    let indices = []; // Initialize index array\n\n    /** Generate vertex array **/\n    // Bottom vertex\n\n    vertices[0] = 0.0;\n    vertices[1] = -radius;\n    vertices[2] = 0.0; // Coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Normal\n\n    vertices[6] = 0.5;\n    vertices[7] = 0.0;\n    const PI = 3.14159265359;\n    let sampleRate = PI / numHorizontalSegments; // Number of steps\n\n    let theta = -PI + sampleRate; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let phi = 0.0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n    // Generate middle part vertices with normals\n\n    let index = stride - 1; // Skip first 7 (the bottom vertex with normal and texture coordinates already specified)\n\n    for (let i = 0; i < numHorizontalSegments - 1; ++i) {\n      let Y = Math.cos(theta); // Y-coordinate\n\n      let R = Math.sin(theta); // XZ-plane\n\n      phi = 0.0;\n\n      for (let j = 0; j < numVerticalSegments; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = radius * R * Math.sin(phi);\n        vertices[++index] = radius * Y;\n        vertices[++index] = radius * R * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = Y;\n        vertices[++index] = R * Math.cos(phi); // Texture Coordinates (s, t)\n\n        vertices[++index] = phi / (2.0 * PI);\n        vertices[++index] = 1.0 + theta / PI;\n        phi += sampleRate;\n      }\n\n      theta += sampleRate;\n    } // Top vertex\n\n\n    vertices[++index] = 0.0;\n    vertices[++index] = radius;\n    vertices[++index] = 0.0; // Coordinates\n\n    vertices[++index] = 0.0;\n    vertices[++index] = 1.0;\n    vertices[++index] = 0.0; // Normal\n\n    vertices[++index] = 0.5;\n    vertices[++index] = 1.0;\n    /** Generate index array */\n    // Bottom cap\n\n    index = -1;\n\n    for (let i = 0; i < numVerticalSegments; ++i) {\n      indices[++index] = 0;\n\n      if (i + 2 <= numVerticalSegments) {\n        indices[++index] = i + 2;\n      } else {\n        indices[++index] = i + 2 - numVerticalSegments;\n      }\n\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = 1;\n\n    for (let i = 0; i < numHorizontalSegments - 2; i++) {\n      for (let j = 0; j < numVerticalSegments - 1; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = numVerticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = numVerticalSegments + v0 + 1;\n        indices[++index] = numVerticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - numVerticalSegments;\n      indices[++index] = numVerticalSegments + v0;\n      indices[++index] = v0 + 1 - numVerticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = numVerticalSegments + v0;\n      ++v0;\n    } // Top cap\n\n\n    let lastVertexIndex = numVertices - 1;\n\n    for (let i = 0; i < numVerticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - numVerticalSegments) {\n        indices[++index] = lastVertexIndex - 2 - i;\n      } else {\n        indices[++index] = lastVertexIndex - numVerticalSegments - 1;\n      }\n\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    indices[numTriangles * 3 - 2] = lastVertexIndex - 1;\n  }\n\n  static generateSphereData(segments) {\n    let horizontalSegments = segments;\n\n    if (horizontalSegments < 2) {\n      horizontalSegments = 2;\n    }\n\n    let verticalSegments = 2 * horizontalSegments;\n    let vertices = []; // Bottom vertex and its normal (x, y, z)\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0;\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0;\n    vertices[6] = 0.0;\n    vertices[7] = 0.0;\n    let sampleResolution = Math.PI / horizontalSegments;\n    let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n    // Generate middle part vertices with normals\n\n    let index = 7;\n\n    for (let i = 0; i < horizontalSegments - 1; ++i) {\n      let y = Math.cos(theta);\n      let R = Math.sin(theta); // radius\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += sampleResolution;\n      }\n\n      theta += sampleResolution;\n    } // Top vertex and its normal (x, y, z)\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom cap\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = 1;\n\n    for (let i = 0; i < horizontalSegments - 2; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top cap\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static generateCylinderData(vertSeg, horizSeg) {\n    let horizontalSegments = horizSeg;\n    let verticalSegments = vertSeg;\n\n    if (horizontalSegments < 1) {\n      horizontalSegments = 1;\n    }\n\n    if (verticalSegments < 4) {\n      verticalSegments = 4;\n    }\n\n    let vertices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.0;\n    vertices[7] = 0.0; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -Math.PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0;\n    let index = 7; // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = -1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0; // Generate middle part vertices with normals\n\n    for (let i = 0; i <= horizontalSegments; ++i) {\n      let y = Math.cos(theta);\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += 2 * Math.PI / verticalSegments;\n      }\n\n      theta += Math.PI / horizontalSegments;\n    }\n\n    phi = 0; // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = 1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = verticalSegments + 2;\n\n    for (let i = 0; i < horizontalSegments; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top circle plane\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n}\n\nexport default ShapeGenerator;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\ShapeGenerator.js"],"names":["ShapeGenerator","constructor","generateCubeData","x","y","z","vertexArray","indexArray","totalTriangles","totalVertices","numVertices","vertices","indices","generateSphere","segments","radius","numHorizontalSegments","numVerticalSegments","numTriangles","stride","console","log","PI","sampleRate","theta","phi","index","i","Y","Math","cos","R","sin","j","v0","lastVertexIndex","generateSphereData","horizontalSegments","verticalSegments","sampleResolution","length","generateCylinderData","vertSeg","horizSeg"],"mappings":"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","sourcesContent":["class ShapeGenerator {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    static generateCubeData(x = 1.0, y = 1.0, z = 1.0) {\r\n        // Vertex coordinates, normals and texture coordinates\r\n        let vertexArray = [\r\n            // Vertex         Normal             Texture coordinates\r\n            // Vertex 0\r\n            -x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n\r\n            // Vertex 1\r\n            -x, -y,  z,     0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y,  z,     0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, -y,  z,    -1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 2\r\n            x, -y,  z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y,  z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, -y,  z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 3\r\n            x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, -y, -z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 4\r\n            -x, y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 5\r\n            -x, y, z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, y, z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 6\r\n            x, y, z,       0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, y, z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, z,       0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 7\r\n            x, y, -z,       0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, y, -z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, -z,       0.0,  1.0,  0.0,      0.0, 0.0\r\n        ];\r\n\r\n        // Vertex indices\r\n        let indexArray = [\t// Bottom\r\n            0, 9, 6,  // v0, v3, v2\r\n            6, 3, 0,  // v2, v1, v0\r\n\r\n            // Front\r\n            4, 7, 18,  // v1, v2, v6\r\n            18, 15, 4, // v6, v5, v1\r\n\r\n            // Left\r\n            1, 5, 16,  // v0, v1, v5\r\n            16, 12, 1, // v5, v4, v0\r\n\r\n            // Back\r\n            2, 13, 21, // v0, v4, v7\r\n            21, 10, 2, // v7, v3, v0\r\n\r\n            // Right\r\n            8, 11, 22, // v2, v3, v7\r\n            22, 19, 8, // v7, v6, v2\r\n\r\n            // Top\r\n            14, 17, 20, // v4, v5, v6\r\n            20, 23, 14  // v6, v7, v4\r\n        ];\r\n\r\n        let totalTriangles = 12;\r\n        let totalVertices = totalTriangles*3;\r\n\r\n        return {\r\n            numVertices: totalVertices,\r\n            vertices: vertexArray,\r\n            indices: indexArray\r\n        };\r\n    }\r\n\r\n    static generateSphere(segments, radius) {\r\n\r\n        let numHorizontalSegments = segments;\r\n        // Minium amount of horizontal segments is 2\r\n        if (numHorizontalSegments < 2) {\r\n            numHorizontalSegments = 2;\r\n        }\r\n\r\n        // Number of vertical segments of the sphere\r\n        let numVerticalSegments = 2 * numHorizontalSegments;\r\n        let numVertices = 1 + (numHorizontalSegments - 1) * numVerticalSegments + 1; // top + middle + bottom\r\n        let numTriangles = numVerticalSegments + (numHorizontalSegments - 2) * 4 * numHorizontalSegments + numVerticalSegments; // top + middle + bottom\r\n\r\n        // Floats per row: position(x,y,z), normal(x,y,z), texture(s,t)\r\n        let stride = 8;\r\n        console.log(\"Vertices size: \" + (numVertices * stride));\r\n        let vertices = []; // Initialize vertex array\r\n        console.log(\"Indices size: \" + (numTriangles * 3));\r\n        let indices = []; // Initialize index array\r\n\r\n        /** Generate vertex array **/\r\n        // Bottom vertex\r\n        vertices[0] = 0.0; vertices[1] = -radius; vertices[2] = 0.0; // Coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0;    vertices[5] = 0.0; // Normal\r\n        vertices[6] = 0.5; vertices[7] = 0.0;\r\n\r\n        const PI = 3.14159265359;\r\n        let sampleRate = PI / numHorizontalSegments; // Number of steps\r\n        let theta = -PI + sampleRate; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let  phi = 0.0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = stride - 1; // Skip first 7 (the bottom vertex with normal and texture coordinates already specified)\r\n        for (let i = 0; i < (numHorizontalSegments - 1); ++i) {\r\n            let Y = Math.cos(theta); // Y-coordinate\r\n            let R = Math.sin(theta); // XZ-plane\r\n\r\n            phi = 0.0;\r\n            for (let j = 0; j < numVerticalSegments; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = radius * R * Math.sin(phi);\r\n                vertices[++index] = radius * Y;\r\n                vertices[++index] = radius * R * Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R * Math.sin(phi);\r\n                vertices[++index] = Y;\r\n                vertices[++index] = R * Math.cos(phi);\r\n                // Texture Coordinates (s, t)\r\n                vertices[++index] = phi / (2.0 * PI);\r\n                vertices[++index] = 1.0 + (theta / PI);\r\n\r\n                phi += sampleRate;\r\n            }\r\n            theta += sampleRate;\r\n        }\r\n\r\n        // Top vertex\r\n        vertices[++index] = 0.0; vertices[++index] = radius; vertices[++index] = 0.0; // Coordinates\r\n        vertices[++index] = 0.0; vertices[++index] = 1.0;    vertices[++index] = 0.0; // Normal\r\n        vertices[++index] = 0.5; vertices[++index] = 1.0;\r\n\r\n        /** Generate index array */\r\n        // Bottom cap\r\n        index = -1;\r\n        for (let i = 0; i < numVerticalSegments; ++i) {\r\n            indices[++index] = 0;\r\n            if ((i + 2) <= numVerticalSegments) {\r\n                indices[++index] = i + 2;\r\n            }\r\n            else {\r\n                indices[++index] = (i + 2) - numVerticalSegments;\r\n            }\r\n            indices[++index] = i + 1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for (let i = 0; i < (numHorizontalSegments - 2); i++) {\r\n            for (let j = 0; j < (numVerticalSegments - 1); ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - numVerticalSegments;\r\n            indices[++index] = numVerticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - numVerticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = numVerticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top cap\r\n        let lastVertexIndex = numVertices - 1;\r\n        for (let i = 0; i < numVerticalSegments; ++i) {\r\n            indices[++index] = lastVertexIndex;\r\n            if ((lastVertexIndex - 2 - i) >= lastVertexIndex - numVerticalSegments) {\r\n                indices[++index] = lastVertexIndex - 2 - i;\r\n            }\r\n            else {\r\n                indices[++index] = lastVertexIndex - numVerticalSegments - 1;\r\n            }\r\n            indices[++index] = lastVertexIndex - 1 - i;\r\n        }\r\n        indices[(numTriangles * 3) - 2] = (lastVertexIndex - 1);\r\n    }\r\n\r\n    static generateSphereData(segments) {\r\n        let horizontalSegments = segments;\r\n\r\n        if (horizontalSegments < 2) {\r\n            horizontalSegments = 2;\r\n        }\r\n        let verticalSegments = 2*horizontalSegments;\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom vertex and its normal (x, y, z)\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        let sampleResolution = Math.PI/horizontalSegments;\r\n        let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = 7;\r\n        for(let i = 0; i < horizontalSegments-1; ++i) {\r\n            let y = Math.cos(theta);\r\n            let R = Math.sin(theta); // radius\r\n\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += sampleResolution;\r\n            }\r\n            theta += sampleResolution;\r\n        }\r\n\r\n        // Top vertex and its normal (x, y, z)\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom cap\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for(let i = 0; i < horizontalSegments-2; i++) {\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top cap\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static generateCylinderData (vertSeg, horizSeg) {\r\n        let horizontalSegments = horizSeg;\r\n        let verticalSegments = vertSeg;\r\n\r\n        if (horizontalSegments < 1) {\r\n            horizontalSegments = 1;\r\n        }\r\n        if (verticalSegments < 4) {\r\n            verticalSegments = 4;\r\n        }\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -Math.PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0;\r\n\r\n        let index = 7;\r\n        // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0;\r\n        // Generate middle part vertices with normals\r\n        for(let i = 0; i <= horizontalSegments; ++i) {\r\n\r\n            let y = Math.cos(theta);\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += (2*Math.PI)/verticalSegments;\r\n            }\r\n            theta += Math.PI/horizontalSegments;\r\n        }\r\n\r\n        phi = 0;\r\n        // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = verticalSegments+2;\r\n        for(let i = 0; i < horizontalSegments; i++) {\r\n\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n\r\n        // Top circle plane\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n}\r\n\r\nexport default ShapeGenerator;"]},"metadata":{},"sourceType":"module"}