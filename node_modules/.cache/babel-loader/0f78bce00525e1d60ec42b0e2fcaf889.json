{"ast":null,"code":"import SphereCollider from \"./SphereCollider\";\nimport Vector3 from \"./math/Vector3\";\nimport Raycast from \"./Raycast\";\nimport CollisionManager from \"./CollisionManager\";\n\nclass RigidBody {\n  constructor(position, mass = 1.0) {\n    this.id = -1;\n    this.position = new Vector3(position);\n    this.velocity = new Vector3([0.0, 0.0, 0.0]);\n    this.acceleration = new Vector3([0.0, 0.0, 0.0]);\n    this.collider = new SphereCollider();\n    this.mass = mass;\n    this.enableGravity(true);\n    this.inCollision = false;\n  }\n\n  setVelocity(vel) {\n    this.velocity.set(vel);\n  }\n\n  setAcceleration(acc) {\n    this.acceleration.set(acc);\n  }\n\n  setPosition(pos) {\n    this.position.set(pos);\n  }\n\n  enableGravity(state) {\n    if (state) this.gravity = 9.82;else this.gravity = 0.0;\n  }\n\n  get gravityIsEnabled() {\n    return this.gravity > 0.1;\n  }\n\n  update(timeStep) {\n    this.updateMotion(timeStep);\n    this.handlePlaneCollisions(timeStep);\n    this.handleBodyCollisions(timeStep);\n    return true;\n  }\n\n  updateMotion(timeStep) {\n    this.velocity.set([this.velocity.x + this.acceleration.x * timeStep, this.velocity.y + (this.acceleration.y - this.gravity) * timeStep, this.velocity.z + this.acceleration.z * timeStep]);\n    this.position.set([this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep]);\n  }\n\n  handlePlaneCollisions(timeStep) {\n    let planes = CollisionManager.getPlaneColliders();\n    let rayDir = this.velocity.normalized();\n    let rayOrigin = this.position.clone(); // Find closest intersectionPoint\n\n    planes.forEach(plane => {\n      // If the plane intersection test returns null, no plane was found\n      let intersectionPoint = Raycast.planeIntersectionTest(rayDir, rayOrigin, plane);\n\n      if (intersectionPoint !== null) {\n        // Calculate the closest distance from the rigid body collider and the plane\n        let distanceToPlane = Vector3.dot(plane.normal, Vector3.subtract(rayOrigin, intersectionPoint)); // Check if the sphere is intersecting the plane\n\n        if (distanceToPlane < this.collider.radius) {\n          // Move the object to the plane surface\n          let diff = this.collider.radius - distanceToPlane;\n          this.position.set([this.position.x + plane.normal.x * diff, this.position.y + plane.normal.y * diff, this.position.z + plane.normal.z * diff]); // Calculate the bounce velocity\n\n          let bounce = this.velocity.magnitude * 0.8;\n          let reflectDirection = Vector3.subtract(plane.normal.clone().multipleBy(2.0 * Vector3.dot(plane.normal, rayDir)), rayDir);\n          this.velocity.set([-reflectDirection.x * bounce, -reflectDirection.y * bounce, -reflectDirection.z * bounce]);\n          this.position.set([this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep]);\n        }\n      }\n    });\n  }\n\n  handleBodyCollisions(timeStep) {\n    if (this.velocity.magnitude < 0.1) {\n      return;\n    }\n\n    let sceneRigidBodies = CollisionManager.getRigidBodies();\n    sceneRigidBodies.forEach(target => {\n      // Check if other id is different from this id\n      if (this.id - target.id !== 0) {\n        //let targetDistance = Vector3.distance(target.position, this.position);\n        let toTargetVector = Vector3.subtract(target.position, this.position);\n        let targetDistance = toTargetVector.magnitude;\n\n        if (targetDistance < target.collider.radius + this.collider.radius) {\n          // Move the body outside of collision area\n          let diff = this.collider.radius + target.collider.radius - targetDistance;\n          let velocityDir = this.velocity.normalized();\n          this.position.set([this.position.x - velocityDir.x * diff, this.position.y - velocityDir.y * diff, this.position.z - velocityDir.z * diff]);\n          toTargetVector = Vector3.add(toTargetVector.normalized(), this.velocity.normalized()).normalized();\n          let speedBefore = this.velocity.magnitude * 0.75;\n          let targetSpeedBefore = target.velocity.magnitude * 0.75; // Calculate velocity after collision\n\n          let targetVelocityBefore = target.velocity.clone();\n          let denominator = this.mass + target.mass; // Elastic Collision Coefficients\n\n          let A = 2.0 * this.mass / denominator;\n          let B = (target.mass - this.mass) / denominator; // Set new velocity and position for target\n\n          target.velocity.set([toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B, toTargetVector.y * speedBefore * A - toTargetVector.y * targetSpeedBefore * B, toTargetVector.z * speedBefore * A - toTargetVector.z * targetSpeedBefore * B]);\n          target.position.set([target.position.x + target.velocity.x * timeStep, target.position.y + target.velocity.y * timeStep, target.position.z + target.velocity.z * timeStep]); // Elastic Collision Coefficients\n\n          A = (this.mass - target.mass) / denominator;\n          B = 2.0 * target.mass / denominator; // Set new velocity and position\n\n          this.velocity.set([toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B, toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B, toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B]);\n          this.position.set([this.position.x + this.velocity.x * timeStep, this.position.y + this.velocity.y * timeStep, this.position.z + this.velocity.z * timeStep]);\n        }\n      }\n    });\n  }\n\n}\n\nexport default RigidBody;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\RigidBody.js"],"names":["SphereCollider","Vector3","Raycast","CollisionManager","RigidBody","constructor","position","mass","id","velocity","acceleration","collider","enableGravity","inCollision","setVelocity","vel","set","setAcceleration","acc","setPosition","pos","state","gravity","gravityIsEnabled","update","timeStep","updateMotion","handlePlaneCollisions","handleBodyCollisions","x","y","z","planes","getPlaneColliders","rayDir","normalized","rayOrigin","clone","forEach","plane","intersectionPoint","planeIntersectionTest","distanceToPlane","dot","normal","subtract","radius","diff","bounce","magnitude","reflectDirection","multipleBy","sceneRigidBodies","getRigidBodies","target","toTargetVector","targetDistance","velocityDir","add","speedBefore","targetSpeedBefore","targetVelocityBefore","denominator","A","B"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;;AAEA,MAAMC,SAAN,CAAgB;AACZC,EAAAA,WAAW,CAACC,QAAD,EAAWC,IAAI,GAAG,GAAlB,EAAuB;AAC9B,SAAKC,EAAL,GAAU,CAAC,CAAX;AACA,SAAKF,QAAL,GAAgB,IAAIL,OAAJ,CAAYK,QAAZ,CAAhB;AACA,SAAKG,QAAL,GAAgB,IAAIR,OAAJ,CAAY,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAZ,CAAhB;AACA,SAAKS,YAAL,GAAoB,IAAIT,OAAJ,CAAY,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAZ,CAApB;AAEA,SAAKU,QAAL,GAAgB,IAAIX,cAAJ,EAAhB;AAEA,SAAKO,IAAL,GAAYA,IAAZ;AACA,SAAKK,aAAL,CAAmB,IAAnB;AAEA,SAAKC,WAAL,GAAmB,KAAnB;AACH;;AAEDC,EAAAA,WAAW,CAACC,GAAD,EAAM;AACb,SAAKN,QAAL,CAAcO,GAAd,CAAkBD,GAAlB;AACH;;AAEDE,EAAAA,eAAe,CAACC,GAAD,EAAM;AACjB,SAAKR,YAAL,CAAkBM,GAAlB,CAAsBE,GAAtB;AACH;;AAEDC,EAAAA,WAAW,CAACC,GAAD,EAAM;AACb,SAAKd,QAAL,CAAcU,GAAd,CAAkBI,GAAlB;AACH;;AAEDR,EAAAA,aAAa,CAACS,KAAD,EAAQ;AACjB,QAAIA,KAAJ,EACI,KAAKC,OAAL,GAAe,IAAf,CADJ,KAGI,KAAKA,OAAL,GAAe,GAAf;AACP;;AAED,MAAIC,gBAAJ,GAAwB;AACpB,WAAO,KAAKD,OAAL,GAAe,GAAtB;AACH;;AAEDE,EAAAA,MAAM,CAACC,QAAD,EAAW;AAEb,SAAKC,YAAL,CAAkBD,QAAlB;AACA,SAAKE,qBAAL,CAA2BF,QAA3B;AACA,SAAKG,oBAAL,CAA0BH,QAA1B;AAEA,WAAO,IAAP;AACH;;AAEDC,EAAAA,YAAY,CAACD,QAAD,EAAW;AACnB,SAAKhB,QAAL,CAAcO,GAAd,CAAkB,CACd,KAAKP,QAAL,CAAcoB,CAAd,GAAkB,KAAKnB,YAAL,CAAkBmB,CAAlB,GAAsBJ,QAD1B,EAEd,KAAKhB,QAAL,CAAcqB,CAAd,GAAkB,CAAC,KAAKpB,YAAL,CAAkBoB,CAAlB,GAAsB,KAAKR,OAA5B,IAAuCG,QAF3C,EAGd,KAAKhB,QAAL,CAAcsB,CAAd,GAAkB,KAAKrB,YAAL,CAAkBqB,CAAlB,GAAsBN,QAH1B,CAAlB;AAKA,SAAKnB,QAAL,CAAcU,GAAd,CAAkB,CACd,KAAKV,QAAL,CAAcuB,CAAd,GAAkB,KAAKpB,QAAL,CAAcoB,CAAd,GAAkBJ,QADtB,EAEd,KAAKnB,QAAL,CAAcwB,CAAd,GAAkB,KAAKrB,QAAL,CAAcqB,CAAd,GAAkBL,QAFtB,EAGd,KAAKnB,QAAL,CAAcyB,CAAd,GAAkB,KAAKtB,QAAL,CAAcsB,CAAd,GAAkBN,QAHtB,CAAlB;AAKH;;AAEDE,EAAAA,qBAAqB,CAACF,QAAD,EAAW;AAC5B,QAAIO,MAAM,GAAG7B,gBAAgB,CAAC8B,iBAAjB,EAAb;AAEA,QAAIC,MAAM,GAAG,KAAKzB,QAAL,CAAc0B,UAAd,EAAb;AACA,QAAIC,SAAS,GAAG,KAAK9B,QAAL,CAAc+B,KAAd,EAAhB,CAJ4B,CAM5B;;AACAL,IAAAA,MAAM,CAACM,OAAP,CAAgBC,KAAD,IAAW;AACtB;AACA,UAAIC,iBAAiB,GAAGtC,OAAO,CAACuC,qBAAR,CAA8BP,MAA9B,EAAsCE,SAAtC,EAAiDG,KAAjD,CAAxB;;AACA,UAAIC,iBAAiB,KAAK,IAA1B,EAAgC;AAC5B;AACA,YAAIE,eAAe,GAAGzC,OAAO,CAAC0C,GAAR,CAAYJ,KAAK,CAACK,MAAlB,EAA0B3C,OAAO,CAAC4C,QAAR,CAAiBT,SAAjB,EAA4BI,iBAA5B,CAA1B,CAAtB,CAF4B,CAI5B;;AACA,YAAIE,eAAe,GAAG,KAAK/B,QAAL,CAAcmC,MAApC,EAA4C;AACxC;AACA,cAAIC,IAAI,GAAI,KAAKpC,QAAL,CAAcmC,MAAd,GAAuBJ,eAAnC;AACA,eAAKpC,QAAL,CAAcU,GAAd,CAAkB,CACd,KAAKV,QAAL,CAAcuB,CAAd,GAAkBU,KAAK,CAACK,MAAN,CAAaf,CAAb,GAAiBkB,IADrB,EAEd,KAAKzC,QAAL,CAAcwB,CAAd,GAAkBS,KAAK,CAACK,MAAN,CAAad,CAAb,GAAiBiB,IAFrB,EAGd,KAAKzC,QAAL,CAAcyB,CAAd,GAAkBQ,KAAK,CAACK,MAAN,CAAab,CAAb,GAAiBgB,IAHrB,CAAlB,EAHwC,CASxC;;AACA,cAAIC,MAAM,GAAG,KAAKvC,QAAL,CAAcwC,SAAd,GAAwB,GAArC;AACA,cAAIC,gBAAgB,GAAGjD,OAAO,CAAC4C,QAAR,CAAiBN,KAAK,CAACK,MAAN,CAAaP,KAAb,GAAqBc,UAArB,CAAgC,MAAMlD,OAAO,CAAC0C,GAAR,CAAYJ,KAAK,CAACK,MAAlB,EAA0BV,MAA1B,CAAtC,CAAjB,EAA2FA,MAA3F,CAAvB;AAEA,eAAKzB,QAAL,CAAcO,GAAd,CAAkB,CACd,CAACkC,gBAAgB,CAACrB,CAAlB,GAAoBmB,MADN,EAEd,CAACE,gBAAgB,CAACpB,CAAlB,GAAoBkB,MAFN,EAGd,CAACE,gBAAgB,CAACnB,CAAlB,GAAoBiB,MAHN,CAAlB;AAKA,eAAK1C,QAAL,CAAcU,GAAd,CAAkB,CACd,KAAKV,QAAL,CAAcuB,CAAd,GAAkB,KAAKpB,QAAL,CAAcoB,CAAd,GAAkBJ,QADtB,EAEd,KAAKnB,QAAL,CAAcwB,CAAd,GAAkB,KAAKrB,QAAL,CAAcqB,CAAd,GAAkBL,QAFtB,EAGd,KAAKnB,QAAL,CAAcyB,CAAd,GAAkB,KAAKtB,QAAL,CAAcsB,CAAd,GAAkBN,QAHtB,CAAlB;AAKH;AACJ;AACJ,KAjCD;AAkCH;;AAEDG,EAAAA,oBAAoB,CAACH,QAAD,EAAW;AAC3B,QAAI,KAAKhB,QAAL,CAAcwC,SAAd,GAA0B,GAA9B,EAAmC;AAC/B;AACH;;AAED,QAAIG,gBAAgB,GAAGjD,gBAAgB,CAACkD,cAAjB,EAAvB;AAEAD,IAAAA,gBAAgB,CAACd,OAAjB,CAA0BgB,MAAD,IAAY;AACjC;AACA,UAAK,KAAK9C,EAAL,GAAU8C,MAAM,CAAC9C,EAAlB,KAA0B,CAA9B,EAAgC;AAE5B;AACA,YAAI+C,cAAc,GAAGtD,OAAO,CAAC4C,QAAR,CAAiBS,MAAM,CAAChD,QAAxB,EAAkC,KAAKA,QAAvC,CAArB;AACA,YAAIkD,cAAc,GAAGD,cAAc,CAACN,SAApC;;AAEA,YAAKO,cAAc,GAAIF,MAAM,CAAC3C,QAAP,CAAgBmC,MAAhB,GAAyB,KAAKnC,QAAL,CAAcmC,MAA9D,EAAuE;AACnE;AACA,cAAIC,IAAI,GAAI,KAAKpC,QAAL,CAAcmC,MAAd,GAAuBQ,MAAM,CAAC3C,QAAP,CAAgBmC,MAAxC,GAAkDU,cAA7D;AACA,cAAIC,WAAW,GAAG,KAAKhD,QAAL,CAAc0B,UAAd,EAAlB;AACA,eAAK7B,QAAL,CAAcU,GAAd,CAAkB,CACd,KAAKV,QAAL,CAAcuB,CAAd,GAAkB4B,WAAW,CAAC5B,CAAZ,GAAgBkB,IADpB,EAEd,KAAKzC,QAAL,CAAcwB,CAAd,GAAkB2B,WAAW,CAAC3B,CAAZ,GAAgBiB,IAFpB,EAGd,KAAKzC,QAAL,CAAcyB,CAAd,GAAkB0B,WAAW,CAAC1B,CAAZ,GAAgBgB,IAHpB,CAAlB;AAMAQ,UAAAA,cAAc,GAAGtD,OAAO,CAACyD,GAAR,CAAYH,cAAc,CAACpB,UAAf,EAAZ,EAAyC,KAAK1B,QAAL,CAAc0B,UAAd,EAAzC,EAAqEA,UAArE,EAAjB;AACA,cAAIwB,WAAW,GAAG,KAAKlD,QAAL,CAAcwC,SAAd,GAA0B,IAA5C;AACA,cAAIW,iBAAiB,GAAGN,MAAM,CAAC7C,QAAP,CAAgBwC,SAAhB,GAA4B,IAApD,CAZmE,CAcnE;;AACA,cAAIY,oBAAoB,GAAGP,MAAM,CAAC7C,QAAP,CAAgB4B,KAAhB,EAA3B;AACA,cAAIyB,WAAW,GAAG,KAAKvD,IAAL,GAAY+C,MAAM,CAAC/C,IAArC,CAhBmE,CAkBnE;;AACA,cAAIwD,CAAC,GAAI,MAAM,KAAKxD,IAAZ,GAAoBuD,WAA5B;AACA,cAAIE,CAAC,GAAG,CAACV,MAAM,CAAC/C,IAAP,GAAc,KAAKA,IAApB,IAA4BuD,WAApC,CApBmE,CAsBnE;;AACAR,UAAAA,MAAM,CAAC7C,QAAP,CAAgBO,GAAhB,CAAoB,CAChBuC,cAAc,CAAC1B,CAAf,GAAmB8B,WAAnB,GAAiCI,CAAjC,GAAqCR,cAAc,CAAC1B,CAAf,GAAmB+B,iBAAnB,GAAuCI,CAD5D,EAEhBT,cAAc,CAACzB,CAAf,GAAmB6B,WAAnB,GAAiCI,CAAjC,GAAqCR,cAAc,CAACzB,CAAf,GAAmB8B,iBAAnB,GAAuCI,CAF5D,EAGhBT,cAAc,CAACxB,CAAf,GAAmB4B,WAAnB,GAAiCI,CAAjC,GAAqCR,cAAc,CAACxB,CAAf,GAAmB6B,iBAAnB,GAAuCI,CAH5D,CAApB;AAKAV,UAAAA,MAAM,CAAChD,QAAP,CAAgBU,GAAhB,CAAoB,CAChBsC,MAAM,CAAChD,QAAP,CAAgBuB,CAAhB,GAAoByB,MAAM,CAAC7C,QAAP,CAAgBoB,CAAhB,GAAoBJ,QADxB,EAEhB6B,MAAM,CAAChD,QAAP,CAAgBwB,CAAhB,GAAoBwB,MAAM,CAAC7C,QAAP,CAAgBqB,CAAhB,GAAoBL,QAFxB,EAGhB6B,MAAM,CAAChD,QAAP,CAAgByB,CAAhB,GAAoBuB,MAAM,CAAC7C,QAAP,CAAgBsB,CAAhB,GAAoBN,QAHxB,CAApB,EA5BmE,CAkCnE;;AACAsC,UAAAA,CAAC,GAAG,CAAC,KAAKxD,IAAL,GAAY+C,MAAM,CAAC/C,IAApB,IAA4BuD,WAAhC;AACAE,UAAAA,CAAC,GAAI,MAAMV,MAAM,CAAC/C,IAAd,GAAsBuD,WAA1B,CApCmE,CAsCnE;;AACA,eAAKrD,QAAL,CAAcO,GAAd,CAAkB,CACduC,cAAc,CAAC1B,CAAf,GAAmB8B,WAAnB,GAAiCI,CAAjC,GAAqCR,cAAc,CAAC1B,CAAf,GAAmB+B,iBAAnB,GAAuCI,CAD9D,EAEdT,cAAc,CAAC1B,CAAf,GAAmB8B,WAAnB,GAAiCI,CAAjC,GAAqCR,cAAc,CAAC1B,CAAf,GAAmB+B,iBAAnB,GAAuCI,CAF9D,EAGdT,cAAc,CAAC1B,CAAf,GAAmB8B,WAAnB,GAAiCI,CAAjC,GAAqCR,cAAc,CAAC1B,CAAf,GAAmB+B,iBAAnB,GAAuCI,CAH9D,CAAlB;AAKA,eAAK1D,QAAL,CAAcU,GAAd,CAAkB,CACd,KAAKV,QAAL,CAAcuB,CAAd,GAAkB,KAAKpB,QAAL,CAAcoB,CAAd,GAAkBJ,QADtB,EAEd,KAAKnB,QAAL,CAAcwB,CAAd,GAAkB,KAAKrB,QAAL,CAAcqB,CAAd,GAAkBL,QAFtB,EAGd,KAAKnB,QAAL,CAAcyB,CAAd,GAAkB,KAAKtB,QAAL,CAAcsB,CAAd,GAAkBN,QAHtB,CAAlB;AAKH;AACJ;AACJ,KA3DD;AA4DH;;AA1KW;;AA6KhB,eAAerB,SAAf","sourcesContent":["import SphereCollider from \"./SphereCollider\";\r\nimport Vector3 from \"./math/Vector3\";\r\nimport Raycast from \"./Raycast\";\r\nimport CollisionManager from \"./CollisionManager\";\r\n\r\nclass RigidBody {\r\n    constructor(position, mass = 1.0) {\r\n        this.id = -1;\r\n        this.position = new Vector3(position);\r\n        this.velocity = new Vector3([0.0, 0.0, 0.0]);\r\n        this.acceleration = new Vector3([0.0, 0.0, 0.0]);\r\n\r\n        this.collider = new SphereCollider();\r\n\r\n        this.mass = mass;\r\n        this.enableGravity(true);\r\n\r\n        this.inCollision = false;\r\n    }\r\n\r\n    setVelocity(vel) {\r\n        this.velocity.set(vel);\r\n    }\r\n\r\n    setAcceleration(acc) {\r\n        this.acceleration.set(acc);\r\n    }\r\n\r\n    setPosition(pos) {\r\n        this.position.set(pos);\r\n    }\r\n\r\n    enableGravity(state) {\r\n        if (state)\r\n            this.gravity = 9.82;\r\n        else\r\n            this.gravity = 0.0;\r\n    }\r\n\r\n    get gravityIsEnabled () {\r\n        return this.gravity > 0.1;\r\n    }\r\n\r\n    update(timeStep) {\r\n\r\n        this.updateMotion(timeStep);\r\n        this.handlePlaneCollisions(timeStep);\r\n        this.handleBodyCollisions(timeStep);\r\n\r\n        return true;\r\n    }\r\n\r\n    updateMotion(timeStep) {\r\n        this.velocity.set([\r\n            this.velocity.x + this.acceleration.x * timeStep,\r\n            this.velocity.y + (this.acceleration.y - this.gravity) * timeStep,\r\n            this.velocity.z + this.acceleration.z * timeStep,\r\n        ]);\r\n        this.position.set([\r\n            this.position.x + this.velocity.x * timeStep,\r\n            this.position.y + this.velocity.y * timeStep,\r\n            this.position.z + this.velocity.z * timeStep,\r\n        ]);\r\n    }\r\n\r\n    handlePlaneCollisions(timeStep) {\r\n        let planes = CollisionManager.getPlaneColliders();\r\n\r\n        let rayDir = this.velocity.normalized();\r\n        let rayOrigin = this.position.clone();\r\n\r\n        // Find closest intersectionPoint\r\n        planes.forEach((plane) => {\r\n            // If the plane intersection test returns null, no plane was found\r\n            let intersectionPoint = Raycast.planeIntersectionTest(rayDir, rayOrigin, plane);\r\n            if (intersectionPoint !== null) {\r\n                // Calculate the closest distance from the rigid body collider and the plane\r\n                let distanceToPlane = Vector3.dot(plane.normal, Vector3.subtract(rayOrigin, intersectionPoint));\r\n\r\n                // Check if the sphere is intersecting the plane\r\n                if (distanceToPlane < this.collider.radius) {\r\n                    // Move the object to the plane surface\r\n                    let diff = (this.collider.radius - distanceToPlane);\r\n                    this.position.set([\r\n                        this.position.x + plane.normal.x * diff,\r\n                        this.position.y + plane.normal.y * diff,\r\n                        this.position.z + plane.normal.z * diff\r\n                    ]);\r\n\r\n                    // Calculate the bounce velocity\r\n                    let bounce = this.velocity.magnitude*0.8;\r\n                    let reflectDirection = Vector3.subtract(plane.normal.clone().multipleBy(2.0 * Vector3.dot(plane.normal, rayDir)), rayDir);\r\n\r\n                    this.velocity.set([\r\n                        -reflectDirection.x*bounce,\r\n                        -reflectDirection.y*bounce,\r\n                        -reflectDirection.z*bounce\r\n                    ]);\r\n                    this.position.set([\r\n                        this.position.x + this.velocity.x * timeStep,\r\n                        this.position.y + this.velocity.y * timeStep,\r\n                        this.position.z + this.velocity.z * timeStep,\r\n                    ]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    handleBodyCollisions(timeStep) {\r\n        if (this.velocity.magnitude < 0.1) {\r\n            return;\r\n        }\r\n\r\n        let sceneRigidBodies = CollisionManager.getRigidBodies();\r\n\r\n        sceneRigidBodies.forEach((target) => {\r\n            // Check if other id is different from this id\r\n            if ((this.id - target.id) !== 0){\r\n\r\n                //let targetDistance = Vector3.distance(target.position, this.position);\r\n                let toTargetVector = Vector3.subtract(target.position, this.position);\r\n                let targetDistance = toTargetVector.magnitude;\r\n\r\n                if ( targetDistance < (target.collider.radius + this.collider.radius)) {\r\n                    // Move the body outside of collision area\r\n                    let diff = (this.collider.radius + target.collider.radius) - targetDistance;\r\n                    let velocityDir = this.velocity.normalized();\r\n                    this.position.set([\r\n                        this.position.x - velocityDir.x * diff,\r\n                        this.position.y - velocityDir.y * diff,\r\n                        this.position.z - velocityDir.z * diff\r\n                    ]);\r\n\r\n                    toTargetVector = Vector3.add(toTargetVector.normalized(), this.velocity.normalized()).normalized();\r\n                    let speedBefore = this.velocity.magnitude * 0.75;\r\n                    let targetSpeedBefore = target.velocity.magnitude * 0.75;\r\n\r\n                    // Calculate velocity after collision\r\n                    let targetVelocityBefore = target.velocity.clone();\r\n                    let denominator = this.mass + target.mass;\r\n\r\n                    // Elastic Collision Coefficients\r\n                    let A = (2.0 * this.mass) / denominator;\r\n                    let B = (target.mass - this.mass) / denominator;\r\n\r\n                    // Set new velocity and position for target\r\n                    target.velocity.set([\r\n                        toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B,\r\n                        toTargetVector.y * speedBefore * A - toTargetVector.y * targetSpeedBefore * B,\r\n                        toTargetVector.z * speedBefore * A - toTargetVector.z * targetSpeedBefore * B\r\n                    ]);\r\n                    target.position.set([\r\n                        target.position.x + target.velocity.x * timeStep,\r\n                        target.position.y + target.velocity.y * timeStep,\r\n                        target.position.z + target.velocity.z * timeStep,\r\n                    ]);\r\n\r\n                    // Elastic Collision Coefficients\r\n                    A = (this.mass - target.mass) / denominator;\r\n                    B = (2.0 * target.mass) / denominator;\r\n\r\n                    // Set new velocity and position\r\n                    this.velocity.set([\r\n                        toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B,\r\n                        toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B,\r\n                        toTargetVector.x * speedBefore * A - toTargetVector.x * targetSpeedBefore * B\r\n                    ]);\r\n                    this.position.set([\r\n                        this.position.x + this.velocity.x * timeStep,\r\n                        this.position.y + this.velocity.y * timeStep,\r\n                        this.position.z + this.velocity.z * timeStep,\r\n                    ]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nexport default RigidBody;"]},"metadata":{},"sourceType":"module"}