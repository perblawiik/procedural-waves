{"ast":null,"code":"/**\r\n * Author: Per Blåwiik\r\n * Date: 2019-12-29\r\n */\nclass PhongLightingShader {\n  static get vertex() {\n    return [\"precision highp float;\", // Attribute locations\n    \"attribute vec3 vertPosition;\", \"attribute vec3 vertNormal;\", \"attribute vec2 vertTexCoord;\", // Transformation matrices\n    \"uniform mat4 cameraView;\", \"uniform mat4 modelView;\", \"uniform mat4 perspective;\", // Fragment shader input variables\n    \"varying vec2 TexCoords;\", \"varying vec3 Normal;\", \"varying vec3 FragPosition;\", \"void main() {\", // Final transformation ( Perspective multiplied with the model view )\n    \"mat4 T = perspective * cameraView * modelView;\", // Transform (x,y,z) vertex coordinates with a 4x4 matrix T\n    \"gl_Position = T * vec4(vertPosition, 1.0);\", // Fragment shader input variables\n    \"Normal = normalize(mat3(modelView)*vertNormal);\", \"TexCoords = vertTexCoord;\", \"FragPosition = vec3(modelView * vec4(vertPosition, 1.0));\", \"}\"].join(\"\\n\");\n  }\n\n  static get fragment() {\n    return [// Float precision\n    \"precision highp float;\", // Fragment shader input variables\n    \"varying vec2 TexCoords;\", \"varying vec3 Normal;\", \"varying vec3 FragPosition;\", \"struct PointLight {\", \"vec3 position;\", \"vec3 color;\", \"vec2 attenuationConstants;\", \"};\", // Shader inputs\n    \"uniform vec3 viewPosition;\", // Current camera position\n    \"uniform vec3 diffuseColor;\", // Object surface color\n    \"uniform int lightCount;\", // Number of light sources\n    \"uniform PointLight pointLights[10];\", // Set maximum point light sources to 10 per scene shader\n    // Computes the specular light effect based on the dot product of the reflected light vector and the camera view vector\n    \"vec3 computeSpecularLight(vec3 viewDirection, vec3 reflectDirection, vec3 lightColor) {\", \"float specularStrength = 0.5;\", \"float shininess = 32.0;\", \"float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), shininess);\", \"return spec * specularStrength * lightColor;\", \"}\", // Computes the intensity based on the distance from the light source\n    \"float computeLightAttenuation(vec3 lightPosition, vec2 attenuationConstants) {\", // Calculate the distance from current pixel to the light source\n    \"float dist = distance(lightPosition, FragPosition);\", // The constants are set to simulate the light's intensity drop off over distance\n    \"return min(1.0 / (1.0 + dist*attenuationConstants.x + dist*dist*attenuationConstants.y), 1.0);\", \"}\", \"vec3 computeDiffuseSpecular(PointLight pointLight, vec3 viewDirection) {\", // Compute the vector from the pixel to the light source\n    \"vec3 lightDirection = normalize(pointLight.position - FragPosition);\", // Diffuse lighting\n    \"float diff = max(dot(Normal, lightDirection), 0.0);\", \"vec3 diffuse = (diff * pointLight.color * diffuseColor);\", // Compute the vector of the reflected light based on the incoming light vector\n    \"vec3 reflectDirection = reflect(-lightDirection, Normal);\", // Specular lighting\n    \"vec3 specular = computeSpecularLight(viewDirection, reflectDirection, pointLight.color) * diff;\", // Compute attenuation (intensity decrement over distance).\n    \"float attenuation = computeLightAttenuation(pointLight.position, pointLight.attenuationConstants);\", // Phong lighting model\n    \"return (diffuse + specular) * attenuation;\", \"}\", \"\", \"void main() {\", // Ambient lighting\n    \"float ambientStrength = 0.05;\", \"vec3 ambientColor = vec3(1.0, 1.0, 1.0);\", \"vec3 ambient = ambientStrength * ambientColor * diffuseColor;\", \"vec3 phong = ambient;\", // Compute the vector from the pixel to the camera\n    \"vec3 viewDirection = normalize(viewPosition - FragPosition);\", // Add point light sources\n    \"for(int i = 0; i < 10; i++) {\", \"if (i > lightCount) break;\", \"phong += computeDiffuseSpecular(pointLights[i], viewDirection);\", \"}\", // Final shaded color (texture * lighting)\n    \"gl_FragColor = vec4 (phong, 1.0);\", \"}\"].join(\"\\n\");\n  }\n\n}\n\nexport default PhongLightingShader;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\Waves\\procedural-waves\\src\\js\\bluebox\\shaders\\PhongLightingShader.js"],"names":["PhongLightingShader","vertex","join","fragment"],"mappings":"AAAA;;;;AAKA,MAAMA,mBAAN,CAA0B;AACtB,aAAWC,MAAX,GAAqB;AACjB,WAAO,CACH,wBADG,EAGH;AACA,kCAJG,EAKH,4BALG,EAMH,8BANG,EAQH;AACA,8BATG,EAUH,yBAVG,EAWH,2BAXG,EAaH;AACA,6BAdG,EAeH,sBAfG,EAgBH,4BAhBG,EAkBH,eAlBG,EAmBC;AACA,oDApBD,EAqBC;AACA,gDAtBD,EAwBC;AACA,qDAzBD,EA0BC,2BA1BD,EA2BC,2DA3BD,EA4BH,GA5BG,EA6BLC,IA7BK,CA6BA,IA7BA,CAAP;AA8BH;;AAED,aAAWC,QAAX,GAAuB;AACnB,WAAO,CACH;AACA,4BAFG,EAGH;AACA,6BAJG,EAKH,sBALG,EAMH,4BANG,EAQH,qBARG,EASC,gBATD,EAUC,aAVD,EAWC,4BAXD,EAYH,IAZG,EAcH;AACA,gCAfG,EAe2B;AAC9B,gCAhBG,EAgB2B;AAC9B,6BAjBG,EAiBwB;AAC3B,yCAlBG,EAkBoC;AAEvC;AACA,6FArBG,EAsBC,+BAtBD,EAuBC,yBAvBD,EAwBC,8EAxBD,EAyBC,8CAzBD,EA0BH,GA1BG,EA4BH;AACA,oFA7BG,EA8BC;AACA,yDA/BD,EAgCC;AACA,oGAjCD,EAkCH,GAlCG,EAoCH,0EApCG,EAqCC;AACA,0EAtCD,EAuCC;AACA,yDAxCD,EAyCC,0DAzCD,EA2CC;AACA,+DA5CD,EA6CC;AACA,qGA9CD,EAgDC;AACA,wGAjDD,EAmDC;AACA,gDApDD,EAqDH,GArDG,EAsDH,EAtDG,EAuDH,eAvDG,EAwDC;AACA,mCAzDD,EA0DC,0CA1DD,EA2DC,+DA3DD,EA4DC,uBA5DD,EA8DC;AACA,kEA/DD,EAgEC;AACA,mCAjED,EAkEK,4BAlEL,EAmEK,iEAnEL,EAoEC,GApED,EAqEC;AACA,uCAtED,EAuEH,GAvEG,EAwELD,IAxEK,CAwEA,IAxEA,CAAP;AAyEH;;AA5GqB;;AA+G1B,eAAeF,mBAAf","sourcesContent":["/**\r\n * Author: Per Blåwiik\r\n * Date: 2019-12-29\r\n */\r\n\r\nclass PhongLightingShader {\r\n    static get vertex () {\r\n        return [\r\n            \"precision highp float;\",\r\n\r\n            // Attribute locations\r\n            \"attribute vec3 vertPosition;\",\r\n            \"attribute vec3 vertNormal;\",\r\n            \"attribute vec2 vertTexCoord;\",\r\n\r\n            // Transformation matrices\r\n            \"uniform mat4 cameraView;\",\r\n            \"uniform mat4 modelView;\",\r\n            \"uniform mat4 perspective;\",\r\n\r\n            // Fragment shader input variables\r\n            \"varying vec2 TexCoords;\",\r\n            \"varying vec3 Normal;\",\r\n            \"varying vec3 FragPosition;\",\r\n\r\n            \"void main() {\",\r\n                // Final transformation ( Perspective multiplied with the model view )\r\n                \"mat4 T = perspective * cameraView * modelView;\",\r\n                // Transform (x,y,z) vertex coordinates with a 4x4 matrix T\r\n                \"gl_Position = T * vec4(vertPosition, 1.0);\",\r\n\r\n                // Fragment shader input variables\r\n                \"Normal = normalize(mat3(modelView)*vertNormal);\",\r\n                \"TexCoords = vertTexCoord;\",\r\n                \"FragPosition = vec3(modelView * vec4(vertPosition, 1.0));\",\r\n            \"}\"\r\n        ].join(\"\\n\");\r\n    }\r\n\r\n    static get fragment () {\r\n        return [\r\n            // Float precision\r\n            \"precision highp float;\",\r\n            // Fragment shader input variables\r\n            \"varying vec2 TexCoords;\",\r\n            \"varying vec3 Normal;\",\r\n            \"varying vec3 FragPosition;\",\r\n\r\n            \"struct PointLight {\",\r\n                \"vec3 position;\",\r\n                \"vec3 color;\",\r\n                \"vec2 attenuationConstants;\",\r\n            \"};\",\r\n\r\n            // Shader inputs\r\n            \"uniform vec3 viewPosition;\", // Current camera position\r\n            \"uniform vec3 diffuseColor;\", // Object surface color\r\n            \"uniform int lightCount;\", // Number of light sources\r\n            \"uniform PointLight pointLights[10];\", // Set maximum point light sources to 10 per scene shader\r\n\r\n            // Computes the specular light effect based on the dot product of the reflected light vector and the camera view vector\r\n            \"vec3 computeSpecularLight(vec3 viewDirection, vec3 reflectDirection, vec3 lightColor) {\",\r\n                \"float specularStrength = 0.5;\",\r\n                \"float shininess = 32.0;\",\r\n                \"float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), shininess);\",\r\n                \"return spec * specularStrength * lightColor;\",\r\n            \"}\",\r\n\r\n            // Computes the intensity based on the distance from the light source\r\n            \"float computeLightAttenuation(vec3 lightPosition, vec2 attenuationConstants) {\",\r\n                // Calculate the distance from current pixel to the light source\r\n                \"float dist = distance(lightPosition, FragPosition);\",\r\n                // The constants are set to simulate the light's intensity drop off over distance\r\n                \"return min(1.0 / (1.0 + dist*attenuationConstants.x + dist*dist*attenuationConstants.y), 1.0);\",\r\n            \"}\",\r\n\r\n            \"vec3 computeDiffuseSpecular(PointLight pointLight, vec3 viewDirection) {\",\r\n                // Compute the vector from the pixel to the light source\r\n                \"vec3 lightDirection = normalize(pointLight.position - FragPosition);\",\r\n                // Diffuse lighting\r\n                \"float diff = max(dot(Normal, lightDirection), 0.0);\",\r\n                \"vec3 diffuse = (diff * pointLight.color * diffuseColor);\",\r\n\r\n                // Compute the vector of the reflected light based on the incoming light vector\r\n                \"vec3 reflectDirection = reflect(-lightDirection, Normal);\",\r\n                // Specular lighting\r\n                \"vec3 specular = computeSpecularLight(viewDirection, reflectDirection, pointLight.color) * diff;\",\r\n\r\n                // Compute attenuation (intensity decrement over distance).\r\n                \"float attenuation = computeLightAttenuation(pointLight.position, pointLight.attenuationConstants);\",\r\n\r\n                // Phong lighting model\r\n                \"return (diffuse + specular) * attenuation;\",\r\n            \"}\",\r\n            \"\",\r\n            \"void main() {\",\r\n                // Ambient lighting\r\n                \"float ambientStrength = 0.05;\",\r\n                \"vec3 ambientColor = vec3(1.0, 1.0, 1.0);\",\r\n                \"vec3 ambient = ambientStrength * ambientColor * diffuseColor;\",\r\n                \"vec3 phong = ambient;\",\r\n\r\n                // Compute the vector from the pixel to the camera\r\n                \"vec3 viewDirection = normalize(viewPosition - FragPosition);\",\r\n                // Add point light sources\r\n                \"for(int i = 0; i < 10; i++) {\",\r\n                    \"if (i > lightCount) break;\",\r\n                    \"phong += computeDiffuseSpecular(pointLights[i], viewDirection);\",\r\n                \"}\",\r\n                // Final shaded color (texture * lighting)\r\n                \"gl_FragColor = vec4 (phong, 1.0);\",\r\n            \"}\"\r\n        ].join(\"\\n\");\r\n    }\r\n}\r\n\r\nexport default PhongLightingShader;"]},"metadata":{},"sourceType":"module"}