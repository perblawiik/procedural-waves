{"ast":null,"code":"/**\r\n * Author: Per BlÃ¥wiik\r\n * Date: 2019-12-29\r\n */\n// JavaScript components\nimport GameEditor from \"./GameEditor\";\nimport Time from \"./Time\";\nimport EventHandler from \"./events/EventHandler\";\nimport Scene from \"./Scene\";\nimport Camera from \"./Camera\";\nimport GameObject from \"./GameObject\";\nimport Mesh from \"./Mesh\";\nimport PointLightSource from \"./PointLightSource\";\nimport Matrix4 from \"./math/Matrix4\";\nimport ConnectionManager from \"./ConnectionManager\"; // Shaders\n\nimport ShaderHandle from \"./ShaderHandle\";\nimport PhongLightingShader from \"./shaders/PhongLightingShader\";\nimport AmbientShader from \"./shaders/AmbientShader\";\nimport ProceduralShader from \"./shaders/ProceduralShader\";\n/***** Settings *****/\n// Default camera position and rotation\n\nconst CAMERA_POSITION = [90.0, 34.0, -90.0];\nconst CAMERA_ROTATION = [-15.0, 140.0, 0.0]; // Enum struct for creating different shapes\n\nconst SHAPE = {\n  CUBE: 0,\n  SPHERE: 1,\n  CYLINDER_SMOOTH: 2,\n  CYLINDER_SHARP: 3,\n  PLANE: 4\n}; // 60 degrees field of view\n\nconst FIELD_OF_VIEW = Math.PI / 3.0;\nconst MS_PER_UPDATE = 4.0;\nconst UPDATE_TIME_STEP = 0.01;\n\nclass Engine {\n  constructor() {\n    // Scenes works like blocks in the game world.\n    // The active scenes are based on the cameras distance to the origin of each scene.\n    this.scenes = [];\n    this.shaders = new Map();\n    this.viewportAspectRatio = 1.0;\n    this.lag = 0.0;\n  }\n  /*\r\n  * @brief This is the engines main update function and is called every iteration of the main loop\r\n  */\n\n\n  run() {\n    // Update game loop clock\n    Time.update(); // Time start of the loop\n    //let startTime =  Time.now;\n    // Process mouse and keyboard events\n\n    this.processInputEvents(); // Communication between GUI and the graphics engine\n\n    this.processInternalSignals(); // Add elapsed time to the lag variable\n\n    this.lag += Time.deltaTime; // Make sure the update function is called on a constant rate\n\n    while (this.lag >= MS_PER_UPDATE) {\n      // Updates game object animations, AI, physics, etc.\n      this.update(); // Clear momentary events\n\n      EventHandler.resetMouseEvents();\n      this.lag -= MS_PER_UPDATE;\n    } // Render graphics\n\n\n    this.render(this.lag / MS_PER_UPDATE); // Hold each frame for a specified number of milliseconds (16 ms locks on roughly 60 fps)\n    //while ((Time.now - startTime) < 16.0) ; // Sleep\n  }\n\n  update() {\n    this.scenes.forEach(scene => {\n      scene.update(UPDATE_TIME_STEP);\n    });\n    this.camera.updateUniforms();\n  }\n\n  render(residualLag) {\n    // Set the viewport to the canvas dimensions and update the aspect ratio for the projection matrix\n    this.updateViewportDimensions(); // Clear screen 3D\n\n    this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT); // Draw scenes\n\n    this.gl.enable(this.gl.DEPTH_TEST);\n    this.scenes.forEach(scene => {\n      //scene.updateLightPositions();\n      scene.draw();\n    }); // Display fps and other useful information\n\n    this.editor.render(this.scenes);\n  }\n\n  processInputEvents() {\n    // Process editor commands\n    this.editor.processUserInput();\n  }\n\n  processInternalSignals() {\n    if (ConnectionManager.signalPending) {\n      this.updateWaveParameter(ConnectionManager.message);\n      ConnectionManager.resetSignal();\n    }\n  } // This function is called before the game loop is started\n\n\n  preload() {\n    // Initiate static classes\n    Time.init();\n    EventHandler.init(); // Set up webgl 2D and 3D context from html canvas. Viewport and render settings are also set.\n\n    this.setUpWebGL(); // Create shaders\n\n    let mainShader = new ShaderHandle(this.canvas, PhongLightingShader.vertex, PhongLightingShader.fragment);\n    let ambientShader = new ShaderHandle(this.canvas, AmbientShader.vertex, AmbientShader.fragment);\n    let proceduralShader = new ShaderHandle(this.canvas, ProceduralShader.vertex, ProceduralShader.fragment); // Add them to the shaders container\n\n    this.shaders.set(\"phong\", mainShader);\n    this.shaders.set(\"ambient\", ambientShader);\n    this.shaders.set(\"procedural\", proceduralShader); // Initialize the main camera\n\n    this.camera = new Camera(this.shaders);\n    this.camera.setPosition(CAMERA_POSITION);\n    this.camera.setRotation(CAMERA_ROTATION); // Initialize the game engine editor used for managing the game scenes\n\n    this.editor = new GameEditor(this.gl, this.context2D, this.shaders, this.camera, this.canvas); // Create and set the projection matrix for the shaders\n\n    this.fieldOfView = FIELD_OF_VIEW;\n    this.viewportAspectRatio = this.canvas.width / this.canvas.height;\n    this.refreshProjectionMatrix();\n    this.setUpScene();\n  }\n\n  setUpScene() {\n    // Create a scene for the objects\n    let defaultScene = new Scene(this.shaders); // Create a objects for the scene\n\n    this.loadDefaultScene(defaultScene); // Add default scene to scenes\n\n    this.scenes.push(defaultScene);\n  }\n\n  updateViewportDimensions() {\n    // Calculate current aspect ratio\n    let currentAspectRatio = this.canvas.width / this.canvas.height; // Check if the aspect ratio has changed before going further\n\n    if (Math.abs(this.viewportAspectRatio - currentAspectRatio) < 0.001) return; // Save new aspect ratio\n\n    this.viewportAspectRatio = currentAspectRatio; // Refresh the projection matrix and send set it in the shaders\n\n    this.refreshProjectionMatrix(); // Update the viewport dimensions to the canvas width\n\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  createGameObject(settings) {\n    let mesh = new Mesh(this.gl);\n\n    if (settings.shape === SHAPE.CUBE) {\n      mesh.createCube();\n    } else if (settings.shape === SHAPE.SPHERE) {\n      mesh.createSphere(32);\n    } else if (settings.shape === SHAPE.CYLINDER_SMOOTH) {\n      mesh.createCylinderSmooth(32, 1, 1, 2);\n    } else if (settings.shape === SHAPE.CYLINDER_SHARP) {\n      mesh.createCylinderSharp(8, 1, 2);\n    } else if (settings.shape === SHAPE.PLANE) {\n      mesh.createPlane(200, 200);\n    }\n\n    mesh.setColor(settings.color);\n    let obj = new GameObject(settings.name);\n    obj.setPosition(settings.position);\n    obj.setScale(settings.scale);\n    obj.addMesh(mesh);\n    obj.setShader(settings.shader);\n    return obj;\n  }\n\n  createPointLightSource(settings) {\n    // Create the light source component\n    let lightSource = new PointLightSource(settings.name);\n    lightSource.setPosition(settings.position);\n    lightSource.setScale(settings.scale);\n    lightSource.setLightColor(settings.color);\n    lightSource.setAttenuation(settings.attenuation.kLinear, settings.attenuation.kQuadratic); // Create a model for the light source\n\n    let lightSourceModel = new Mesh(this.gl);\n    lightSourceModel.createSphere(8);\n    lightSourceModel.setColor(settings.color);\n    lightSource.addMesh(lightSourceModel);\n    return lightSource;\n  }\n\n  loadDefaultScene(scene) {\n    // Initiate procedural shader inputs\n    this.updateWaveParameter(\"harmonicAmplitude\");\n    this.updateWaveParameter(\"harmonicWaveLength\");\n    this.updateWaveParameter(\"harmonicSpeed\");\n    this.updateWaveParameter(\"waveSharpness\");\n    this.updateWaveParameter(\"harmonicDirectionAngle\");\n    const color = ConnectionManager.getItemValue('waterColor'); // Create four planes for visualizing a water surface\n\n    let plane1 = this.createGameObject({\n      shape: SHAPE.PLANE,\n      name: 'Waves',\n      scale: [1.0, 1.0, 1.0],\n      position: [0.0, 10.0, 100.0],\n      color: [color.r, color.g, color.b],\n      shader: 'procedural'\n    }); // Add water planes to the scene\n\n    scene.addGameObject(plane1);\n    this.water = [];\n    this.water.push(plane1); // Wall dimensions\n\n    const wallHeight = 20.0;\n    const wallWidth = 100.0; // Create gray floor\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Floor',\n      scale: [wallWidth, 0.1, wallWidth],\n      position: [0.0, -0.1, 0.0],\n      color: [0.75, 0.75, 0.75],\n      shader: 'phong'\n    })); // Create blue walls\n\n    let wallColor = [1.0, 1.0, 1.0];\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Left Wall',\n      scale: [0.1, wallHeight, wallWidth],\n      position: [-wallWidth, wallHeight, 0.0],\n      color: wallColor,\n      shader: 'phong'\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Right Wall',\n      scale: [0.1, wallHeight, wallWidth],\n      position: [wallWidth, wallHeight, 0.0],\n      color: wallColor,\n      shader: 'phong'\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Back Wall',\n      scale: [wallWidth, wallHeight, 0.1],\n      position: [0.0, wallHeight, -wallWidth],\n      color: wallColor,\n      shader: 'phong'\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Front Wall',\n      scale: [wallWidth, wallHeight, 0.1],\n      position: [0.0, wallHeight, wallWidth],\n      color: wallColor,\n      shader: 'phong'\n    })); // Create a point lights for the scene\n    // Add the light source to our scene\n\n    let atten = {\n      // The attenuation constants should make the light travel a maximum distance of 325\n      kLinear: 0.014,\n      kQuadratic: 0.0007\n    };\n    let lampRadius = 1.0;\n    let lampHeight = 2.0 * wallHeight - lampRadius;\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [0.0, lampHeight, -wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Right Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [wallWidth * 0.75, lampHeight, -wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Left Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [-wallWidth * 0.75, lampHeight, -wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [0.0, lampHeight, wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Right Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [wallWidth * 0.75, lampHeight, wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Left Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [-wallWidth * 0.75, lampHeight, wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    })); // Middle section\n\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Left Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [-wallWidth * 0.75, lampHeight, 0.0],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Right Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [wallWidth * 0.75, lampHeight, 0.0],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [0.0, lampHeight, 0.0],\n      color: [1.0, 1.0, 1.0],\n      attenuation: atten\n    }));\n  }\n\n  setUpWebGL() {\n    // 2D Canvas for text display\n    this.context2D = document.getElementById('text-canvas').getContext('2d'); // WebGL canvas\n\n    this.canvas = document.getElementById(\"gl-canvas\"); // Initialize the WebGL context\n\n    this.gl = this.canvas.getContext(\"webgl\"); // If WebGL isn't supported\n\n    if (!this.gl) {\n      console.log(\"WebGL is not supported\");\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n      return 0;\n    } // Set the viewport dimensions to the same as the canvas\n\n\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height); // Set clear color to dark blue, fully opaque\n\n    this.gl.clearColor(0.02, 0.02, 0.02, 1.0); // Enable depth so that triangles closer to the camera don't get overlapped by those further away\n\n    this.gl.enable(this.gl.DEPTH_TEST); // Only draw \"visible\" sides (memory saving)\n\n    this.gl.enable(this.gl.CULL_FACE);\n    this.gl.cullFace(this.gl.BACK);\n    this.gl.frontFace(this.gl.CCW);\n  }\n\n  refreshProjectionMatrix() {\n    // Create a new projection matrix\n    this.projectionMatrix = Matrix4.perspective(this.fieldOfView, this.viewportAspectRatio, 0.1, 10000.0); // Update the projection matrix in the editor\n\n    this.editor.projectionMatrix = this.projectionMatrix; // Update the projection matrix for the shaders\n\n    this.shaders.forEach(shader => {\n      shader.activate();\n      shader.setProjectionUniform(this.projectionMatrix);\n    });\n  }\n\n  updateWaveParameter(tag) {\n    let newValue = ConnectionManager.getItemValue(tag);\n\n    if (tag === \"waterColor\") {\n      this.water.forEach(o => {\n        o.meshes[0].setColor([newValue.r, newValue.g, newValue.b]);\n      });\n    } else {\n      let proceduralShader = this.shaders.get(\"procedural\");\n      proceduralShader.activate();\n      let uniformLocation = proceduralShader.getUniformLoc(tag);\n      proceduralShader.setUniformFloat(uniformLocation, newValue);\n    }\n  }\n\n}\n\nexport default Engine;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\Waves\\procedural-waves\\src\\js\\bluebox\\Engine.js"],"names":["GameEditor","Time","EventHandler","Scene","Camera","GameObject","Mesh","PointLightSource","Matrix4","ConnectionManager","ShaderHandle","PhongLightingShader","AmbientShader","ProceduralShader","CAMERA_POSITION","CAMERA_ROTATION","SHAPE","CUBE","SPHERE","CYLINDER_SMOOTH","CYLINDER_SHARP","PLANE","FIELD_OF_VIEW","Math","PI","MS_PER_UPDATE","UPDATE_TIME_STEP","Engine","constructor","scenes","shaders","Map","viewportAspectRatio","lag","run","update","processInputEvents","processInternalSignals","deltaTime","resetMouseEvents","render","forEach","scene","camera","updateUniforms","residualLag","updateViewportDimensions","gl","clear","DEPTH_BUFFER_BIT","COLOR_BUFFER_BIT","enable","DEPTH_TEST","draw","editor","processUserInput","signalPending","updateWaveParameter","message","resetSignal","preload","init","setUpWebGL","mainShader","canvas","vertex","fragment","ambientShader","proceduralShader","set","setPosition","setRotation","context2D","fieldOfView","width","height","refreshProjectionMatrix","setUpScene","defaultScene","loadDefaultScene","push","currentAspectRatio","abs","viewport","createGameObject","settings","mesh","shape","createCube","createSphere","createCylinderSmooth","createCylinderSharp","createPlane","setColor","color","obj","name","position","setScale","scale","addMesh","setShader","shader","createPointLightSource","lightSource","setLightColor","setAttenuation","attenuation","kLinear","kQuadratic","lightSourceModel","getItemValue","plane1","r","g","b","addGameObject","water","wallHeight","wallWidth","wallColor","atten","lampRadius","lampHeight","addLightSource","document","getElementById","getContext","console","log","alert","clearColor","CULL_FACE","cullFace","BACK","frontFace","CCW","projectionMatrix","perspective","activate","setProjectionUniform","tag","newValue","o","meshes","get","uniformLocation","getUniformLoc","setUniformFloat"],"mappings":"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","sourcesContent":["/**\r\n * Author: Per BlÃ¥wiik\r\n * Date: 2019-12-29\r\n */\r\n\r\n// JavaScript components\r\nimport GameEditor from \"./GameEditor\";\r\nimport Time from \"./Time\";\r\n\r\nimport EventHandler from \"./events/EventHandler\";\r\n\r\nimport Scene from \"./Scene\";\r\nimport Camera from \"./Camera\";\r\nimport GameObject from \"./GameObject\";\r\nimport Mesh from \"./Mesh\";\r\nimport PointLightSource from \"./PointLightSource\";\r\n\r\nimport Matrix4 from \"./math/Matrix4\";\r\n\r\nimport ConnectionManager from \"./ConnectionManager\";\r\n\r\n// Shaders\r\nimport ShaderHandle from \"./ShaderHandle\";\r\nimport PhongLightingShader from \"./shaders/PhongLightingShader\";\r\nimport AmbientShader from \"./shaders/AmbientShader\";\r\nimport ProceduralShader from \"./shaders/ProceduralShader\";\r\n\r\n/***** Settings *****/\r\n// Default camera position and rotation\r\nconst CAMERA_POSITION = [90.0, 34.0, -90.0];\r\nconst CAMERA_ROTATION = [-15.0, 140.0, 0.0];\r\n\r\n// Enum struct for creating different shapes\r\nconst SHAPE = {\r\n    CUBE: 0,\r\n    SPHERE: 1,\r\n    CYLINDER_SMOOTH: 2,\r\n    CYLINDER_SHARP: 3,\r\n    PLANE: 4\r\n};\r\n\r\n// 60 degrees field of view\r\nconst FIELD_OF_VIEW = Math.PI / 3.0;\r\n\r\nconst MS_PER_UPDATE = 4.0;\r\nconst UPDATE_TIME_STEP = 0.01;\r\n\r\nclass Engine {\r\n    constructor() {\r\n        // Scenes works like blocks in the game world.\r\n        // The active scenes are based on the cameras distance to the origin of each scene.\r\n        this.scenes = [];\r\n        this.shaders = new Map();\r\n\r\n        this.viewportAspectRatio = 1.0;\r\n        this.lag = 0.0;\r\n    }\r\n\r\n    /*\r\n    * @brief This is the engines main update function and is called every iteration of the main loop\r\n    */\r\n    run() {\r\n        // Update game loop clock\r\n        Time.update();\r\n\r\n        // Time start of the loop\r\n        //let startTime =  Time.now;\r\n\r\n        // Process mouse and keyboard events\r\n        this.processInputEvents();\r\n\r\n        // Communication between GUI and the graphics engine\r\n        this.processInternalSignals();\r\n\r\n        // Add elapsed time to the lag variable\r\n        this.lag += Time.deltaTime;\r\n\r\n        // Make sure the update function is called on a constant rate\r\n        while (this.lag >= MS_PER_UPDATE) {\r\n            // Updates game object animations, AI, physics, etc.\r\n            this.update();\r\n            // Clear momentary events\r\n            EventHandler.resetMouseEvents();\r\n            this.lag -= MS_PER_UPDATE;\r\n        }\r\n\r\n        // Render graphics\r\n        this.render(this.lag/MS_PER_UPDATE);\r\n\r\n        // Hold each frame for a specified number of milliseconds (16 ms locks on roughly 60 fps)\r\n        //while ((Time.now - startTime) < 16.0) ; // Sleep\r\n    }\r\n\r\n    update() {\r\n        this.scenes.forEach((scene) => {\r\n            scene.update(UPDATE_TIME_STEP);\r\n        });\r\n        this.camera.updateUniforms();\r\n    }\r\n\r\n    render(residualLag) {\r\n        // Set the viewport to the canvas dimensions and update the aspect ratio for the projection matrix\r\n        this.updateViewportDimensions();\r\n\r\n        // Clear screen 3D\r\n        this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);\r\n\r\n        // Draw scenes\r\n        this.gl.enable(this.gl.DEPTH_TEST);\r\n        this.scenes.forEach((scene) => {\r\n            //scene.updateLightPositions();\r\n            scene.draw();\r\n        });\r\n\r\n        // Display fps and other useful information\r\n        this.editor.render(this.scenes);\r\n    }\r\n\r\n    processInputEvents() {\r\n        // Process editor commands\r\n        this.editor.processUserInput();\r\n    }\r\n\r\n    processInternalSignals() {\r\n        if(ConnectionManager.signalPending) {\r\n            this.updateWaveParameter(ConnectionManager.message);\r\n            ConnectionManager.resetSignal();\r\n        }\r\n    }\r\n\r\n    // This function is called before the game loop is started\r\n    preload() {\r\n        // Initiate static classes\r\n        Time.init();\r\n        EventHandler.init();\r\n\r\n        // Set up webgl 2D and 3D context from html canvas. Viewport and render settings are also set.\r\n        this.setUpWebGL();\r\n\r\n        // Create shaders\r\n        let mainShader = new ShaderHandle(this.canvas, PhongLightingShader.vertex, PhongLightingShader.fragment);\r\n        let ambientShader = new ShaderHandle(this.canvas, AmbientShader.vertex, AmbientShader.fragment);\r\n        let proceduralShader = new ShaderHandle(this.canvas, ProceduralShader.vertex, ProceduralShader.fragment);\r\n\r\n        // Add them to the shaders container\r\n        this.shaders.set(\"phong\", mainShader);\r\n        this.shaders.set(\"ambient\", ambientShader);\r\n        this.shaders.set(\"procedural\", proceduralShader);\r\n\r\n        // Initialize the main camera\r\n        this.camera = new Camera(this.shaders);\r\n        this.camera.setPosition(CAMERA_POSITION);\r\n        this.camera.setRotation(CAMERA_ROTATION);\r\n\r\n        // Initialize the game engine editor used for managing the game scenes\r\n        this.editor = new GameEditor(this.gl, this.context2D, this.shaders, this.camera, this.canvas);\r\n\r\n        // Create and set the projection matrix for the shaders\r\n        this.fieldOfView = FIELD_OF_VIEW;\r\n        this.viewportAspectRatio = this.canvas.width / this.canvas.height;\r\n        this.refreshProjectionMatrix();\r\n\r\n        this.setUpScene();\r\n    }\r\n\r\n    setUpScene() {\r\n        // Create a scene for the objects\r\n        let defaultScene = new Scene(this.shaders);\r\n\r\n        // Create a objects for the scene\r\n        this.loadDefaultScene(defaultScene);\r\n\r\n        // Add default scene to scenes\r\n        this.scenes.push(defaultScene);\r\n    }\r\n\r\n    updateViewportDimensions() {\r\n        // Calculate current aspect ratio\r\n        let currentAspectRatio = this.canvas.width / this.canvas.height;\r\n\r\n        // Check if the aspect ratio has changed before going further\r\n        if (Math.abs(this.viewportAspectRatio - currentAspectRatio) < 0.001)\r\n            return;\r\n\r\n        // Save new aspect ratio\r\n        this.viewportAspectRatio = currentAspectRatio;\r\n\r\n        // Refresh the projection matrix and send set it in the shaders\r\n        this.refreshProjectionMatrix();\r\n\r\n        // Update the viewport dimensions to the canvas width\r\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    createGameObject (settings) {\r\n        let mesh = new Mesh(this.gl);\r\n        if (settings.shape === SHAPE.CUBE) {\r\n            mesh.createCube();\r\n        }\r\n        else if (settings.shape === SHAPE.SPHERE) {\r\n            mesh.createSphere(32);\r\n        }\r\n        else if (settings.shape === SHAPE.CYLINDER_SMOOTH) {\r\n            mesh.createCylinderSmooth(32, 1, 1, 2);\r\n        }\r\n        else if(settings.shape === SHAPE.CYLINDER_SHARP) {\r\n            mesh.createCylinderSharp(8, 1, 2);\r\n        }\r\n        else if (settings.shape === SHAPE.PLANE) {\r\n            mesh.createPlane(200, 200);\r\n        }\r\n        mesh.setColor(settings.color);\r\n\r\n        let obj = new GameObject (settings.name);\r\n        obj.setPosition(settings.position);\r\n        obj.setScale(settings.scale);\r\n        obj.addMesh(mesh);\r\n        obj.setShader(settings.shader);\r\n\r\n        return obj;\r\n    }\r\n\r\n    createPointLightSource(settings) {\r\n        // Create the light source component\r\n        let lightSource = new PointLightSource(settings.name);\r\n        lightSource.setPosition(settings.position);\r\n        lightSource.setScale(settings.scale);\r\n        lightSource.setLightColor(settings.color);\r\n        lightSource.setAttenuation(settings.attenuation.kLinear, settings.attenuation.kQuadratic);\r\n\r\n        // Create a model for the light source\r\n        let lightSourceModel = new Mesh(this.gl);\r\n        lightSourceModel.createSphere(8);\r\n        lightSourceModel.setColor(settings.color);\r\n        lightSource.addMesh(lightSourceModel);\r\n\r\n        return lightSource;\r\n    }\r\n\r\n    loadDefaultScene(scene) {\r\n        // Initiate procedural shader inputs\r\n        this.updateWaveParameter(\"harmonicAmplitude\");\r\n        this.updateWaveParameter(\"harmonicWaveLength\");\r\n        this.updateWaveParameter(\"harmonicSpeed\");\r\n        this.updateWaveParameter(\"waveSharpness\");\r\n        this.updateWaveParameter(\"harmonicDirectionAngle\");\r\n        const color = ConnectionManager.getItemValue('waterColor');\r\n\r\n        // Create four planes for visualizing a water surface\r\n        let plane1 = this.createGameObject({\r\n            shape: SHAPE.PLANE,\r\n            name: 'Waves',\r\n            scale: [1.0, 1.0, 1.0],\r\n            position: [0.0, 10.0, 100.0],\r\n            color: [color.r, color.g, color.b],\r\n            shader: 'procedural'\r\n        });\r\n\r\n        // Add water planes to the scene\r\n        scene.addGameObject(plane1);\r\n        this.water =[];\r\n        this.water.push(plane1);\r\n\r\n        // Wall dimensions\r\n        const wallHeight = 20.0;\r\n        const wallWidth = 100.0;\r\n\r\n        // Create gray floor\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Floor',\r\n            scale: [wallWidth, 0.1, wallWidth],\r\n            position: [0.0, -0.1, 0.0],\r\n            color: [0.75, 0.75, 0.75],\r\n            shader: 'phong'\r\n        }));\r\n\r\n        // Create blue walls\r\n        let wallColor = [1.0, 1.0, 1.0];\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Left Wall',\r\n            scale: [0.1, wallHeight, wallWidth],\r\n            position: [-wallWidth, wallHeight, 0.0],\r\n            color: wallColor,\r\n            shader: 'phong'\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Right Wall',\r\n            scale: [0.1, wallHeight, wallWidth],\r\n            position: [wallWidth, wallHeight, 0.0],\r\n            color: wallColor,\r\n            shader: 'phong'\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Back Wall',\r\n            scale: [wallWidth, wallHeight, 0.1],\r\n            position: [0.0, wallHeight, -wallWidth],\r\n            color: wallColor,\r\n            shader: 'phong'\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Front Wall',\r\n            scale: [wallWidth, wallHeight, 0.1],\r\n            position: [0.0, wallHeight, wallWidth],\r\n            color: wallColor,\r\n            shader: 'phong'\r\n        }));\r\n\r\n        // Create a point lights for the scene\r\n        // Add the light source to our scene\r\n        let atten = {// The attenuation constants should make the light travel a maximum distance of 325\r\n            kLinear: 0.014,\r\n            kQuadratic: 0.0007\r\n        };\r\n\r\n        let lampRadius = 1.0;\r\n        let lampHeight = 2.0 * wallHeight - lampRadius;\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [0.0, lampHeight, -wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Right Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [wallWidth*0.75, lampHeight, -wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Left Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [-wallWidth*0.75, lampHeight, -wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [0.0, lampHeight, wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Right Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [wallWidth*0.75, lampHeight, wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Left Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [-wallWidth*0.75, lampHeight, wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        // Middle section\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Left Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [-wallWidth*0.75, lampHeight, 0.0],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Right Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [wallWidth*0.75, lampHeight, 0.0],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [0.0, lampHeight, 0.0],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: atten\r\n        }));\r\n    }\r\n\r\n    setUpWebGL() {\r\n        // 2D Canvas for text display\r\n        this.context2D = document.getElementById('text-canvas').getContext('2d');\r\n\r\n        // WebGL canvas\r\n        this.canvas = document.getElementById(\"gl-canvas\");\r\n        // Initialize the WebGL context\r\n        this.gl = this.canvas.getContext(\"webgl\");\r\n\r\n        // If WebGL isn't supported\r\n        if (!this.gl) {\r\n            console.log(\"WebGL is not supported\");\r\n            alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n            return 0;\r\n        }\r\n\r\n        // Set the viewport dimensions to the same as the canvas\r\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n        // Set clear color to dark blue, fully opaque\r\n        this.gl.clearColor(0.02, 0.02, 0.02, 1.0);\r\n        // Enable depth so that triangles closer to the camera don't get overlapped by those further away\r\n        this.gl.enable(this.gl.DEPTH_TEST);\r\n        // Only draw \"visible\" sides (memory saving)\r\n        this.gl.enable(this.gl.CULL_FACE);\r\n        this.gl.cullFace(this.gl.BACK);\r\n        this.gl.frontFace(this.gl.CCW);\r\n    }\r\n\r\n    refreshProjectionMatrix() {\r\n        // Create a new projection matrix\r\n        this.projectionMatrix = Matrix4.perspective(this.fieldOfView, this.viewportAspectRatio, 0.1, 10000.0);\r\n\r\n        // Update the projection matrix in the editor\r\n        this.editor.projectionMatrix = this.projectionMatrix;\r\n\r\n        // Update the projection matrix for the shaders\r\n        this.shaders.forEach((shader) => {\r\n            shader.activate();\r\n            shader.setProjectionUniform(this.projectionMatrix);\r\n        });\r\n    }\r\n\r\n    updateWaveParameter(tag) {\r\n        let newValue = ConnectionManager.getItemValue(tag);\r\n\r\n        if(tag === \"waterColor\") {\r\n            this.water.forEach((o)=> {\r\n                o.meshes[0].setColor([newValue.r, newValue.g, newValue.b]);\r\n            });\r\n        }\r\n        else {\r\n            let proceduralShader = this.shaders.get(\"procedural\");\r\n            proceduralShader.activate();\r\n\r\n            let uniformLocation = proceduralShader.getUniformLoc(tag);\r\n            proceduralShader.setUniformFloat(uniformLocation, newValue);\r\n        }\r\n    }\r\n}\r\n\r\nexport default Engine;"]},"metadata":{},"sourceType":"module"}