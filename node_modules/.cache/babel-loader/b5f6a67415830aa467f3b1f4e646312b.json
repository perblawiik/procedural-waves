{"ast":null,"code":"import Transform from \"./Transform\";\nimport ShapeGenerator from \"./ShapeGenerator\";\n\nclass Mesh {\n  constructor(shader) {\n    this.shader = shader;\n    this.gl = shader.gl;\n    this.positionAttributeLocation = shader.positionAttributeLocation;\n    this.normalAttributeLocation = shader.normalAttributeLocation;\n    this.textureAttributeLocation = shader.textureAttributeLocation;\n    this.colorUniformLocation = shader.colorUniformLocation;\n    this.matrixUniformLocation = shader.worldViewUniformLocation;\n    this.timeUniformLocation = shader.timeUniformLocation;\n    this.totalVertices = 0;\n    this.color = [0.5, 0.5, 0.5];\n    this.shape = null;\n    this.time = 0;\n    this.transform = new Transform();\n  }\n\n  clone() {\n    let clone = new Mesh(this.shader);\n    if (this.shape === 'cube') clone.createCube();else if (this.shape === 'sphere') clone.createSphere(64);\n    clone.setColor(this.color);\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  setPosition(pos) {\n    this.transform.setPosition(pos);\n  }\n\n  setScale(scale) {\n    this.transform.setScale(scale);\n  }\n\n  setRotation(rot) {\n    this.transform.setRotation(rot);\n  }\n\n  render(time) {\n    if (this.shape) {\n      this.time = time;\n      this.updateUniforms();\n      this.bindBuffersAndEnableAttributes(); // Draw our graphics\n      // Param 1 specifies how to draw from vertices,\n      // param 2 is how many vertices we use to draw\n      // param 3 is what type the elements are\n      // param 4 is the starting point from the array\n\n      this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\n      this.unbindBuffers();\n    } else {\n      console.log(\"ERROR! The mesh got no shape!\");\n    }\n  }\n\n  updateUniforms() {\n    this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\n    this.gl.uniform3fv(this.colorUniformLocation, this.color);\n    this.gl.uniform1f(this.timeUniformLocation, this.time);\n  }\n\n  unbindBuffers() {\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  bindBuffersAndEnableAttributes() {\n    // Vertex buffer\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); // Enable vertex attribute\n\n    this.gl.vertexAttribPointer(this.positionAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.FALSE, // Don't normalize the data\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\n    0 // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.positionAttributeLocation); // Enable normal attribute\n\n    this.gl.vertexAttribPointer(this.normalAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.TRUE, // Not normalized\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\n    3 * Float32Array.BYTES_PER_ELEMENT // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.normalAttributeLocation); // Index buffer\n\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  }\n\n  createCylinder(vertSeg, horizSeg) {\n    this.shape = 'cylinder';\n    let horizontalSegments = horizSeg;\n    let verticalSegments = vertSeg;\n\n    if (horizontalSegments < 1) {\n      horizontalSegments = 1;\n    }\n\n    if (verticalSegments < 4) {\n      verticalSegments = 4;\n    }\n\n    let vertices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.0;\n    vertices[7] = 0.0; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -Math.PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0;\n    let index = 7; // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = -1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0; // Generate middle part vertices with normals\n\n    for (let i = 0; i <= horizontalSegments; ++i) {\n      let y = Math.cos(theta);\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += 2 * Math.PI / verticalSegments;\n      }\n\n      theta += Math.PI / horizontalSegments;\n    }\n\n    phi = 0; // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = 1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = verticalSegments + 2;\n\n    for (let i = 0; i < horizontalSegments; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top circle plane\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    this.totalVertices = indices.length; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createSphere(segments) {\n    this.shape = 'sphere';\n    /*\r\n    let horizontalSegments = segments;\r\n      if (horizontalSegments < 2) {\r\n        horizontalSegments = 2;\r\n    }\r\n    let verticalSegments = 2*horizontalSegments;\r\n      let vertices = [];\r\n      // Bottom vertex and its normal (x, y, z)\r\n    vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n    vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n    vertices[6] = 0.0; vertices[7] = 0.0;\r\n      let sampleResolution = Math.PI/horizontalSegments;\r\n    let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\r\n    let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n      // Generate middle part vertices with normals\r\n    let index = 7;\r\n    for(let i = 0; i < horizontalSegments-1; ++i) {\r\n        let y = Math.cos(theta);\r\n        let R = Math.sin(theta); // radius\r\n          for (let j = 0; j < verticalSegments+1; ++j) {\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = R*Math.sin(phi);\r\n            vertices[++index] = y;\r\n            vertices[++index] = R*Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = R*Math.sin(phi);\r\n            vertices[++index] = y;\r\n            vertices[++index] = R*Math.cos(phi);\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n              phi += sampleResolution;\r\n        }\r\n        theta += sampleResolution;\r\n    }\r\n      // Top vertex and its normal (x, y, z)\r\n    vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n    vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n    vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n       */\n\n    /* Generate Index Array */\n    // Bottom cap\n\n    /*\r\n    let indices = [];\r\n    index = -1;\r\n    for (let i = 0; i < verticalSegments; ++i) {\r\n        indices[++index] = 0;\r\n          if( (i+2) <= verticalSegments)\r\n            indices[++index] = i+2;\r\n        else\r\n            indices[++index] = (i+2)-verticalSegments;\r\n          indices[++index] = i+1;\r\n    }\r\n      // Middle part\r\n    let v0 = 1;\r\n    for(let i = 0; i < horizontalSegments-2; i++) {\r\n        for (let j = 0; j < verticalSegments; ++j) {\r\n            // One rectangle at a time (two triangles)\r\n            indices[++index] = v0;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n        indices[++index] = v0;\r\n        indices[++index] = (v0 + 1) - verticalSegments;\r\n        indices[++index] = verticalSegments + v0;\r\n        indices[++index] = (v0 + 1) - verticalSegments;\r\n        indices[++index] = v0 + 1;\r\n        indices[++index] = verticalSegments + v0;\r\n        ++v0;\r\n    }\r\n      // Top cap\r\n    let lastVertexIndex = (vertices.length/8)-1;\r\n    for (let i = 0; i < verticalSegments; ++i) {\r\n          indices[++index] = lastVertexIndex;\r\n          if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n            indices[++index] = lastVertexIndex-2-i;\r\n        else\r\n            indices[++index] = lastVertexIndex-verticalSegments-1;\r\n          indices[++index] = lastVertexIndex-1-i;\r\n    }\r\n      this.totalVertices = indices.length;\r\n    */\n    // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createCube() {\n    this.shape = 'cube';\n    let cubeData = ShapeGenerator.generateCubeData();\n    this.totalVertices = cubeData.numVertices; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cubeData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createPlane(rows, columns) {\n    this.shape = 'plane';\n    let index = 0;\n    let x = 0;\n    let vertexArray = []; // Generate and store coordinates in vertex array\n\n    for (let i = 0; i <= columns; ++i) {\n      x = -(rows / 2);\n\n      for (let k = 0; k <= rows; ++k) {\n        // Storing one vertex at the time (x,y,z)\n        vertexArray[index] = x;\n        vertexArray[index + 1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\n\n        vertexArray[index + 2] = -i; // Set normals\n\n        vertexArray[index + 3] = 0.0;\n        vertexArray[index + 4] = 1.0;\n        vertexArray[index + 5] = 0.0; // Texture coordinates\n\n        vertexArray[index + 6] = 0.0;\n        vertexArray[index + 7] = 0.0; // We go from left to right in the direction of x-axis\n\n        ++x; // Increase by three since we store values in three indices at the time\n\n        index += 8;\n      }\n    } // v0-v3 represent the four vertices in one quad\n\n\n    let v0 = 0;\n    let v1 = 1;\n    let v2 = rows + 2;\n    let v3 = rows + 1;\n    index = 0;\n    let indexArray = []; // Store indices in index array\n\n    for (let j = 0; j < columns; ++j) {\n      // Each iteration generates the order of vertex indices for one full quad\n      for (let l = 0; l < rows; ++l) {\n        // Triangle 1\n        indexArray[index] = v0;\n        indexArray[index + 1] = v1;\n        indexArray[index + 2] = v2; // Triangle 2\n\n        indexArray[index + 3] = v2;\n        indexArray[index + 4] = v3;\n        indexArray[index + 5] = v0; // Increase for next quad\n\n        ++v0;\n        ++v1;\n        ++v2;\n        ++v3;\n        index += 6;\n      } // Increase one more time after a full row of quads\n\n\n      ++v0;\n      ++v1;\n      ++v2;\n      ++v3;\n    } //this.totalTriangles = rows*columns*2;\n    //this.totalVertices = this.totalTriangles*3;\n\n\n    this.totalVertices = indexArray.length; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n}\n\nexport default Mesh;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Mesh.js"],"names":["Transform","ShapeGenerator","Mesh","constructor","shader","gl","positionAttributeLocation","normalAttributeLocation","textureAttributeLocation","colorUniformLocation","matrixUniformLocation","worldViewUniformLocation","timeUniformLocation","totalVertices","color","shape","time","transform","clone","createCube","createSphere","setColor","setPosition","pos","setScale","scale","setRotation","rot","render","updateUniforms","bindBuffersAndEnableAttributes","drawElements","TRIANGLES","UNSIGNED_SHORT","unbindBuffers","console","log","uniformMatrix4fv","FALSE","matrix","uniform3fv","uniform1f","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","vertexBuffer","vertexAttribPointer","FLOAT","Float32Array","BYTES_PER_ELEMENT","enableVertexAttribArray","TRUE","indexBuffer","createCylinder","vertSeg","horizSeg","horizontalSegments","verticalSegments","vertices","theta","Math","PI","phi","index","j","sin","cos","i","y","indices","v0","lastVertexIndex","length","createBuffer","bufferData","STATIC_DRAW","Uint16Array","segments","cubeData","generateCubeData","numVertices","createPlane","rows","columns","x","vertexArray","k","v1","v2","v3","indexArray","l"],"mappings":"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","sourcesContent":["\r\nimport Transform from \"./Transform\";\r\nimport ShapeGenerator from \"./ShapeGenerator\";\r\n\r\nclass Mesh {\r\n    constructor(shader) {\r\n        this.shader = shader;\r\n        this.gl = shader.gl;\r\n        this.positionAttributeLocation = shader.positionAttributeLocation;\r\n        this.normalAttributeLocation = shader.normalAttributeLocation;\r\n        this.textureAttributeLocation = shader.textureAttributeLocation;\r\n        this.colorUniformLocation = shader.colorUniformLocation;\r\n        this.matrixUniformLocation = shader.worldViewUniformLocation;\r\n        this.timeUniformLocation = shader.timeUniformLocation;\r\n\r\n        this.totalVertices = 0;\r\n\r\n        this.color = [0.5, 0.5, 0.5];\r\n        this.shape = null;\r\n        this.time = 0;\r\n\r\n        this.transform = new Transform();\r\n    }\r\n\r\n    clone() {\r\n        let clone = new Mesh(this.shader);\r\n\r\n        if (this.shape === 'cube')\r\n            clone.createCube();\r\n        else if (this.shape === 'sphere')\r\n            clone.createSphere(64);\r\n\r\n        clone.setColor(this.color);\r\n        clone.transform = this.transform.clone();\r\n        return clone;\r\n    }\r\n\r\n    setColor(color) {\r\n        this.color = color;\r\n    }\r\n\r\n    setPosition(pos) {\r\n        this.transform.setPosition(pos);\r\n    }\r\n\r\n    setScale (scale) {\r\n        this.transform.setScale(scale);\r\n    }\r\n\r\n    setRotation (rot) {\r\n        this.transform.setRotation(rot);\r\n    }\r\n\r\n    render(time) {\r\n        if (this.shape) {\r\n            this.time = time;\r\n            this.updateUniforms();\r\n            this.bindBuffersAndEnableAttributes();\r\n            // Draw our graphics\r\n            // Param 1 specifies how to draw from vertices,\r\n            // param 2 is how many vertices we use to draw\r\n            // param 3 is what type the elements are\r\n            // param 4 is the starting point from the array\r\n            this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\r\n            this.unbindBuffers();\r\n        }\r\n        else {\r\n            console.log(\"ERROR! The mesh got no shape!\");\r\n        }\r\n    }\r\n\r\n    updateUniforms() {\r\n        this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\r\n        this.gl.uniform3fv(this.colorUniformLocation, this.color);\r\n        this.gl.uniform1f(this.timeUniformLocation, this.time);\r\n    }\r\n\r\n    unbindBuffers() {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    bindBuffersAndEnableAttributes() {\r\n        // Vertex buffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n\r\n        // Enable vertex attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.positionAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.FALSE, // Don't normalize the data\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\r\n            0// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.positionAttributeLocation);\r\n\r\n        // Enable normal attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.normalAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.TRUE, // Not normalized\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\r\n            3 * Float32Array.BYTES_PER_ELEMENT// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.normalAttributeLocation);\r\n\r\n        // Index buffer\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n    }\r\n\r\n    createCylinder (vertSeg, horizSeg) {\r\n        this.shape = 'cylinder';\r\n\r\n        let horizontalSegments = horizSeg;\r\n        let verticalSegments = vertSeg;\r\n\r\n        if (horizontalSegments < 1) {\r\n            horizontalSegments = 1;\r\n        }\r\n        if (verticalSegments < 4) {\r\n            verticalSegments = 4;\r\n        }\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -Math.PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0;\r\n\r\n        let index = 7;\r\n        // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0;\r\n        // Generate middle part vertices with normals\r\n        for(let i = 0; i <= horizontalSegments; ++i) {\r\n\r\n            let y = Math.cos(theta);\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += (2*Math.PI)/verticalSegments;\r\n            }\r\n            theta += Math.PI/horizontalSegments;\r\n        }\r\n\r\n        phi = 0;\r\n        // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = verticalSegments+2;\r\n        for(let i = 0; i < horizontalSegments; i++) {\r\n\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n\r\n        // Top circle plane\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        this.totalVertices = indices.length;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createSphere (segments) {\r\n        this.shape = 'sphere';\r\n        /*\r\n        let horizontalSegments = segments;\r\n\r\n        if (horizontalSegments < 2) {\r\n            horizontalSegments = 2;\r\n        }\r\n        let verticalSegments = 2*horizontalSegments;\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom vertex and its normal (x, y, z)\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        let sampleResolution = Math.PI/horizontalSegments;\r\n        let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = 7;\r\n        for(let i = 0; i < horizontalSegments-1; ++i) {\r\n            let y = Math.cos(theta);\r\n            let R = Math.sin(theta); // radius\r\n\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += sampleResolution;\r\n            }\r\n            theta += sampleResolution;\r\n        }\r\n\r\n        // Top vertex and its normal (x, y, z)\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n           */\r\n        /* Generate Index Array */\r\n        // Bottom cap\r\n        /*\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for(let i = 0; i < horizontalSegments-2; i++) {\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top cap\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        this.totalVertices = indices.length;\r\n        */\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createCube() {\r\n        this.shape = 'cube';\r\n        let cubeData = ShapeGenerator.generateCubeData();\r\n        this.totalVertices = cubeData.numVertices;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cubeData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createPlane (rows, columns) {\r\n        this.shape = 'plane';\r\n\r\n        let index = 0;\r\n        let x = 0;\r\n        let vertexArray = [];\r\n        // Generate and store coordinates in vertex array\r\n        for (let i = 0; i <= columns; ++i) {\r\n            x = -(rows/2);\r\n            for (let k = 0; k <= rows; ++k) {\r\n                // Storing one vertex at the time (x,y,z)\r\n                vertexArray[index] = x;\r\n                vertexArray[index+1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\r\n                vertexArray[index+2] = -i;\r\n\r\n                // Set normals\r\n                vertexArray[index+3] = 0.0;\r\n                vertexArray[index+4] = 1.0;\r\n                vertexArray[index+5] = 0.0;\r\n\r\n                // Texture coordinates\r\n                vertexArray[index+6] = 0.0;\r\n                vertexArray[index+7] = 0.0;\r\n\r\n                // We go from left to right in the direction of x-axis\r\n                ++x;\r\n                // Increase by three since we store values in three indices at the time\r\n                index += 8;\r\n            }\r\n        }\r\n\r\n        // v0-v3 represent the four vertices in one quad\r\n        let v0 = 0;\r\n        let v1 = 1;\r\n        let v2 = rows+2;\r\n        let v3 = rows+1;\r\n        index = 0;\r\n        let indexArray = [];\r\n        // Store indices in index array\r\n        for (let j = 0; j < columns; ++j) {\r\n            // Each iteration generates the order of vertex indices for one full quad\r\n            for (let l = 0; l < rows; ++l) {\r\n                // Triangle 1\r\n                indexArray[index] = v0;\r\n                indexArray[index + 1] = v1;\r\n                indexArray[index + 2] = v2;\r\n                // Triangle 2\r\n                indexArray[index + 3] = v2;\r\n                indexArray[index + 4] = v3;\r\n                indexArray[index + 5] = v0;\r\n\r\n                // Increase for next quad\r\n                ++v0;\r\n                ++v1;\r\n                ++v2;\r\n                ++v3;\r\n                index += 6;\r\n            }\r\n            // Increase one more time after a full row of quads\r\n            ++v0;\r\n            ++v1;\r\n            ++v2;\r\n            ++v3;\r\n        }\r\n        //this.totalTriangles = rows*columns*2;\r\n        //this.totalVertices = this.totalTriangles*3;\r\n        this.totalVertices = indexArray.length;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    };\r\n}\r\n\r\nexport default Mesh;"]},"metadata":{},"sourceType":"module"}