{"ast":null,"code":"//TODO: Implement a sky box background\n//TODO: Implement cubic shadow mapping\n//TODO: Implement a ParticleSystem component\n// JavaScript components\nimport GameEditor from \"./GameEditor\";\nimport Time from \"./Time\";\nimport Raycast from \"./Raycast\";\nimport CollisionManager from \"./CollisionManager\";\nimport EventHandler from \"./events/EventHandler\";\nimport MouseEvent from \"./events/MouseEvent\";\nimport Scene from \"./Scene\";\nimport Camera from \"./Camera\";\nimport GameObject from \"./GameObject\";\nimport Mesh from \"./Mesh\";\nimport PointLightSource from \"./PointLightSource\";\nimport SphereCollider from \"./SphereCollider\";\nimport ParticleEmitter from \"./ParticleEmitter\";\nimport RigidBody from \"./RigidBody\";\nimport Matrix4 from \"./math/Matrix4\";\nimport Vector3 from \"./math/Vector3\";\nimport Transform from \"./Transform\"; // Shader\n\nimport ShaderHandle from \"./ShaderHandle\";\nimport PhongLightingShader from \"./shaders/PhongLightingShader\";\nimport AmbientShader from \"./shaders/AmbientShader\";\n/***** Settings *****/\n// Default camera position and rotation\n\nconst CAMERA_POSITION = [0.0, 5.0, 60.0];\nconst CAMERA_ROTATION = [0.0, 0.0, 0.0]; // Enum struct for creating different shapes\n\nconst SHAPE = {\n  CUBE: 0,\n  SPHERE: 1,\n  CYLINDER_SMOOTH: 2,\n  CYLINDER_SHARP: 3,\n  PLANE: 4\n};\nconst MS_PER_UPDATE = 4.0;\nconst UPDATE_TIME_STEP = 0.01;\n\nclass Engine {\n  constructor() {\n    // Scenes works like blocks in the game world.\n    // The active scenes are based on the cameras distance to the origin of each scene.\n    this.scenes = [];\n    this.shaders = new Map();\n    this.viewportAspectRatio = 1.0;\n    this.lag = 0.0;\n  }\n  /*\r\n  * @brief This is the engines main update function and is called every iteration of the main loop\r\n  */\n\n\n  run() {\n    // Update game loop clock\n    Time.update(); // Time start of the loop\n\n    let startTime = Time.now; // Process mouse and keyboard events\n\n    this.processInputEvents(); // Add elapsed time to the lag variable\n\n    this.lag += Time.deltaTime; // Make sure the update function is called on a constant rate\n\n    while (this.lag >= MS_PER_UPDATE) {\n      // Updates game object animations, ai, physics, etc.\n      this.update(); // Clear momentary events\n\n      EventHandler.resetMouseEvents();\n      this.lag -= MS_PER_UPDATE;\n    } // Render graphics\n\n\n    this.render(this.lag / MS_PER_UPDATE); // Hold each frame for a specified number of milliseconds (16 ms locks on roughly 60 fps)\n\n    while (Time.now - startTime < 16.0); // Sleep\n\n  }\n\n  update() {\n    this.scenes.forEach(scene => {\n      scene.update(UPDATE_TIME_STEP);\n    }); //// SPRINKLER UPDATE ////\n\n    this.sprinklerTransform.rotate([0.0, 1.0, 0.0]);\n    this.sprinklerTimer += UPDATE_TIME_STEP;\n\n    if (this.sprinklerTimer > 0.1) {\n      let pos = [this.sprinklerTransform.position.x, this.sprinklerTransform.position.y, this.sprinklerTransform.position.z];\n      this.sprinkler.emitParticle(pos, this.sprinklerTransform.xAxis);\n      this.sprinklerTimer = 0.0;\n    }\n\n    this.sprinkler.update(UPDATE_TIME_STEP); //// SPRINKLER UPDATE ////\n    //// RAYCAST BULLETS UPDATE ////\n\n    this.raycastBullets.update(UPDATE_TIME_STEP); //// RAYCAST BULLETS UPDATE ////\n  }\n\n  render(residualLag) {\n    // Set the viewport to the canvas dimensions and update the aspect ratio for the projection matrix\n    this.updateViewportDimensions(); // Clear screen 3D\n\n    this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT); // Draw scenes\n\n    this.gl.enable(this.gl.DEPTH_TEST);\n    this.scenes.forEach(scene => {\n      //scene.updateLightPositions();\n      scene.draw();\n    }); //// SPRINKLER RENDER ////\n\n    this.sprinkler.render(this.shaders.get(\"phong\")); //// SPRINKLER RENDER ////\n    //// RAYCAST BULLETS RENDER ////\n\n    this.raycastBullets.render(this.shaders.get(\"phong\")); //// RAYCAST BULLETS RENDER ////\n    // Display fps and other useful information\n\n    this.editor.render(this.scenes);\n  }\n\n  processInputEvents() {\n    // Process editor commands\n    this.editor.processUserInput(); // If left mouse button is pressed, cast a ray from the mouse cursor position\n\n    if (MouseEvent.mouseDown && MouseEvent.isPressed.leftButton) {// Create a raycast bullet for visualization purpose\n      //let ray = Raycast.raycastFromMouseCursor(MouseEvent.offsetX, MouseEvent.offsetY, this.camera.transform, this.projectionMatrix, this.canvas.width, this.canvas.height);\n      // Offset the bullet start point\n      //const bulletOrigin = [ray.origin.x + ray.direction.x*2.0, ray.origin.y + ray.direction.y*2.0, ray.origin.z + ray.direction.z*2.0];\n      //this.raycastBullets.emitParticle(bulletOrigin, ray.direction);\n    }\n  } // This function is called before the game loop is started\n\n\n  preload() {\n    // Initiate static classes\n    Time.init();\n    EventHandler.init();\n    CollisionManager.init(); // Set up webgl 2D and 3D context from html canvas. Viewport and render settings are also set.\n\n    this.setUpWebGL(); // Create shaders\n\n    let mainShader = new ShaderHandle(this.canvas, PhongLightingShader.vertex, PhongLightingShader.fragment);\n    let ambientShader = new ShaderHandle(this.canvas, AmbientShader.vertex, AmbientShader.fragment); // Add them to the shaders container\n\n    this.shaders.set(\"phong\", mainShader);\n    this.shaders.set(\"ambient\", ambientShader); // Initialize the main camera\n\n    this.camera = new Camera(this.shaders);\n    this.camera.setPosition(CAMERA_POSITION);\n    this.camera.setRotation(CAMERA_ROTATION); // Initialize the game engine editor used for managing the game scenes\n\n    this.editor = new GameEditor(this.gl, this.context2D, this.shaders, this.camera, this.canvas); // Create and set the projection matrix for the shaders\n\n    this.fieldOfView = Math.PI / 6;\n    this.viewportAspectRatio = this.canvas.width / this.canvas.height;\n    this.refreshProjectionMatrix();\n    this.setUpGameContent();\n  }\n\n  setUpGameContent() {\n    // Create a scene for the objects\n    let defaultScene = new Scene(this.shaders); // Create scene objects\n\n    this.loadDefaultScene(defaultScene); // Add to scenes\n\n    this.scenes.push(defaultScene); // Create a bullet for displaying raycast\n\n    let bulletModel = this.createGameObject({\n      shape: SHAPE.SPHERE,\n      name: 'Cyan Sphere',\n      scale: [1.0, 1.0, 1.0],\n      position: [0.0, 0.0, 0.0],\n      color: [0.0, 1.0, 1.0]\n    });\n    let initialSpeed = 80.0;\n    let lifetime = 10.0;\n    this.raycastBullets = new ParticleEmitter(bulletModel, initialSpeed, lifetime);\n    this.raycastBullets.enableGravity(true);\n    this.sprinkler = new ParticleEmitter(bulletModel, 50.0, 30.0);\n    this.sprinkler.enableGravity(true);\n    this.sprinklerTransform = new Transform();\n    this.sprinklerTransform.setPosition([0.0, 40.0, 0.0]);\n    this.sprinklerTimer = 0.0;\n  }\n\n  updateViewportDimensions() {\n    // Calculate current aspect ratio\n    let currentAspectRatio = this.canvas.width / this.canvas.height; // Check if the aspect ratio has changed before going further\n\n    if (Math.abs(this.viewportAspectRatio - currentAspectRatio) < 0.001) return; // Save new aspect ratio\n\n    this.viewportAspectRatio = currentAspectRatio; // Refresh the projection matrix and send set it in the shaders\n\n    this.refreshProjectionMatrix(); // Update the viewport dimensions to the canvas width\n\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  createGameObject(settings) {\n    let mesh = new Mesh(this.gl);\n\n    if (settings.shape === SHAPE.CUBE) {\n      mesh.createCube();\n    } else if (settings.shape === SHAPE.SPHERE) {\n      mesh.createSphere(32);\n    } else if (settings.shape === SHAPE.CYLINDER_SMOOTH) {\n      mesh.createCylinderSmooth(32, 1, 1, 2);\n    } else if (settings.shape === SHAPE.CYLINDER_SHARP) {\n      mesh.createCylinderSharp(8, 1, 2);\n    } else if (settings.shape === SHAPE.PLANE) {\n      mesh.createPlane(50, 50);\n    }\n\n    mesh.setColor(settings.color);\n    let obj = new GameObject(settings.name);\n    obj.setPosition(settings.position);\n    obj.setScale(settings.scale);\n    obj.addMesh(mesh);\n\n    if (!settings.static) {\n      let rb = new RigidBody(settings.position, 5.0);\n      rb.enableGravity(true);\n      CollisionManager.registerRigidBody(rb);\n      obj.setRigidBody(rb);\n    }\n\n    return obj;\n  }\n\n  createPointLightSource(settings) {\n    // Create the light source component\n    let lightSource = new PointLightSource(settings.name);\n    lightSource.setPosition(settings.position);\n    lightSource.setScale(settings.scale);\n    lightSource.setLightColor(settings.color);\n    lightSource.setAttenuation(settings.attenuation.kLinear, settings.attenuation.kQuadratic); // Create a model for the light source\n\n    let lightSourceModel = new Mesh(this.gl);\n    lightSourceModel.createSphere(8);\n    lightSourceModel.setColor(settings.color);\n    lightSource.addMesh(lightSourceModel);\n    return lightSource;\n  }\n\n  loadDefaultScene(scene) {\n    /*\r\n    // Create a red cube\r\n    let cube = this.createGameObject({\r\n        shape: SHAPE.CUBE,\r\n        name: 'Red Cube',\r\n        scale: [2.0, 2.0, 2.0],\r\n        position: [0.0, 4, 0.0],\r\n        color: [1.0, 0.0, 0.0],\r\n        static: false\r\n    });\r\n    // Add rotation to the cube\r\n    cube.customUpdate = function(stepSize) {\r\n        //this.rotate([0.1, 0.1, 0.0]);\r\n    };\r\n    // Add cube to scene\r\n    scene.addGameObject(cube);\r\n    */\n\n    /*\r\n    // Create a smooth magenta cylinder\r\n    scene.addGameObject(this.createGameObject({\r\n        shape: SHAPE.CYLINDER_SMOOTH,\r\n        name: 'Magenta Cylinder',\r\n        scale: [2.0, 2.0, 2.0],\r\n        position: [-8.0, 4.0, 0.0],\r\n        color: [1.0, 0.0, 1.0],\r\n        static: false\r\n    }));\r\n    */\n    // Create a green spheres\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.SPHERE,\n      name: 'Green Sphere',\n      scale: [2.0, 2.0, 2.0],\n      position: [0.0, 4.0, 0.0],\n      color: [0.0, 1.0, 0.0],\n      static: false\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.SPHERE,\n      name: 'Green Sphere',\n      scale: [2.0, 2.0, 2.0],\n      position: [-4.2, 4.0, 0.0],\n      color: [0.0, 1.0, 0.0],\n      static: false\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.SPHERE,\n      name: 'Green Sphere',\n      scale: [2.0, 2.0, 2.0],\n      position: [4.2, 4.0, 0.0],\n      color: [0.0, 1.0, 0.0],\n      static: false\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.SPHERE,\n      name: 'Green Sphere',\n      scale: [2.0, 2.0, 2.0],\n      position: [8.2, 4.0, 0.0],\n      color: [0.0, 1.0, 0.0],\n      static: false\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.SPHERE,\n      name: 'Green Sphere',\n      scale: [2.0, 2.0, 2.0],\n      position: [-8.2, 4.0, 0.0],\n      color: [0.0, 1.0, 0.0],\n      static: false\n    }));\n    let wallHeight = 20.0;\n    let wallWidth = 100.0; // Create gray floor\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Floor',\n      scale: [wallWidth, 0.1, wallWidth],\n      position: [0.0, -0.1, 0.0],\n      color: [0.75, 0.75, 0.75],\n      static: true\n    })); // Create blue walls\n\n    let wallColor = [0.0, 0.2, 1.0];\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Left Wall',\n      scale: [0.1, wallHeight, wallWidth],\n      position: [-wallWidth, wallHeight, 0.0],\n      color: wallColor,\n      static: true\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Right Wall',\n      scale: [0.1, wallHeight, wallWidth],\n      position: [wallWidth, wallHeight, 0.0],\n      color: wallColor,\n      static: true\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Back Wall',\n      scale: [wallWidth, wallHeight, 0.1],\n      position: [0.0, wallHeight, -wallWidth],\n      color: wallColor,\n      static: true\n    }));\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Front Wall',\n      scale: [wallWidth, wallHeight, 0.1],\n      position: [0.0, wallHeight, wallWidth],\n      color: wallColor,\n      static: true\n    })); // Create gray roof\n\n    scene.addGameObject(this.createGameObject({\n      shape: SHAPE.CUBE,\n      name: 'Roof',\n      scale: [wallWidth, 0.1, wallWidth],\n      position: [0.0, wallHeight * 2.0, 0.0],\n      color: [0.65, 0.65, 0.65],\n      static: true\n    })); // Create a point lights for the scene\n    // Add the light source to our scene\n\n    let lampRadius = 0.5;\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [0.0, 2.0 * wallHeight - lampRadius, -wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Right Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [37.5, 2.0 * wallHeight - lampRadius, -wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Left Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [-37.5, 2.0 * wallHeight - lampRadius, -wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Middle Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [0.0, 2.0 * wallHeight - lampRadius, wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Right Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [37.5, 2.0 * wallHeight - lampRadius, wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    }));\n    scene.addLightSource(this.createPointLightSource({\n      name: \"Left Lamp\",\n      scale: [lampRadius, lampRadius, lampRadius],\n      position: [-37.5, 2.0 * wallHeight - lampRadius, wallWidth * 0.75],\n      color: [1.0, 1.0, 1.0],\n      attenuation: {\n        // The attenuation constants should make the light travel a maximum distance of 325\n        kLinear: 0.014,\n        kQuadratic: 0.0007\n      }\n    })); //// WORLD BOUNDARIES ////\n    // Ground plane\n\n    CollisionManager.registerPlaneCollider({\n      normal: new Vector3([0.0, 1.0, 0.0]),\n      offset: 0.0\n    });\n    CollisionManager.registerPlaneCollider({\n      normal: new Vector3([0.0, 0.0, 1.0]),\n      offset: wallWidth\n    });\n    CollisionManager.registerPlaneCollider({\n      normal: new Vector3([-1.0, 0.0, 0.0]),\n      offset: wallWidth\n    });\n    CollisionManager.registerPlaneCollider({\n      normal: new Vector3([1.0, 0.0, 0.0]),\n      offset: wallWidth\n    });\n    CollisionManager.registerPlaneCollider({\n      normal: new Vector3([0.0, 0.0, -1.0]),\n      offset: wallWidth\n    });\n    CollisionManager.registerPlaneCollider({\n      normal: new Vector3([0.0, -1.0, 0.0]),\n      offset: wallHeight * 2\n    });\n  }\n\n  setUpWebGL() {\n    // 2D Canvas for text display\n    this.context2D = document.getElementById('text-canvas').getContext('2d'); // WebGL canvas\n\n    this.canvas = document.getElementById(\"gl-canvas\"); // Initialize the WebGL context\n\n    this.gl = this.canvas.getContext(\"webgl\"); // If WebGL isn't supported\n\n    if (!this.gl) {\n      console.log(\"WebGL is not supported\");\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n      return 0;\n    } // Set the viewport dimensions to the same as the canvas\n\n\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height); // Set clear color to dark blue, fully opaque\n\n    this.gl.clearColor(0.02, 0.02, 0.02, 1.0); // Enable depth so that triangles closer to the camera don't get overlapped by those further away\n\n    this.gl.enable(this.gl.DEPTH_TEST); // Only draw \"visible\" sides (memory saving)\n\n    this.gl.enable(this.gl.CULL_FACE);\n    this.gl.cullFace(this.gl.BACK);\n    this.gl.frontFace(this.gl.CCW);\n  }\n\n  refreshProjectionMatrix() {\n    // Create a new projection matrix\n    this.projectionMatrix = Matrix4.perspective(this.fieldOfView, this.viewportAspectRatio, 0.1, 10000.0); // Update the projection matrix in the editor\n\n    this.editor.projectionMatrix = this.projectionMatrix; // Update the projection matrix for the shaders\n\n    this.shaders.forEach(shader => {\n      shader.activate();\n      shader.setProjectionUniform(this.projectionMatrix);\n    });\n  }\n\n}\n\nexport default Engine;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Engine.js"],"names":["GameEditor","Time","Raycast","CollisionManager","EventHandler","MouseEvent","Scene","Camera","GameObject","Mesh","PointLightSource","SphereCollider","ParticleEmitter","RigidBody","Matrix4","Vector3","Transform","ShaderHandle","PhongLightingShader","AmbientShader","CAMERA_POSITION","CAMERA_ROTATION","SHAPE","CUBE","SPHERE","CYLINDER_SMOOTH","CYLINDER_SHARP","PLANE","MS_PER_UPDATE","UPDATE_TIME_STEP","Engine","constructor","scenes","shaders","Map","viewportAspectRatio","lag","run","update","startTime","now","processInputEvents","deltaTime","resetMouseEvents","render","forEach","scene","sprinklerTransform","rotate","sprinklerTimer","pos","position","x","y","z","sprinkler","emitParticle","xAxis","raycastBullets","residualLag","updateViewportDimensions","gl","clear","DEPTH_BUFFER_BIT","COLOR_BUFFER_BIT","enable","DEPTH_TEST","draw","get","editor","processUserInput","mouseDown","isPressed","leftButton","preload","init","setUpWebGL","mainShader","canvas","vertex","fragment","ambientShader","set","camera","setPosition","setRotation","context2D","fieldOfView","Math","PI","width","height","refreshProjectionMatrix","setUpGameContent","defaultScene","loadDefaultScene","push","bulletModel","createGameObject","shape","name","scale","color","initialSpeed","lifetime","enableGravity","currentAspectRatio","abs","viewport","settings","mesh","createCube","createSphere","createCylinderSmooth","createCylinderSharp","createPlane","setColor","obj","setScale","addMesh","static","rb","registerRigidBody","setRigidBody","createPointLightSource","lightSource","setLightColor","setAttenuation","attenuation","kLinear","kQuadratic","lightSourceModel","addGameObject","wallHeight","wallWidth","wallColor","lampRadius","addLightSource","registerPlaneCollider","normal","offset","document","getElementById","getContext","console","log","alert","clearColor","CULL_FACE","cullFace","BACK","frontFace","CCW","projectionMatrix","perspective","shader","activate","setProjectionUniform"],"mappings":"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","sourcesContent":["//TODO: Implement a sky box background\r\n//TODO: Implement cubic shadow mapping\r\n//TODO: Implement a ParticleSystem component\r\n\r\n// JavaScript components\r\nimport GameEditor from \"./GameEditor\";\r\nimport Time from \"./Time\";\r\nimport Raycast from \"./Raycast\";\r\nimport CollisionManager from \"./CollisionManager\";\r\n\r\nimport EventHandler from \"./events/EventHandler\";\r\nimport MouseEvent from \"./events/MouseEvent\";\r\n\r\nimport Scene from \"./Scene\";\r\n\r\nimport Camera from \"./Camera\";\r\nimport GameObject from \"./GameObject\";\r\nimport Mesh from \"./Mesh\";\r\nimport PointLightSource from \"./PointLightSource\";\r\nimport SphereCollider from \"./SphereCollider\";\r\nimport ParticleEmitter from \"./ParticleEmitter\";\r\nimport RigidBody from \"./RigidBody\";\r\n\r\nimport Matrix4 from \"./math/Matrix4\";\r\nimport Vector3 from \"./math/Vector3\";\r\nimport Transform from \"./Transform\";\r\n\r\n// Shader\r\nimport ShaderHandle from \"./ShaderHandle\";\r\nimport PhongLightingShader from \"./shaders/PhongLightingShader\";\r\nimport AmbientShader from \"./shaders/AmbientShader\";\r\n\r\n/***** Settings *****/\r\n// Default camera position and rotation\r\nconst CAMERA_POSITION = [0.0, 5.0, 60.0];\r\nconst CAMERA_ROTATION = [0.0, 0.0, 0.0];\r\n\r\n// Enum struct for creating different shapes\r\nconst SHAPE = {\r\n    CUBE: 0,\r\n    SPHERE: 1,\r\n    CYLINDER_SMOOTH: 2,\r\n    CYLINDER_SHARP: 3,\r\n    PLANE: 4\r\n};\r\n\r\nconst MS_PER_UPDATE = 4.0;\r\nconst UPDATE_TIME_STEP = 0.01;\r\n\r\nclass Engine {\r\n    constructor() {\r\n        // Scenes works like blocks in the game world.\r\n        // The active scenes are based on the cameras distance to the origin of each scene.\r\n        this.scenes = [];\r\n        this.shaders = new Map();\r\n\r\n        this.viewportAspectRatio = 1.0;\r\n        this.lag = 0.0;\r\n    }\r\n\r\n    /*\r\n    * @brief This is the engines main update function and is called every iteration of the main loop\r\n    */\r\n    run() {\r\n        // Update game loop clock\r\n        Time.update();\r\n\r\n        // Time start of the loop\r\n        let startTime =  Time.now;\r\n\r\n        // Process mouse and keyboard events\r\n        this.processInputEvents();\r\n\r\n        // Add elapsed time to the lag variable\r\n        this.lag += Time.deltaTime;\r\n\r\n        // Make sure the update function is called on a constant rate\r\n        while (this.lag >= MS_PER_UPDATE) {\r\n            // Updates game object animations, ai, physics, etc.\r\n            this.update();\r\n            // Clear momentary events\r\n            EventHandler.resetMouseEvents();\r\n            this.lag -= MS_PER_UPDATE;\r\n        }\r\n\r\n        // Render graphics\r\n        this.render(this.lag/MS_PER_UPDATE);\r\n\r\n        // Hold each frame for a specified number of milliseconds (16 ms locks on roughly 60 fps)\r\n        while ((Time.now - startTime) < 16.0) ; // Sleep\r\n    }\r\n\r\n    update() {\r\n        this.scenes.forEach((scene) => {\r\n            scene.update(UPDATE_TIME_STEP);\r\n        });\r\n\r\n        //// SPRINKLER UPDATE ////\r\n        this.sprinklerTransform.rotate([0.0, 1.0, 0.0]);\r\n        this.sprinklerTimer += UPDATE_TIME_STEP;\r\n\r\n        if (this.sprinklerTimer > 0.1) {\r\n            let pos = [this.sprinklerTransform.position.x, this.sprinklerTransform.position.y, this.sprinklerTransform.position.z];\r\n            this.sprinkler.emitParticle(pos, this.sprinklerTransform.xAxis);\r\n            this.sprinklerTimer = 0.0;\r\n        }\r\n\r\n        this.sprinkler.update(UPDATE_TIME_STEP);\r\n        //// SPRINKLER UPDATE ////\r\n\r\n        //// RAYCAST BULLETS UPDATE ////\r\n        this.raycastBullets.update(UPDATE_TIME_STEP);\r\n        //// RAYCAST BULLETS UPDATE ////\r\n    }\r\n\r\n    render(residualLag) {\r\n        // Set the viewport to the canvas dimensions and update the aspect ratio for the projection matrix\r\n        this.updateViewportDimensions();\r\n\r\n        // Clear screen 3D\r\n        this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);\r\n\r\n        // Draw scenes\r\n        this.gl.enable(this.gl.DEPTH_TEST);\r\n        this.scenes.forEach((scene) => {\r\n            //scene.updateLightPositions();\r\n            scene.draw();\r\n        });\r\n\r\n        //// SPRINKLER RENDER ////\r\n        this.sprinkler.render(this.shaders.get(\"phong\"));\r\n        //// SPRINKLER RENDER ////\r\n\r\n        //// RAYCAST BULLETS RENDER ////\r\n        this.raycastBullets.render(this.shaders.get(\"phong\"));\r\n        //// RAYCAST BULLETS RENDER ////\r\n\r\n        // Display fps and other useful information\r\n        this.editor.render(this.scenes);\r\n    }\r\n\r\n    processInputEvents() {\r\n        // Process editor commands\r\n        this.editor.processUserInput();\r\n\r\n        // If left mouse button is pressed, cast a ray from the mouse cursor position\r\n        if(MouseEvent.mouseDown && MouseEvent.isPressed.leftButton) {\r\n            // Create a raycast bullet for visualization purpose\r\n            //let ray = Raycast.raycastFromMouseCursor(MouseEvent.offsetX, MouseEvent.offsetY, this.camera.transform, this.projectionMatrix, this.canvas.width, this.canvas.height);\r\n            // Offset the bullet start point\r\n            //const bulletOrigin = [ray.origin.x + ray.direction.x*2.0, ray.origin.y + ray.direction.y*2.0, ray.origin.z + ray.direction.z*2.0];\r\n            //this.raycastBullets.emitParticle(bulletOrigin, ray.direction);\r\n        }\r\n    }\r\n\r\n    // This function is called before the game loop is started\r\n    preload() {\r\n        // Initiate static classes\r\n        Time.init();\r\n        EventHandler.init();\r\n        CollisionManager.init();\r\n\r\n        // Set up webgl 2D and 3D context from html canvas. Viewport and render settings are also set.\r\n        this.setUpWebGL();\r\n\r\n        // Create shaders\r\n        let mainShader = new ShaderHandle(this.canvas, PhongLightingShader.vertex, PhongLightingShader.fragment);\r\n        let ambientShader = new ShaderHandle(this.canvas, AmbientShader.vertex, AmbientShader.fragment);\r\n\r\n        // Add them to the shaders container\r\n        this.shaders.set(\"phong\", mainShader);\r\n        this.shaders.set(\"ambient\", ambientShader);\r\n\r\n        // Initialize the main camera\r\n        this.camera = new Camera(this.shaders);\r\n        this.camera.setPosition(CAMERA_POSITION);\r\n        this.camera.setRotation(CAMERA_ROTATION);\r\n\r\n        // Initialize the game engine editor used for managing the game scenes\r\n        this.editor = new GameEditor(this.gl, this.context2D, this.shaders, this.camera, this.canvas);\r\n\r\n        // Create and set the projection matrix for the shaders\r\n        this.fieldOfView = Math.PI / 6;\r\n        this.viewportAspectRatio = this.canvas.width / this.canvas.height;\r\n        this.refreshProjectionMatrix();\r\n\r\n        this.setUpGameContent();\r\n    }\r\n\r\n    setUpGameContent() {\r\n        // Create a scene for the objects\r\n        let defaultScene = new Scene(this.shaders);\r\n\r\n        // Create scene objects\r\n        this.loadDefaultScene(defaultScene);\r\n        // Add to scenes\r\n        this.scenes.push(defaultScene);\r\n\r\n        // Create a bullet for displaying raycast\r\n        let bulletModel = this.createGameObject({\r\n            shape: SHAPE.SPHERE,\r\n            name: 'Cyan Sphere',\r\n            scale: [1.0, 1.0, 1.0],\r\n            position: [0.0, 0.0, 0.0],\r\n            color: [0.0, 1.0, 1.0]\r\n        });\r\n\r\n        let initialSpeed = 80.0;\r\n        let lifetime = 10.0;\r\n        this.raycastBullets = new ParticleEmitter(bulletModel, initialSpeed, lifetime);\r\n        this.raycastBullets.enableGravity(true);\r\n\r\n        this.sprinkler = new ParticleEmitter(bulletModel, 50.0, 30.0);\r\n        this.sprinkler.enableGravity(true);\r\n        this.sprinklerTransform = new Transform();\r\n        this.sprinklerTransform.setPosition([0.0, 40.0, 0.0]);\r\n        this.sprinklerTimer = 0.0;\r\n    }\r\n\r\n    updateViewportDimensions() {\r\n        // Calculate current aspect ratio\r\n        let currentAspectRatio = this.canvas.width / this.canvas.height;\r\n\r\n        // Check if the aspect ratio has changed before going further\r\n        if (Math.abs(this.viewportAspectRatio - currentAspectRatio) < 0.001)\r\n            return;\r\n\r\n        // Save new aspect ratio\r\n        this.viewportAspectRatio = currentAspectRatio;\r\n\r\n        // Refresh the projection matrix and send set it in the shaders\r\n        this.refreshProjectionMatrix();\r\n\r\n        // Update the viewport dimensions to the canvas width\r\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    createGameObject (settings) {\r\n        let mesh = new Mesh(this.gl);\r\n        if (settings.shape === SHAPE.CUBE) {\r\n            mesh.createCube();\r\n        }\r\n        else if (settings.shape === SHAPE.SPHERE) {\r\n            mesh.createSphere(32);\r\n        }\r\n        else if (settings.shape === SHAPE.CYLINDER_SMOOTH) {\r\n            mesh.createCylinderSmooth(32, 1, 1, 2);\r\n        }\r\n        else if(settings.shape === SHAPE.CYLINDER_SHARP) {\r\n            mesh.createCylinderSharp(8, 1, 2);\r\n        }\r\n        else if (settings.shape === SHAPE.PLANE) {\r\n            mesh.createPlane(50,50);\r\n        }\r\n        mesh.setColor(settings.color);\r\n\r\n        let obj = new GameObject (settings.name);\r\n        obj.setPosition(settings.position);\r\n        obj.setScale(settings.scale);\r\n        obj.addMesh(mesh);\r\n\r\n        if (!settings.static) {\r\n            let rb = new RigidBody(settings.position, 5.0);\r\n            rb.enableGravity(true);\r\n            CollisionManager.registerRigidBody(rb);\r\n            obj.setRigidBody(rb);\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    createPointLightSource(settings) {\r\n        // Create the light source component\r\n        let lightSource = new PointLightSource(settings.name);\r\n        lightSource.setPosition(settings.position);\r\n        lightSource.setScale(settings.scale);\r\n        lightSource.setLightColor(settings.color);\r\n        lightSource.setAttenuation(settings.attenuation.kLinear, settings.attenuation.kQuadratic);\r\n\r\n        // Create a model for the light source\r\n        let lightSourceModel = new Mesh(this.gl);\r\n        lightSourceModel.createSphere(8);\r\n        lightSourceModel.setColor(settings.color);\r\n        lightSource.addMesh(lightSourceModel);\r\n\r\n        return lightSource;\r\n    }\r\n\r\n    loadDefaultScene(scene) {\r\n        /*\r\n        // Create a red cube\r\n        let cube = this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Red Cube',\r\n            scale: [2.0, 2.0, 2.0],\r\n            position: [0.0, 4, 0.0],\r\n            color: [1.0, 0.0, 0.0],\r\n            static: false\r\n        });\r\n        // Add rotation to the cube\r\n        cube.customUpdate = function(stepSize) {\r\n            //this.rotate([0.1, 0.1, 0.0]);\r\n        };\r\n        // Add cube to scene\r\n        scene.addGameObject(cube);\r\n        */\r\n\r\n        /*\r\n        // Create a smooth magenta cylinder\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CYLINDER_SMOOTH,\r\n            name: 'Magenta Cylinder',\r\n            scale: [2.0, 2.0, 2.0],\r\n            position: [-8.0, 4.0, 0.0],\r\n            color: [1.0, 0.0, 1.0],\r\n            static: false\r\n        }));\r\n        */\r\n\r\n        // Create a green spheres\r\n\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.SPHERE,\r\n            name: 'Green Sphere',\r\n            scale: [2.0, 2.0, 2.0],\r\n            position: [0.0, 4.0, 0.0],\r\n            color: [0.0, 1.0, 0.0],\r\n            static: false\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.SPHERE,\r\n            name: 'Green Sphere',\r\n            scale: [2.0, 2.0, 2.0],\r\n            position: [-4.2, 4.0, 0.0],\r\n            color: [0.0, 1.0, 0.0],\r\n            static: false\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.SPHERE,\r\n            name: 'Green Sphere',\r\n            scale: [2.0, 2.0, 2.0],\r\n            position: [4.2, 4.0, 0.0],\r\n            color: [0.0, 1.0, 0.0],\r\n            static: false\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.SPHERE,\r\n            name: 'Green Sphere',\r\n            scale: [2.0, 2.0, 2.0],\r\n            position: [8.2, 4.0, 0.0],\r\n            color: [0.0, 1.0, 0.0],\r\n            static: false\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.SPHERE,\r\n            name: 'Green Sphere',\r\n            scale: [2.0, 2.0, 2.0],\r\n            position: [-8.2, 4.0, 0.0],\r\n            color: [0.0, 1.0, 0.0],\r\n            static: false\r\n        }));\r\n\r\n        let wallHeight = 20.0;\r\n        let wallWidth = 100.0;\r\n\r\n        // Create gray floor\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Floor',\r\n            scale: [wallWidth, 0.1, wallWidth],\r\n            position: [0.0, -0.1, 0.0],\r\n            color: [0.75, 0.75, 0.75],\r\n            static: true\r\n        }));\r\n\r\n        // Create blue walls\r\n        let wallColor = [0.0, 0.2, 1.0];\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Left Wall',\r\n            scale: [0.1, wallHeight, wallWidth],\r\n            position: [-wallWidth, wallHeight, 0.0],\r\n            color: wallColor,\r\n            static: true\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Right Wall',\r\n            scale: [0.1, wallHeight, wallWidth],\r\n            position: [wallWidth, wallHeight, 0.0],\r\n            color: wallColor,\r\n            static: true\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Back Wall',\r\n            scale: [wallWidth, wallHeight, 0.1],\r\n            position: [0.0, wallHeight, -wallWidth],\r\n            color: wallColor,\r\n            static: true\r\n        }));\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Front Wall',\r\n            scale: [wallWidth, wallHeight, 0.1],\r\n            position: [0.0, wallHeight, wallWidth],\r\n            color: wallColor,\r\n            static: true\r\n        }));\r\n\r\n        // Create gray roof\r\n        scene.addGameObject(this.createGameObject({\r\n            shape: SHAPE.CUBE,\r\n            name: 'Roof',\r\n            scale: [wallWidth, 0.1, wallWidth],\r\n            position: [0.0, wallHeight * 2.0, 0.0],\r\n            color: [0.65, 0.65, 0.65],\r\n            static: true\r\n        }));\r\n\r\n        // Create a point lights for the scene\r\n        // Add the light source to our scene\r\n        let lampRadius = 0.5;\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [0.0, 2.0 * wallHeight - lampRadius, -wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Right Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [37.5, 2.0 * wallHeight - lampRadius, -wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Left Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [-37.5, 2.0 * wallHeight - lampRadius, -wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Middle Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [0.0, 2.0 * wallHeight - lampRadius, wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Right Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [37.5, 2.0 * wallHeight - lampRadius, wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n        scene.addLightSource(this.createPointLightSource({\r\n            name: \"Left Lamp\",\r\n            scale: [lampRadius, lampRadius, lampRadius],\r\n            position: [-37.5, 2.0 * wallHeight - lampRadius, wallWidth*0.75],\r\n            color: [1.0, 1.0, 1.0],\r\n            attenuation: { // The attenuation constants should make the light travel a maximum distance of 325\r\n                kLinear: 0.014,\r\n                kQuadratic: 0.0007\r\n            }\r\n        }));\r\n\r\n        //// WORLD BOUNDARIES ////\r\n        // Ground plane\r\n        CollisionManager.registerPlaneCollider( {\r\n            normal: new Vector3([0.0, 1.0, 0.0]),\r\n            offset: 0.0\r\n        });\r\n        CollisionManager.registerPlaneCollider( {\r\n            normal: new Vector3([0.0, 0.0, 1.0]),\r\n            offset: wallWidth\r\n        });\r\n        CollisionManager.registerPlaneCollider( {\r\n            normal: new Vector3([-1.0, 0.0, 0.0]),\r\n            offset: wallWidth\r\n        });\r\n        CollisionManager.registerPlaneCollider( {\r\n            normal: new Vector3([1.0, 0.0, 0.0]),\r\n            offset: wallWidth\r\n        });\r\n        CollisionManager.registerPlaneCollider( {\r\n            normal: new Vector3([0.0, 0.0, -1.0]),\r\n            offset: wallWidth\r\n        });\r\n        CollisionManager.registerPlaneCollider( {\r\n            normal: new Vector3([0.0, -1.0, 0.0]),\r\n            offset: wallHeight*2\r\n        });\r\n    }\r\n\r\n    setUpWebGL() {\r\n        // 2D Canvas for text display\r\n        this.context2D = document.getElementById('text-canvas').getContext('2d');\r\n\r\n        // WebGL canvas\r\n        this.canvas = document.getElementById(\"gl-canvas\");\r\n        // Initialize the WebGL context\r\n        this.gl = this.canvas.getContext(\"webgl\");\r\n\r\n        // If WebGL isn't supported\r\n        if (!this.gl) {\r\n            console.log(\"WebGL is not supported\");\r\n            alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n            return 0;\r\n        }\r\n\r\n        // Set the viewport dimensions to the same as the canvas\r\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n        // Set clear color to dark blue, fully opaque\r\n        this.gl.clearColor(0.02, 0.02, 0.02, 1.0);\r\n        // Enable depth so that triangles closer to the camera don't get overlapped by those further away\r\n        this.gl.enable(this.gl.DEPTH_TEST);\r\n        // Only draw \"visible\" sides (memory saving)\r\n        this.gl.enable(this.gl.CULL_FACE);\r\n        this.gl.cullFace(this.gl.BACK);\r\n        this.gl.frontFace(this.gl.CCW);\r\n    }\r\n\r\n    refreshProjectionMatrix() {\r\n        // Create a new projection matrix\r\n        this.projectionMatrix = Matrix4.perspective(this.fieldOfView, this.viewportAspectRatio, 0.1, 10000.0);\r\n\r\n        // Update the projection matrix in the editor\r\n        this.editor.projectionMatrix = this.projectionMatrix;\r\n\r\n        // Update the projection matrix for the shaders\r\n        this.shaders.forEach((shader) => {\r\n            shader.activate();\r\n            shader.setProjectionUniform(this.projectionMatrix);\r\n        });\r\n    }\r\n}\r\n\r\nexport default Engine;"]},"metadata":{},"sourceType":"module"}