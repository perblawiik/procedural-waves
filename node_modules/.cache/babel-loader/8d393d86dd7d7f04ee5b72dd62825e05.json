{"ast":null,"code":"class ShapeGenerator {\n  static generateCubeData(x = 1.0, y = 1.0, z = 1.0) {\n    // Vertex coordinates, normals and texture coordinates\n    let vertexArray = [// Vertex         Normal             Texture coordinates\n    // Vertex 0\n    -x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, // Vertex 1\n    -x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, -x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, -y, z, -1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 2\n    x, -y, z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, -y, z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 3\n    x, -y, -z, 0.0, -1.0, 0.0, 0.0, 0.0, x, -y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, -y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, // Vertex 4\n    -x, y, -z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, -x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 5\n    -x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, -x, y, z, -1.0, 0.0, 0.0, 0.0, 0.0, -x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 6\n    x, y, z, 0.0, 0.0, 1.0, 0.0, 0.0, x, y, z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, z, 0.0, 1.0, 0.0, 0.0, 0.0, // Vertex 7\n    x, y, -z, 0.0, 0.0, -1.0, 0.0, 0.0, x, y, -z, 1.0, 0.0, 0.0, 0.0, 0.0, x, y, -z, 0.0, 1.0, 0.0, 0.0, 0.0]; // Vertex indices\n\n    let indexArray = [// Bottom\n    0, 9, 6, // v0, v3, v2\n    6, 3, 0, // v2, v1, v0\n    // Front\n    4, 7, 18, // v1, v2, v6\n    18, 15, 4, // v6, v5, v1\n    // Left\n    1, 5, 16, // v0, v1, v5\n    16, 12, 1, // v5, v4, v0\n    // Back\n    2, 13, 21, // v0, v4, v7\n    21, 10, 2, // v7, v3, v0\n    // Right\n    8, 11, 22, // v2, v3, v7\n    22, 19, 8, // v7, v6, v2\n    // Top\n    14, 17, 20, // v4, v5, v6\n    20, 23, 14 // v6, v7, v4\n    ];\n    let totalTriangles = 12;\n    let totalVertices = totalTriangles * 3;\n    return {\n      numVertices: totalVertices,\n      vertices: vertexArray,\n      indices: indexArray\n    };\n  }\n\n  static generateSphere(segments, radius) {\n    let numHorizontalSegments = segments; // Minium amount of horizontal segments is 2\n\n    if (numHorizontalSegments < 2) {\n      numHorizontalSegments = 2;\n    } // Number of vertical segments of the sphere\n\n\n    let numVerticalSegments = 2 * numHorizontalSegments;\n    let numVertices = 1 + (numHorizontalSegments - 1) * numVerticalSegments + 1; // top + middle + bottom\n\n    let numTriangles = numVerticalSegments + (numHorizontalSegments - 2) * 4 * numHorizontalSegments + numVerticalSegments; // top + middle + bottom\n    // Floats per row: position(x,y,z), normal(x,y,z), texture(s,t)\n\n    let stride = 8;\n    console.log(\"Vertices size: \" + numVertices * stride);\n    let vertices = []; // Initialize vertex array\n\n    console.log(\"Indices size: \" + numTriangles * 3);\n    let indices = []; // Initialize index array\n\n    /** Generate vertex array **/\n    // Bottom vertex\n\n    vertices[0] = 0.0;\n    vertices[1] = -radius;\n    vertices[2] = 0.0; // Coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Normal\n\n    vertices[6] = 0.5;\n    vertices[7] = 0.0;\n    const PI = Math.PI;\n    let sampleRate = PI / numHorizontalSegments; // Number of steps\n\n    let theta = -PI + sampleRate; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let phi = 0.0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n    // Generate middle part vertices with normals\n\n    let index = stride - 1; // Skip first 7 (the bottom vertex with normal and texture coordinates already specified)\n\n    for (let i = 0; i < numHorizontalSegments - 1; ++i) {\n      let Y = Math.cos(theta); // Y-coordinate\n\n      let R = Math.sin(theta); // XZ-plane\n\n      phi = 0.0;\n\n      for (let j = 0; j < numVerticalSegments; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = radius * R * Math.sin(phi);\n        vertices[++index] = radius * Y;\n        vertices[++index] = radius * R * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = Y;\n        vertices[++index] = R * Math.cos(phi); // Texture Coordinates (s, t)\n\n        vertices[++index] = phi / (2.0 * PI);\n        vertices[++index] = 1.0 + theta / PI;\n        phi += sampleRate;\n      }\n\n      theta += sampleRate;\n    } // Top vertex\n\n\n    vertices[++index] = 0.0;\n    vertices[++index] = radius;\n    vertices[++index] = 0.0; // Coordinates\n\n    vertices[++index] = 0.0;\n    vertices[++index] = 1.0;\n    vertices[++index] = 0.0; // Normal\n\n    vertices[++index] = 0.5;\n    vertices[++index] = 1.0;\n    /** Generate index array */\n    // Bottom cap\n\n    index = -1;\n\n    for (let i = 0; i < numVerticalSegments; ++i) {\n      indices[++index] = 0;\n\n      if (i + 2 <= numVerticalSegments) {\n        indices[++index] = i + 2;\n      } else {\n        indices[++index] = i + 2 - numVerticalSegments;\n      }\n\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = 1;\n\n    for (let i = 0; i < numHorizontalSegments - 2; i++) {\n      for (let j = 0; j < numVerticalSegments - 1; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = numVerticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = numVerticalSegments + v0 + 1;\n        indices[++index] = numVerticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - numVerticalSegments;\n      indices[++index] = numVerticalSegments + v0;\n      indices[++index] = v0 + 1 - numVerticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = numVerticalSegments + v0;\n      ++v0;\n    } // Top cap\n\n\n    let lastVertexIndex = numVertices - 1;\n\n    for (let i = 0; i < numVerticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - numVerticalSegments) {\n        indices[++index] = lastVertexIndex - 2 - i;\n      } else {\n        indices[++index] = lastVertexIndex - numVerticalSegments - 1;\n      }\n\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    indices[numTriangles * 3 - 2] = lastVertexIndex - 1;\n    console.log(\"Vertices after: \" + vertices.length);\n    console.log(\"Indices after: \" + indices.length);\n    return {\n      numVertices: numVertices,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static generateSphereData(segments) {\n    let horizontalSegments = segments;\n\n    if (horizontalSegments < 2) {\n      horizontalSegments = 2;\n    }\n\n    let verticalSegments = 2 * horizontalSegments;\n    let vertices = []; // Bottom vertex and its normal (x, y, z)\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0;\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0;\n    vertices[6] = 0.0;\n    vertices[7] = 0.0;\n    let sampleResolution = Math.PI / horizontalSegments;\n    let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n    // Generate middle part vertices with normals\n\n    let index = 7;\n\n    for (let i = 0; i < horizontalSegments - 1; ++i) {\n      let y = Math.cos(theta);\n      let R = Math.sin(theta); // radius\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = R * Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = R * Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += sampleResolution;\n      }\n\n      theta += sampleResolution;\n    } // Top vertex and its normal (x, y, z)\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom cap\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = 1;\n\n    for (let i = 0; i < horizontalSegments - 2; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top cap\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static generateCylinderData(vertSeg, horizSeg) {\n    let horizontalSegments = horizSeg;\n    let verticalSegments = vertSeg;\n\n    if (horizontalSegments < 1) {\n      horizontalSegments = 1;\n    }\n\n    if (verticalSegments < 4) {\n      verticalSegments = 4;\n    }\n\n    let vertices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -1.0;\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.0;\n    vertices[7] = 0.0; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -Math.PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0;\n    let index = 7; // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = -1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0; // Generate middle part vertices with normals\n\n    for (let i = 0; i <= horizontalSegments; ++i) {\n      let y = Math.cos(theta);\n\n      for (let j = 0; j < verticalSegments + 1; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = 0.0;\n        vertices[++index] = 0.0;\n        phi += 2 * Math.PI / verticalSegments;\n      }\n\n      theta += Math.PI / horizontalSegments;\n    }\n\n    phi = 0; // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < verticalSegments + 1; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = Math.sin(phi);\n      vertices[++index] = 1.0;\n      vertices[++index] = Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 0.0;\n      phi += 2 * Math.PI / verticalSegments;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0;\n    vertices[++index] = 1;\n    vertices[++index] = 0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    let indices = [];\n    index = -1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = 0;\n      if (i + 2 <= verticalSegments) indices[++index] = i + 2;else indices[++index] = i + 2 - verticalSegments;\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = verticalSegments + 2;\n\n    for (let i = 0; i < horizontalSegments; i++) {\n      for (let j = 0; j < verticalSegments; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = verticalSegments + v0 + 1;\n        indices[++index] = verticalSegments + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = verticalSegments + v0;\n      indices[++index] = v0 + 1 - verticalSegments;\n      indices[++index] = v0 + 1;\n      indices[++index] = verticalSegments + v0;\n      ++v0;\n    } // Top circle plane\n\n\n    let lastVertexIndex = vertices.length / 8 - 1;\n\n    for (let i = 0; i < verticalSegments; ++i) {\n      indices[++index] = lastVertexIndex;\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - verticalSegments) indices[++index] = lastVertexIndex - 2 - i;else indices[++index] = lastVertexIndex - verticalSegments - 1;\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n  static createCylinder(vertSegs, horizSegs, radius, height) {\n    if (horizSegs < 1) {\n      horizSegs = 1;\n    }\n\n    if (vertSegs < 4) {\n      vertSegs = 4;\n    }\n\n    let numVertices = 4 * vertSegs + 2 + vertSegs * (horizSegs - 1);\n    let numTriangles = 2 * vertSegs * (1 + horizSegs);\n    let stride = 8;\n    console.log(\"Vertices before: \" + numVertices * stride);\n    let vertices = [];\n    console.log(\"Indices before: \" + 3 * numTriangles);\n    let indices = []; // Bottom center\n    // Vertex coordinates\n\n    vertices[0] = 0.0;\n    vertices[1] = -(height / 2.0);\n    vertices[2] = 0.0; // Normal coordinates\n\n    vertices[3] = 0.0;\n    vertices[4] = -1.0;\n    vertices[5] = 0.0; // Texture coordinates\n\n    vertices[6] = 0.5;\n    vertices[7] = 0.5;\n    const PI = Math.PI; // Go from bottom to top (Y € -PI < theta < PI )\n\n    let theta = -PI; // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n    let phi = 0.0; // Start on index 7\n\n    let index = stride - 1; // Generate vertices and normals for bottom circle plane (all normals should be (0.0, -1.0, 0.0))\n\n    for (let j = 0; j < vertSegs; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = radius * Math.sin(phi);\n      vertices[++index] = -(height / 2.0); // The bottom circle is on the plane y = -height/2\n\n      vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = -1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\n      vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\n      phi += 2.0 * PI / vertSegs;\n    } // Begin at Z = 0 (Z € 0 < phi < 2PI )\n\n\n    phi = 0.0; // Generate middle part vertices with normals (from bottom to top)\n\n    for (let i = 0; i < horizSegs + 1; ++i) {\n      let y = Math.cos(theta);\n\n      for (let j = 0; j < vertSegs; ++j) {\n        // Vertex (x, y, z)\n        vertices[++index] = radius * Math.sin(phi);\n        vertices[++index] = height / 2.0 * y;\n        vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n        vertices[++index] = Math.sin(phi);\n        vertices[++index] = y;\n        vertices[++index] = Math.cos(phi); // Textures (s, t)\n\n        vertices[++index] = phi / (2.0 * PI);\n        vertices[++index] = Math.abs(y * 0.5 - 0.5);\n        phi += 2.0 * PI / vertSegs;\n      }\n\n      phi = 0.0;\n      theta += PI / horizSegs;\n    }\n\n    phi = 0.0; // Generate vertices and normals for top circle plane (all normals should be (0.0, 1.0, 0.0))\n\n    for (let j = 0; j < vertSegs; ++j) {\n      // Vertex (x, y, z)\n      vertices[++index] = radius * Math.sin(phi);\n      vertices[++index] = height / 2.0;\n      vertices[++index] = radius * Math.cos(phi); // Normal (x, y, z)\n\n      vertices[++index] = 0.0;\n      vertices[++index] = 1.0;\n      vertices[++index] = 0.0; // Textures (s, t)\n\n      vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\n      vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\n      phi += 2.0 * PI / vertSegs;\n    } // Top center vertex, normal and texture coordinates\n\n\n    vertices[++index] = 0.0;\n    vertices[++index] = height / 2.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 1.0;\n    vertices[++index] = 0.0;\n    vertices[++index] = 0.5;\n    vertices[++index] = 0.5;\n    /* Generate Index Array */\n    // Bottom circle plane\n\n    index = -1;\n\n    for (let i = 0; i < vertSegs; ++i) {\n      indices[++index] = 0;\n\n      if (i + 2 <= vertSegs) {\n        indices[++index] = i + 2;\n      } else {\n        indices[++index] = i + 2 - vertSegs;\n      }\n\n      indices[++index] = i + 1;\n    } // Middle part\n\n\n    let v0 = vertSegs + 1;\n\n    for (let i = 0; i < horizSegs; i++) {\n      for (let j = 0; j < vertSegs - 1; ++j) {\n        // One rectangle at a time (two triangles)\n        indices[++index] = v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = vertSegs + v0;\n        indices[++index] = v0 + 1;\n        indices[++index] = vertSegs + v0 + 1;\n        indices[++index] = vertSegs + v0;\n        ++v0;\n      }\n\n      indices[++index] = v0;\n      indices[++index] = v0 + 1 - vertSegs;\n      indices[++index] = vertSegs + v0;\n      indices[++index] = v0 + 1 - vertSegs;\n      indices[++index] = v0 + 1;\n      indices[++index] = vertSegs + v0;\n      ++v0;\n    } // Top circle plane\n\n\n    let lastVertexIndex = numVertices - 1;\n\n    for (let i = 0; i < vertSegs; ++i) {\n      indices[++index] = lastVertexIndex;\n\n      if (lastVertexIndex - 2 - i >= lastVertexIndex - vertSegs) {\n        indices[++index] = lastVertexIndex - 2 - i;\n      } else {\n        indices[++index] = lastVertexIndex - 1;\n      }\n\n      indices[++index] = lastVertexIndex - 1 - i;\n    }\n\n    console.log(\"Vertices after: \" + vertices.length);\n    console.log(\"Indices after: \" + indices.length);\n    return {\n      numVertices: indices.length,\n      vertices: vertices,\n      indices: indices\n    };\n  }\n\n}\n\nexport default ShapeGenerator;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\ShapeGenerator.js"],"names":["ShapeGenerator","generateCubeData","x","y","z","vertexArray","indexArray","totalTriangles","totalVertices","numVertices","vertices","indices","generateSphere","segments","radius","numHorizontalSegments","numVerticalSegments","numTriangles","stride","console","log","PI","Math","sampleRate","theta","phi","index","i","Y","cos","R","sin","j","v0","lastVertexIndex","length","generateSphereData","horizontalSegments","verticalSegments","sampleResolution","generateCylinderData","vertSeg","horizSeg","createCylinder","vertSegs","horizSegs","height","abs"],"mappings":"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","sourcesContent":["class ShapeGenerator {\r\n    static generateCubeData(x = 1.0, y = 1.0, z = 1.0) {\r\n        // Vertex coordinates, normals and texture coordinates\r\n        let vertexArray = [\r\n            // Vertex         Normal             Texture coordinates\r\n            // Vertex 0\r\n            -x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n\r\n            // Vertex 1\r\n            -x, -y,  z,     0.0, -1.0,  0.0,      0.0, 0.0,\r\n            -x, -y,  z,     0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, -y,  z,    -1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 2\r\n            x, -y,  z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y,  z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, -y,  z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 3\r\n            x, -y, -z,      0.0, -1.0,  0.0,      0.0, 0.0,\r\n            x, -y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, -y, -z,      1.0,  0.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 4\r\n            -x, y, -z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            -x, y, -z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 5\r\n            -x, y, z,      0.0,  0.0, 1.0,      0.0, 0.0,\r\n            -x, y, z,     -1.0,  0.0,  0.0,      0.0, 0.0,\r\n            -x, y, z,      0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 6\r\n            x, y, z,       0.0,  0.0, 1.0,      0.0, 0.0,\r\n            x, y, z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, z,       0.0,  1.0,  0.0,      0.0, 0.0,\r\n\r\n            // Vertex 7\r\n            x, y, -z,       0.0,  0.0,  -1.0,      0.0, 0.0,\r\n            x, y, -z,       1.0,  0.0,  0.0,      0.0, 0.0,\r\n            x, y, -z,       0.0,  1.0,  0.0,      0.0, 0.0\r\n        ];\r\n\r\n        // Vertex indices\r\n        let indexArray = [\t// Bottom\r\n            0, 9, 6,  // v0, v3, v2\r\n            6, 3, 0,  // v2, v1, v0\r\n\r\n            // Front\r\n            4, 7, 18,  // v1, v2, v6\r\n            18, 15, 4, // v6, v5, v1\r\n\r\n            // Left\r\n            1, 5, 16,  // v0, v1, v5\r\n            16, 12, 1, // v5, v4, v0\r\n\r\n            // Back\r\n            2, 13, 21, // v0, v4, v7\r\n            21, 10, 2, // v7, v3, v0\r\n\r\n            // Right\r\n            8, 11, 22, // v2, v3, v7\r\n            22, 19, 8, // v7, v6, v2\r\n\r\n            // Top\r\n            14, 17, 20, // v4, v5, v6\r\n            20, 23, 14  // v6, v7, v4\r\n        ];\r\n\r\n        let totalTriangles = 12;\r\n        let totalVertices = totalTriangles*3;\r\n\r\n        return {\r\n            numVertices: totalVertices,\r\n            vertices: vertexArray,\r\n            indices: indexArray\r\n        };\r\n    }\r\n\r\n    static generateSphere(segments, radius) {\r\n        let numHorizontalSegments = segments;\r\n        // Minium amount of horizontal segments is 2\r\n        if (numHorizontalSegments < 2) {\r\n            numHorizontalSegments = 2;\r\n        }\r\n\r\n        // Number of vertical segments of the sphere\r\n        let numVerticalSegments = 2 * numHorizontalSegments;\r\n        let numVertices = 1 + (numHorizontalSegments - 1) * numVerticalSegments + 1; // top + middle + bottom\r\n        let numTriangles = numVerticalSegments + (numHorizontalSegments - 2) * 4 * numHorizontalSegments + numVerticalSegments; // top + middle + bottom\r\n\r\n        // Floats per row: position(x,y,z), normal(x,y,z), texture(s,t)\r\n        let stride = 8;\r\n        console.log(\"Vertices size: \" + (numVertices * stride));\r\n        let vertices = []; // Initialize vertex array\r\n        console.log(\"Indices size: \" + (numTriangles * 3));\r\n        let indices = []; // Initialize index array\r\n\r\n        /** Generate vertex array **/\r\n        // Bottom vertex\r\n        vertices[0] = 0.0; vertices[1] = -radius; vertices[2] = 0.0; // Coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0;    vertices[5] = 0.0; // Normal\r\n        vertices[6] = 0.5; vertices[7] = 0.0;\r\n\r\n        const PI = Math.PI;\r\n\r\n        let sampleRate = PI / numHorizontalSegments; // Number of steps\r\n        let theta = -PI + sampleRate; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let  phi = 0.0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = stride - 1; // Skip first 7 (the bottom vertex with normal and texture coordinates already specified)\r\n        for (let i = 0; i < (numHorizontalSegments - 1); ++i) {\r\n            let Y = Math.cos(theta); // Y-coordinate\r\n            let R = Math.sin(theta); // XZ-plane\r\n\r\n            phi = 0.0;\r\n            for (let j = 0; j < numVerticalSegments; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = radius * R * Math.sin(phi);\r\n                vertices[++index] = radius * Y;\r\n                vertices[++index] = radius * R * Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R * Math.sin(phi);\r\n                vertices[++index] = Y;\r\n                vertices[++index] = R * Math.cos(phi);\r\n                // Texture Coordinates (s, t)\r\n                vertices[++index] = phi / (2.0 * PI);\r\n                vertices[++index] = 1.0 + (theta / PI);\r\n\r\n                phi += sampleRate;\r\n            }\r\n            theta += sampleRate;\r\n        }\r\n\r\n        // Top vertex\r\n        vertices[++index] = 0.0; vertices[++index] = radius; vertices[++index] = 0.0; // Coordinates\r\n        vertices[++index] = 0.0; vertices[++index] = 1.0;    vertices[++index] = 0.0; // Normal\r\n        vertices[++index] = 0.5; vertices[++index] = 1.0;\r\n\r\n        /** Generate index array */\r\n        // Bottom cap\r\n        index = -1;\r\n        for (let i = 0; i < numVerticalSegments; ++i) {\r\n            indices[++index] = 0;\r\n            if ((i + 2) <= numVerticalSegments) {\r\n                indices[++index] = i + 2;\r\n            }\r\n            else {\r\n                indices[++index] = (i + 2) - numVerticalSegments;\r\n            }\r\n            indices[++index] = i + 1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for (let i = 0; i < (numHorizontalSegments - 2); i++) {\r\n            for (let j = 0; j < (numVerticalSegments - 1); ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0 + 1;\r\n                indices[++index] = numVerticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - numVerticalSegments;\r\n            indices[++index] = numVerticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - numVerticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = numVerticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top cap\r\n        let lastVertexIndex = numVertices - 1;\r\n        for (let i = 0; i < numVerticalSegments; ++i) {\r\n            indices[++index] = lastVertexIndex;\r\n            if ((lastVertexIndex - 2 - i) >= lastVertexIndex - numVerticalSegments) {\r\n                indices[++index] = lastVertexIndex - 2 - i;\r\n            }\r\n            else {\r\n                indices[++index] = lastVertexIndex - numVerticalSegments - 1;\r\n            }\r\n            indices[++index] = lastVertexIndex - 1 - i;\r\n        }\r\n        indices[(numTriangles * 3) - 2] = (lastVertexIndex - 1);\r\n\r\n        console.log(\"Vertices after: \" + vertices.length);\r\n        console.log(\"Indices after: \" + indices.length);\r\n        return {\r\n            numVertices: numVertices,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static generateSphereData(segments) {\r\n        let horizontalSegments = segments;\r\n\r\n        if (horizontalSegments < 2) {\r\n            horizontalSegments = 2;\r\n        }\r\n        let verticalSegments = 2*horizontalSegments;\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom vertex and its normal (x, y, z)\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        let sampleResolution = Math.PI/horizontalSegments;\r\n        let theta = -Math.PI + sampleResolution; // Go from bottom to top (Y € -PI < theta < PI )\r\n        let phi = 0; // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n\r\n        // Generate middle part vertices with normals\r\n        let index = 7;\r\n        for(let i = 0; i < horizontalSegments-1; ++i) {\r\n            let y = Math.cos(theta);\r\n            let R = Math.sin(theta); // radius\r\n\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = R*Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = R*Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += sampleResolution;\r\n            }\r\n            theta += sampleResolution;\r\n        }\r\n\r\n        // Top vertex and its normal (x, y, z)\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom cap\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = 1;\r\n        for(let i = 0; i < horizontalSegments-2; i++) {\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top cap\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static generateCylinderData (vertSeg, horizSeg) {\r\n        let horizontalSegments = horizSeg;\r\n        let verticalSegments = vertSeg;\r\n\r\n        if (horizontalSegments < 1) {\r\n            horizontalSegments = 1;\r\n        }\r\n        if (verticalSegments < 4) {\r\n            verticalSegments = 4;\r\n        }\r\n\r\n        let vertices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -1.0; vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0; vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.0; vertices[7] = 0.0;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -Math.PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0;\r\n\r\n        let index = 7;\r\n        // Generate vertices and normals for bottom plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0;\r\n        // Generate middle part vertices with normals\r\n        for(let i = 0; i <= horizontalSegments; ++i) {\r\n\r\n            let y = Math.cos(theta);\r\n            for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = 0.0;\r\n                vertices[++index] = 0.0;\r\n\r\n                phi += (2*Math.PI)/verticalSegments;\r\n            }\r\n            theta += Math.PI/horizontalSegments;\r\n        }\r\n\r\n        phi = 0;\r\n        // Generate vertices and normals for top plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < verticalSegments+1; ++j) {\r\n\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = Math.sin(phi);\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 0.0;\r\n\r\n            phi += (2 * Math.PI) / verticalSegments;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0; vertices[++index] = 1; vertices[++index] = 0;\r\n        vertices[++index] = 0.0; vertices[++index] = 0.0;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        let indices = [];\r\n        index = -1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = 0;\r\n\r\n            if( (i+2) <= verticalSegments)\r\n                indices[++index] = i+2;\r\n            else\r\n                indices[++index] = (i+2)-verticalSegments;\r\n\r\n            indices[++index] = i+1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = verticalSegments+2;\r\n        for(let i = 0; i < horizontalSegments; i++) {\r\n\r\n            for (let j = 0; j < verticalSegments; ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = verticalSegments + v0 + 1;\r\n                indices[++index] = verticalSegments + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = verticalSegments + v0;\r\n            indices[++index] = (v0 + 1) - verticalSegments;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = verticalSegments + v0;\r\n            ++v0;\r\n        }\r\n\r\n\r\n        // Top circle plane\r\n        let lastVertexIndex = (vertices.length/8)-1;\r\n        for (let i = 0; i < verticalSegments; ++i) {\r\n\r\n            indices[++index] = lastVertexIndex;\r\n\r\n            if ((lastVertexIndex-2-i) >= lastVertexIndex-verticalSegments )\r\n                indices[++index] = lastVertexIndex-2-i;\r\n            else\r\n                indices[++index] = lastVertexIndex-verticalSegments-1;\r\n\r\n            indices[++index] = lastVertexIndex-1-i;\r\n        }\r\n\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n\r\n    static createCylinder (vertSegs, horizSegs, radius, height) {\r\n        if (horizSegs < 1) {\r\n        horizSegs = 1;\r\n        }\r\n        if (vertSegs < 4) {\r\n            vertSegs = 4;\r\n        }\r\n\r\n        let numVertices = (4 * vertSegs) + 2 + (vertSegs * (horizSegs - 1));\r\n        let numTriangles = 2 * vertSegs * (1 + horizSegs);\r\n\r\n        let stride = 8;\r\n        console.log(\"Vertices before: \" + (numVertices * stride));\r\n        let vertices = [];\r\n        console.log(\"Indices before: \" + (3 * numTriangles));\r\n        let indices = [];\r\n\r\n        // Bottom center\r\n        // Vertex coordinates\r\n        vertices[0] = 0.0; vertices[1] = -(height / 2.0); vertices[2] = 0.0;\r\n        // Normal coordinates\r\n        vertices[3] = 0.0; vertices[4] = -1.0;            vertices[5] = 0.0;\r\n        // Texture coordinates\r\n        vertices[6] = 0.5; vertices[7] = 0.5;\r\n\r\n        const PI = Math.PI;\r\n\r\n        // Go from bottom to top (Y € -PI < theta < PI )\r\n        let theta = -PI;\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        let phi = 0.0;\r\n\r\n        // Start on index 7\r\n        let index = stride - 1;\r\n        // Generate vertices and normals for bottom circle plane (all normals should be (0.0, -1.0, 0.0))\r\n        for (let j = 0; j < vertSegs; ++j) {\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = radius * Math.sin(phi);\r\n            vertices[++index] = -(height / 2.0); // The bottom circle is on the plane y = -height/2\r\n            vertices[++index] = radius * Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = -1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\r\n            vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\r\n\r\n            phi += (2.0 * PI) / vertSegs;\r\n        }\r\n\r\n        // Begin at Z = 0 (Z € 0 < phi < 2PI )\r\n        phi = 0.0;\r\n        // Generate middle part vertices with normals (from bottom to top)\r\n        for (let i = 0; i < (horizSegs + 1); ++i) {\r\n            let y = Math.cos(theta);\r\n            for (let j = 0; j < vertSegs; ++j) {\r\n                // Vertex (x, y, z)\r\n                vertices[++index] = radius * Math.sin(phi);\r\n                vertices[++index] = (height / 2.0) * y;\r\n                vertices[++index] = radius * Math.cos(phi);\r\n                // Normal (x, y, z)\r\n                vertices[++index] = Math.sin(phi);\r\n                vertices[++index] = y;\r\n                vertices[++index] = Math.cos(phi);\r\n                // Textures (s, t)\r\n                vertices[++index] = phi/(2.0*PI);\r\n                vertices[++index] = Math.abs(y * 0.5 - 0.5);\r\n\r\n                phi += (2.0 * PI) / vertSegs;\r\n            }\r\n            phi = 0.0;\r\n            theta += PI / horizSegs;\r\n        }\r\n\r\n        phi = 0.0;\r\n        // Generate vertices and normals for top circle plane (all normals should be (0.0, 1.0, 0.0))\r\n        for (let j = 0; j < vertSegs; ++j) {\r\n            // Vertex (x, y, z)\r\n            vertices[++index] = radius * Math.sin(phi);\r\n            vertices[++index] = (height / 2.0);\r\n            vertices[++index] = radius * Math.cos(phi);\r\n            // Normal (x, y, z)\r\n            vertices[++index] = 0.0;\r\n            vertices[++index] = 1.0;\r\n            vertices[++index] = 0.0;\r\n            // Textures (s, t)\r\n            vertices[++index] = Math.cos(phi) * 0.5 + 0.5;\r\n            vertices[++index] = Math.sin(phi + PI) * 0.5 + 0.5;\r\n\r\n            phi += (2.0 * PI) / vertSegs;\r\n        }\r\n\r\n        // Top center vertex, normal and texture coordinates\r\n        vertices[++index] = 0.0; vertices[++index] = (height / 2.0); vertices[++index] = 0.0;\r\n        vertices[++index] = 0.0; vertices[++index] = 1.0;            vertices[++index] = 0.0;\r\n        vertices[++index] = 0.5; vertices[++index] = 0.5;\r\n\r\n        /* Generate Index Array */\r\n        // Bottom circle plane\r\n        index = -1;\r\n        for (let i = 0; i < vertSegs; ++i) {\r\n            indices[++index] = 0;\r\n            if ((i + 2) <= vertSegs) {\r\n                indices[++index] = i + 2;\r\n            }\r\n            else {\r\n                indices[++index] = (i + 2) - vertSegs;\r\n            }\r\n            indices[++index] = i + 1;\r\n        }\r\n\r\n        // Middle part\r\n        let v0 = vertSegs + 1;\r\n        for (let i = 0; i < horizSegs; i++) {\r\n            for (let j = 0; j < (vertSegs - 1); ++j) {\r\n                // One rectangle at a time (two triangles)\r\n                indices[++index] = v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = vertSegs + v0;\r\n                indices[++index] = v0 + 1;\r\n                indices[++index] = vertSegs + v0 + 1;\r\n                indices[++index] = vertSegs + v0;\r\n                ++v0;\r\n            }\r\n            indices[++index] = v0;\r\n            indices[++index] = (v0 + 1) - vertSegs;\r\n            indices[++index] = vertSegs + v0;\r\n            indices[++index] = (v0 + 1) - vertSegs;\r\n            indices[++index] = v0 + 1;\r\n            indices[++index] = vertSegs + v0;\r\n            ++v0;\r\n        }\r\n\r\n        // Top circle plane\r\n        let lastVertexIndex = numVertices - 1;\r\n        for (let i = 0; i < vertSegs; ++i) {\r\n            indices[++index] = lastVertexIndex;\r\n            if ((lastVertexIndex - 2 - i) >= lastVertexIndex - vertSegs) {\r\n                indices[++index] = lastVertexIndex - 2 - i;\r\n            }\r\n            else {\r\n                indices[++index] = lastVertexIndex - 1;\r\n            }\r\n            indices[++index] = lastVertexIndex - 1 - i;\r\n        }\r\n\r\n        console.log(\"Vertices after: \" + vertices.length);\r\n        console.log(\"Indices after: \" + indices.length);\r\n        return {\r\n            numVertices: indices.length,\r\n            vertices: vertices,\r\n            indices: indices\r\n        };\r\n    }\r\n}\r\n\r\nexport default ShapeGenerator;"]},"metadata":{},"sourceType":"module"}