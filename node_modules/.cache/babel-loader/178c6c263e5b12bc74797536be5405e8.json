{"ast":null,"code":"import Time from \"./Time\";\nimport Transform from \"./Transform\";\nimport ShapeGenerator from \"./ShapeGenerator\";\n\nclass Mesh {\n  constructor(shader) {\n    this.shader = shader;\n    this.gl = shader.gl;\n    this.matrixUniformLocation = shader.modelViewUniformLocation;\n    this.timeUniformLocation = shader.timeUniformLocation;\n    this.totalVertices = 0;\n    this.color = [0.5, 0.5, 0.5];\n    this.shape = null;\n    this.transform = new Transform();\n  }\n\n  clone() {\n    let clone = new Mesh(this.shader);\n    if (this.shape === 'cube') clone.createCube();else if (this.shape === 'sphere') clone.createSphere(64);\n    clone.setColor(this.color);\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  setPosition(pos) {\n    this.transform.setPosition(pos);\n  }\n\n  setScale(scale) {\n    this.transform.setScale(scale);\n  }\n\n  setRotation(rot) {\n    this.transform.setRotation(rot);\n  }\n\n  render() {\n    if (this.shape) {\n      // Activate the shader\n      this.shader.use(); // Set shader uniforms for this mesh\n\n      this.updateUniforms();\n      this.bindBuffersAndEnableAttributes(); // Draw our graphics\n      // Param 1 specifies how to draw from vertices,\n      // param 2 is how many vertices we use to draw\n      // param 3 is what type the elements are\n      // param 4 is the starting point from the array\n\n      this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\n      this.unbindBuffers();\n    } else {\n      console.log(\"ERROR! The mesh got no shape!\");\n    }\n  }\n\n  updateUniforms() {\n    this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\n    this.gl.uniform3fv(this.shader.colorUniformLocation, this.color);\n    this.gl.uniform1f(this.timeUniformLocation, Time.time);\n  }\n\n  unbindBuffers() {\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  bindBuffersAndEnableAttributes() {\n    // Vertex buffer\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); // Enable vertex attribute\n\n    this.gl.vertexAttribPointer(this.shader.positionAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.FALSE, // Don't normalize the data\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\n    0 // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.shader.positionAttributeLocation); // Enable normal attribute\n\n    this.gl.vertexAttribPointer(this.shader.normalAttributeLocation, // Attribute location\n    3, // Number of elements per iteration (x,y,z)\n    this.gl.FLOAT, // Type of elements (32bit floats)\n    this.gl.TRUE, // Not normalized\n    8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\n    3 * Float32Array.BYTES_PER_ELEMENT // Offset from the beginning of a single vertex to this attribute\n    );\n    this.gl.enableVertexAttribArray(this.shader.normalAttributeLocation); // Index buffer\n\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  }\n\n  createCylinder(vertSeg, horizSeg) {\n    this.shape = 'cylinder';\n    let cylinderData = ShapeGenerator.createCylinder(vertSeg, horizSeg, 1.0, 2.0);\n    this.totalVertices = cylinderData.numVertices; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cylinderData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createSphere(segments) {\n    this.shape = 'sphere';\n    let sphereData = ShapeGenerator.createSphere(segments, 1.0);\n    this.totalVertices = sphereData.numVertices; // Create vertex and normal buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sphereData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createCube() {\n    this.shape = 'cube';\n    let cubeData = ShapeGenerator.generateCubeData();\n    this.totalVertices = cubeData.numVertices; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cubeData.vertices), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeData.indices), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  createPlane(rows, columns) {\n    this.shape = 'plane';\n    let index = 0;\n    let x = 0;\n    let vertexArray = []; // Generate and store coordinates in vertex array\n\n    for (let i = 0; i <= columns; ++i) {\n      x = -(rows / 2);\n\n      for (let k = 0; k <= rows; ++k) {\n        // Storing one vertex at the time (x,y,z)\n        vertexArray[index] = x;\n        vertexArray[index + 1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\n\n        vertexArray[index + 2] = -i; // Set normals\n\n        vertexArray[index + 3] = 0.0;\n        vertexArray[index + 4] = 1.0;\n        vertexArray[index + 5] = 0.0; // Texture coordinates\n\n        vertexArray[index + 6] = 0.0;\n        vertexArray[index + 7] = 0.0; // We go from left to right in the direction of x-axis\n\n        ++x; // Increase by three since we store values in three indices at the time\n\n        index += 8;\n      }\n    } // v0-v3 represent the four vertices in one quad\n\n\n    let v0 = 0;\n    let v1 = 1;\n    let v2 = rows + 2;\n    let v3 = rows + 1;\n    index = 0;\n    let indexArray = []; // Store indices in index array\n\n    for (let j = 0; j < columns; ++j) {\n      // Each iteration generates the order of vertex indices for one full quad\n      for (let l = 0; l < rows; ++l) {\n        // Triangle 1\n        indexArray[index] = v0;\n        indexArray[index + 1] = v1;\n        indexArray[index + 2] = v2; // Triangle 2\n\n        indexArray[index + 3] = v2;\n        indexArray[index + 4] = v3;\n        indexArray[index + 5] = v0; // Increase for next quad\n\n        ++v0;\n        ++v1;\n        ++v2;\n        ++v3;\n        index += 6;\n      } // Increase one more time after a full row of quads\n\n\n      ++v0;\n      ++v1;\n      ++v2;\n      ++v3;\n    } //this.totalTriangles = rows*columns*2;\n    //this.totalVertices = this.totalTriangles*3;\n\n\n    this.totalVertices = indexArray.length; // Create vertex buffer\n\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW); // Create index buffer\n\n    this.indexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW); // Unbind buffers\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n}\n\nexport default Mesh;","map":{"version":3,"sources":["G:\\DOKUMENT\\Projekt\\React\\BlueBox\\client\\src\\js\\bluebox\\Mesh.js"],"names":["Time","Transform","ShapeGenerator","Mesh","constructor","shader","gl","matrixUniformLocation","modelViewUniformLocation","timeUniformLocation","totalVertices","color","shape","transform","clone","createCube","createSphere","setColor","setPosition","pos","setScale","scale","setRotation","rot","render","use","updateUniforms","bindBuffersAndEnableAttributes","drawElements","TRIANGLES","UNSIGNED_SHORT","unbindBuffers","console","log","uniformMatrix4fv","FALSE","matrix","uniform3fv","colorUniformLocation","uniform1f","time","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","vertexBuffer","vertexAttribPointer","positionAttributeLocation","FLOAT","Float32Array","BYTES_PER_ELEMENT","enableVertexAttribArray","normalAttributeLocation","TRUE","indexBuffer","createCylinder","vertSeg","horizSeg","cylinderData","numVertices","createBuffer","bufferData","vertices","STATIC_DRAW","Uint16Array","indices","segments","sphereData","cubeData","generateCubeData","createPlane","rows","columns","index","x","vertexArray","i","k","v0","v1","v2","v3","indexArray","j","l","length"],"mappings":"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","sourcesContent":["import Time from \"./Time\";\r\nimport Transform from \"./Transform\";\r\nimport ShapeGenerator from \"./ShapeGenerator\";\r\n\r\nclass Mesh {\r\n    constructor(shader) {\r\n        this.shader = shader;\r\n        this.gl = shader.gl;\r\n\r\n        this.matrixUniformLocation = shader.modelViewUniformLocation;\r\n        this.timeUniformLocation = shader.timeUniformLocation;\r\n\r\n        this.totalVertices = 0;\r\n\r\n        this.color = [0.5, 0.5, 0.5];\r\n        this.shape = null;\r\n\r\n        this.transform = new Transform();\r\n    }\r\n\r\n    clone() {\r\n        let clone = new Mesh(this.shader);\r\n\r\n        if (this.shape === 'cube')\r\n            clone.createCube();\r\n        else if (this.shape === 'sphere')\r\n            clone.createSphere(64);\r\n\r\n        clone.setColor(this.color);\r\n        clone.transform = this.transform.clone();\r\n        return clone;\r\n    }\r\n\r\n    setColor(color) {\r\n        this.color = color;\r\n    }\r\n\r\n    setPosition(pos) {\r\n        this.transform.setPosition(pos);\r\n    }\r\n\r\n    setScale (scale) {\r\n        this.transform.setScale(scale);\r\n    }\r\n\r\n    setRotation (rot) {\r\n        this.transform.setRotation(rot);\r\n    }\r\n\r\n    render() {\r\n        if (this.shape) {\r\n            // Activate the shader\r\n            this.shader.use();\r\n            // Set shader uniforms for this mesh\r\n            this.updateUniforms();\r\n            this.bindBuffersAndEnableAttributes();\r\n            // Draw our graphics\r\n            // Param 1 specifies how to draw from vertices,\r\n            // param 2 is how many vertices we use to draw\r\n            // param 3 is what type the elements are\r\n            // param 4 is the starting point from the array\r\n            this.gl.drawElements(this.gl.TRIANGLES, this.totalVertices, this.gl.UNSIGNED_SHORT, 0);\r\n            this.unbindBuffers();\r\n        }\r\n        else {\r\n            console.log(\"ERROR! The mesh got no shape!\");\r\n        }\r\n    }\r\n\r\n    updateUniforms() {\r\n        this.gl.uniformMatrix4fv(this.matrixUniformLocation, this.gl.FALSE, this.transform.matrix);\r\n        this.gl.uniform3fv(this.shader.colorUniformLocation, this.color);\r\n        this.gl.uniform1f(this.timeUniformLocation, Time.time);\r\n    }\r\n\r\n    unbindBuffers() {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    bindBuffersAndEnableAttributes() {\r\n        // Vertex buffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n\r\n        // Enable vertex attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.shader.positionAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.FALSE, // Don't normalize the data\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next vertex\r\n            0// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.shader.positionAttributeLocation);\r\n\r\n        // Enable normal attribute\r\n        this.gl.vertexAttribPointer(\r\n            this.shader.normalAttributeLocation, // Attribute location\r\n            3, // Number of elements per iteration (x,y,z)\r\n            this.gl.FLOAT, // Type of elements (32bit floats)\r\n            this.gl.TRUE, // Not normalized\r\n            8 * Float32Array.BYTES_PER_ELEMENT, // how many bytes to move to the next normal\r\n            3 * Float32Array.BYTES_PER_ELEMENT// Offset from the beginning of a single vertex to this attribute\r\n        );\r\n        this.gl.enableVertexAttribArray(this.shader.normalAttributeLocation);\r\n\r\n        // Index buffer\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n    }\r\n\r\n    createCylinder (vertSeg, horizSeg) {\r\n        this.shape = 'cylinder';\r\n\r\n        let cylinderData = ShapeGenerator.createCylinder(vertSeg, horizSeg, 1.0, 2.0);\r\n        this.totalVertices = cylinderData.numVertices;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cylinderData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createSphere (segments) {\r\n        this.shape = 'sphere';\r\n\r\n        let sphereData = ShapeGenerator.createSphere(segments, 1.0);\r\n        this.totalVertices = sphereData.numVertices;\r\n\r\n        // Create vertex and normal buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sphereData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createCube() {\r\n        this.shape = 'cube';\r\n        let cubeData = ShapeGenerator.generateCubeData();\r\n        this.totalVertices = cubeData.numVertices;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cubeData.vertices), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeData.indices), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    }\r\n\r\n    createPlane (rows, columns) {\r\n        this.shape = 'plane';\r\n\r\n        let index = 0;\r\n        let x = 0;\r\n        let vertexArray = [];\r\n        // Generate and store coordinates in vertex array\r\n        for (let i = 0; i <= columns; ++i) {\r\n            x = -(rows/2);\r\n            for (let k = 0; k <= rows; ++k) {\r\n                // Storing one vertex at the time (x,y,z)\r\n                vertexArray[index] = x;\r\n                vertexArray[index+1] = 0; // y will always be 0 since the floor is flat (xz-plane is being used)\r\n                vertexArray[index+2] = -i;\r\n\r\n                // Set normals\r\n                vertexArray[index+3] = 0.0;\r\n                vertexArray[index+4] = 1.0;\r\n                vertexArray[index+5] = 0.0;\r\n\r\n                // Texture coordinates\r\n                vertexArray[index+6] = 0.0;\r\n                vertexArray[index+7] = 0.0;\r\n\r\n                // We go from left to right in the direction of x-axis\r\n                ++x;\r\n                // Increase by three since we store values in three indices at the time\r\n                index += 8;\r\n            }\r\n        }\r\n\r\n        // v0-v3 represent the four vertices in one quad\r\n        let v0 = 0;\r\n        let v1 = 1;\r\n        let v2 = rows+2;\r\n        let v3 = rows+1;\r\n        index = 0;\r\n        let indexArray = [];\r\n        // Store indices in index array\r\n        for (let j = 0; j < columns; ++j) {\r\n            // Each iteration generates the order of vertex indices for one full quad\r\n            for (let l = 0; l < rows; ++l) {\r\n                // Triangle 1\r\n                indexArray[index] = v0;\r\n                indexArray[index + 1] = v1;\r\n                indexArray[index + 2] = v2;\r\n                // Triangle 2\r\n                indexArray[index + 3] = v2;\r\n                indexArray[index + 4] = v3;\r\n                indexArray[index + 5] = v0;\r\n\r\n                // Increase for next quad\r\n                ++v0;\r\n                ++v1;\r\n                ++v2;\r\n                ++v3;\r\n                index += 6;\r\n            }\r\n            // Increase one more time after a full row of quads\r\n            ++v0;\r\n            ++v1;\r\n            ++v2;\r\n            ++v3;\r\n        }\r\n        //this.totalTriangles = rows*columns*2;\r\n        //this.totalVertices = this.totalTriangles*3;\r\n        this.totalVertices = indexArray.length;\r\n\r\n        // Create vertex buffer\r\n        this.vertexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Create index buffer\r\n        this.indexBuffer = this.gl.createBuffer();\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexArray), this.gl.STATIC_DRAW);\r\n\r\n        // Unbind buffers\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\r\n    };\r\n}\r\n\r\nexport default Mesh;"]},"metadata":{},"sourceType":"module"}